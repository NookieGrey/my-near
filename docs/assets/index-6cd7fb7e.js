var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-6cd7fb7e.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i2 = 0; i2 < m2.length; i2++) {
        const e2 = m2[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill2() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity)
          fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy)
          fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n2) {
      if (n2.__esModule)
        return n2;
      var f2 = n2.default;
      if (typeof f2 == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            var args = [null];
            args.push.apply(args, arguments);
            var Ctor = Function.bind.apply(f2, args);
            return new Ctor();
          }
          return f2.apply(this, arguments);
        };
        a.prototype = f2.prototype;
      } else
        a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n2).forEach(function(k2) {
        var d2 = Object.getOwnPropertyDescriptor(n2, k2);
        Object.defineProperty(a, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return n2[k2];
          }
        });
      });
      return a;
    }
    var jsxRuntimeExports = {};
    var jsxRuntime = {
      get exports() {
        return jsxRuntimeExports;
      },
      set exports(v2) {
        jsxRuntimeExports = v2;
      }
    };
    var reactJsxRuntime_production_min = {};
    var reactExports = {};
    var react = {
      get exports() {
        return reactExports;
      },
      set exports(v2) {
        reactExports = v2;
      }
    };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$2 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
    function A$2(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z$2 && a[z$2] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B$1 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$1 = Object.assign, D$1 = {};
    function E$1(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    E$1.prototype.isReactComponent = {};
    E$1.prototype.setState = function(a, b2) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b2, "setState");
    };
    E$1.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E$1.prototype;
    function G$1(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    var H$1 = G$1.prototype = new F();
    H$1.constructor = G$1;
    C$1(H$1, E$1.prototype);
    H$1.isPureReactComponent = true;
    var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
    function M$1(a, b2, e2) {
      var d2, c2 = {}, k2 = null, h2 = null;
      if (null != b2)
        for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
          J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        c2.children = e2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a && a.defaultProps)
        for (d2 in g2 = a.defaultProps, g2)
          void 0 === c2[d2] && (c2[d2] = g2[d2]);
      return { $$typeof: l$2, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
    }
    function N$1(a, b2) {
      return { $$typeof: l$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O$1(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l$2;
    }
    function escape(a) {
      var b2 = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b2[a2];
      });
    }
    var P$1 = /\/+/g;
    function Q$1(a, b2) {
      return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
    }
    function R$1(a, b2, e2, d2, c2) {
      var k2 = typeof a;
      if ("undefined" === k2 || "boolean" === k2)
        a = null;
      var h2 = false;
      if (null === a)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l$2:
              case n$2:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
          return a2;
        })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
      h2 = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I$1(a))
        for (var g2 = 0; g2 < a.length; g2++) {
          k2 = a[g2];
          var f2 = d2 + Q$1(k2, g2);
          h2 += R$1(k2, b2, e2, f2, c2);
        }
      else if (f2 = A$2(a), "function" === typeof f2)
        for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
          k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
      else if ("object" === k2)
        throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$1(a, b2, e2) {
      if (null == a)
        return a;
      var d2 = [], c2 = 0;
      R$1(a, d2, "", "", function(a2) {
        return b2.call(e2, a2, c2++);
      });
      return d2;
    }
    function T$1(a) {
      if (-1 === a._status) {
        var b2 = a._result;
        b2 = b2();
        b2.then(function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b3;
        }, function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b3;
        });
        -1 === a._status && (a._status = 0, a._result = b2);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
      S$1(a, function() {
        b2.apply(this, arguments);
      }, e2);
    }, count: function(a) {
      var b2 = 0;
      S$1(a, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a) {
      return S$1(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O$1(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E$1;
    react_production_min.Fragment = p$3;
    react_production_min.Profiler = r$1;
    react_production_min.PureComponent = G$1;
    react_production_min.StrictMode = q$2;
    react_production_min.Suspense = w$1;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
    react_production_min.cloneElement = function(a, b2, e2) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
        void 0 !== b2.key && (c2 = "" + b2.key);
        if (a.type && a.type.defaultProps)
          var g2 = a.type.defaultProps;
        for (f2 in b2)
          J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d2.children = e2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        d2.children = g2;
      }
      return { $$typeof: l$2, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t$1, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a) {
      var b2 = M$1.bind(null, a);
      b2.type = a;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v$2, render: a };
    };
    react_production_min.isValidElement = O$1;
    react_production_min.lazy = function(a) {
      return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
    };
    react_production_min.memo = function(a, b2) {
      return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.startTransition = function(a) {
      var b2 = V$1.transition;
      V$1.transition = {};
      try {
        a();
      } finally {
        V$1.transition = b2;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a, b2) {
      return U$1.current.useCallback(a, b2);
    };
    react_production_min.useContext = function(a) {
      return U$1.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U$1.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b2) {
      return U$1.current.useEffect(a, b2);
    };
    react_production_min.useId = function() {
      return U$1.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b2, e2) {
      return U$1.current.useImperativeHandle(a, b2, e2);
    };
    react_production_min.useInsertionEffect = function(a, b2) {
      return U$1.current.useInsertionEffect(a, b2);
    };
    react_production_min.useLayoutEffect = function(a, b2) {
      return U$1.current.useLayoutEffect(a, b2);
    };
    react_production_min.useMemo = function(a, b2) {
      return U$1.current.useMemo(a, b2);
    };
    react_production_min.useReducer = function(a, b2, e2) {
      return U$1.current.useReducer(a, b2, e2);
    };
    react_production_min.useRef = function(a) {
      return U$1.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U$1.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b2, e2) {
      return U$1.current.useSyncExternalStore(a, b2, e2);
    };
    react_production_min.useTransition = function() {
      return U$1.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    (function(module2) {
      {
        module2.exports = react_production_min;
      }
    })(react);
    const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$2 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React$1
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
    function q$1(c2, a, g2) {
      var b2, d2 = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a.key && (e2 = "" + a.key);
      void 0 !== a.ref && (h2 = a.ref);
      for (b2 in a)
        m$2.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
      if (c2 && c2.defaultProps)
        for (b2 in a = c2.defaultProps, a)
          void 0 === d2[b2] && (d2[b2] = a[b2]);
      return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
    }
    reactJsxRuntime_production_min.Fragment = l$1;
    reactJsxRuntime_production_min.jsx = q$1;
    reactJsxRuntime_production_min.jsxs = q$1;
    (function(module2) {
      {
        module2.exports = reactJsxRuntime_production_min;
      }
    })(jsxRuntime);
    const jsx = jsxRuntimeExports.jsx;
    const jsxs = jsxRuntimeExports.jsxs;
    var client = {};
    var reactDomExports = {};
    var reactDom = {
      get exports() {
        return reactDomExports;
      },
      set exports(v2) {
        reactDomExports = v2;
      }
    };
    var reactDom_production_min = {};
    var schedulerExports = {};
    var scheduler = {
      get exports() {
        return schedulerExports;
      },
      set exports(v2) {
        schedulerExports = v2;
      }
    };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a, b2) {
        var c2 = a.length;
        a.push(b2);
        a:
          for (; 0 < c2; ) {
            var d2 = c2 - 1 >>> 1, e2 = a[d2];
            if (0 < g2(e2, b2))
              a[d2] = b2, a[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function h2(a) {
        return 0 === a.length ? null : a[0];
      }
      function k2(a) {
        if (0 === a.length)
          return null;
        var b2 = a[0], c2 = a.pop();
        if (c2 !== b2) {
          a[0] = c2;
          a:
            for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
              var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
              if (0 > g2(C2, c2))
                n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
              else if (n2 < e2 && 0 > g2(x2, c2))
                a[d2] = x2, a[n2] = c2, d2 = n2;
              else
                break a;
            }
        }
        return b2;
      }
      function g2(a, b2) {
        var c2 = a.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a) {
        for (var b2 = h2(t2); null !== b2; ) {
          if (null === b2.callback)
            k2(t2);
          else if (b2.startTime <= a)
            k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
          else
            break;
          b2 = h2(t2);
        }
      }
      function H2(a) {
        B2 = false;
        G2(a);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b2 = h2(t2);
            null !== b2 && K2(H2, b2.startTime - a);
          }
      }
      function J2(a, b2) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b2);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
            var d2 = v2.callback;
            if ("function" === typeof d2) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d2(v2.expirationTime <= b2);
              b2 = exports2.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
              G2(b2);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b2);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a = exports2.unstable_now();
          Q2 = a;
          var b2 = true;
          try {
            b2 = O2(true, a);
          } finally {
            b2 ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a) {
        O2 = a;
        N2 || (N2 = true, S2());
      }
      function K2(a, b2) {
        L2 = D2(function() {
          a(exports2.unstable_now());
        }, b2);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y2;
        }
        var c2 = y2;
        y2 = b2;
        try {
          return a();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a, b2) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c2 = y2;
        y2 = a;
        try {
          return b2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a, b2, c2) {
        var d2 = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
        return a;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a) {
        var b2 = y2;
        return function() {
          var c2 = y2;
          y2 = b2;
          try {
            return a.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    (function(module2) {
      {
        module2.exports = scheduler_production_min;
      }
    })(scheduler);
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p$1(a) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b2) {
      ha(a, b2);
      ha(a + "Capture", b2);
    }
    function ha(a, b2) {
      ea[a] = b2;
      for (a = 0; a < b2.length; a++)
        da.add(b2[a]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      if (ja.call(ma, a))
        return true;
      if (ja.call(la, a))
        return false;
      if (ka.test(a))
        return ma[a] = true;
      la[a] = true;
      return false;
    }
    function pa(a, b2, c2, d2) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b2) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b2, c2, d2) {
      if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }
    function v$1(a, b2, c2, d2, e2, f2, g2) {
      this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
      this.attributeName = d2;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a;
      this.type = b2;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var z$1 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z$1[a] = new v$1(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b2 = a[0];
      z$1[b2] = new v$1(b2, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z$1[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z$1[a] = new v$1(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z$1[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z$1[a] = new v$1(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z$1[a] = new v$1(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z$1[a] = new v$1(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z$1[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b2 = a.replace(
        ra,
        sa
      );
      z$1[b2] = new v$1(b2, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b2 = a.replace(ra, sa);
      z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b2 = a.replace(ra, sa);
      z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b2, c2, d2) {
      var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
      if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
        qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A$1 = Object.assign, La;
    function Ma(a) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          La = b2 && b2[1] || "";
        }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa(a, b2) {
      if (!a || Na)
        return "";
      Na = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (l2) {
              var d2 = l2;
            }
            Reflect.construct(a, [], b2);
          } else {
            try {
              b2.call();
            } catch (l2) {
              d2 = l2;
            }
            a.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d2 = l2;
          }
          a();
        }
      } catch (l2) {
        if (l2 && d2 && "string" === typeof l2.stack) {
          for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                    var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                    a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                    return k2;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c2;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a)
        return null;
      if ("function" === typeof a)
        return a.displayName || a.name || null;
      if ("string" === typeof a)
        return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b2 = a.render;
            a = a.displayName;
            a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
          case Ha:
            b2 = a._payload;
            a = a._init;
            try {
              return Qa(a(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function Ra(a) {
      var b2 = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b2.displayName || "Context") + ".Consumer";
        case 10:
          return (b2._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b2;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b2);
        case 8:
          return b2 === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b2)
            return b2.displayName || b2.name || null;
          if ("string" === typeof b2)
            return b2;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b2 = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
    }
    function Ua(a) {
      var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
      if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a, b2, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a2) {
          d2 = "" + a2;
          f2.call(this, a2);
        } });
        Object.defineProperty(a, b2, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d2;
        }, setValue: function(a2) {
          d2 = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b2];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a)
        return false;
      var b2 = a._valueTracker;
      if (!b2)
        return true;
      var c2 = b2.getValue();
      var d2 = "";
      a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d2;
      return a !== c2 ? (b2.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a)
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b2) {
        return a.body;
      }
    }
    function Ya(a, b2) {
      var c2 = b2.checked;
      return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
    }
    function Za(a, b2) {
      var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
      c2 = Sa(null != b2.value ? b2.value : c2);
      a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
    }
    function ab(a, b2) {
      b2 = b2.checked;
      null != b2 && ta(a, "checked", b2, false);
    }
    function bb(a, b2) {
      ab(a, b2);
      var c2 = Sa(b2.value), d2 = b2.type;
      if (null != c2)
        if ("number" === d2) {
          if (0 === c2 && "" === a.value || a.value != c2)
            a.value = "" + c2;
        } else
          a.value !== "" + c2 && (a.value = "" + c2);
      else if ("submit" === d2 || "reset" === d2) {
        a.removeAttribute("value");
        return;
      }
      b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
      null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
    }
    function db(a, b2, c2) {
      if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
        var d2 = b2.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
          return;
        b2 = "" + a._wrapperState.initialValue;
        c2 || b2 === a.value || (a.value = b2);
        a.defaultValue = b2;
      }
      c2 = a.name;
      "" !== c2 && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c2 && (a.name = c2);
    }
    function cb(a, b2, c2) {
      if ("number" !== b2 || Xa(a.ownerDocument) !== a)
        null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a, b2, c2, d2) {
      a = a.options;
      if (b2) {
        b2 = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b2["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a.length; c2++)
          e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b2 = null;
        for (e2 = 0; e2 < a.length; e2++) {
          if (a[e2].value === c2) {
            a[e2].selected = true;
            d2 && (a[e2].defaultSelected = true);
            return;
          }
          null !== b2 || a[e2].disabled || (b2 = a[e2]);
        }
        null !== b2 && (b2.selected = true);
      }
    }
    function gb(a, b2) {
      if (null != b2.dangerouslySetInnerHTML)
        throw Error(p$1(91));
      return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b2) {
      var c2 = b2.value;
      if (null == c2) {
        c2 = b2.children;
        b2 = b2.defaultValue;
        if (null != c2) {
          if (null != b2)
            throw Error(p$1(92));
          if (eb(c2)) {
            if (1 < c2.length)
              throw Error(p$1(93));
            c2 = c2[0];
          }
          b2 = c2;
        }
        null == b2 && (b2 = "");
        c2 = b2;
      }
      a._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a, b2) {
      var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
      null != d2 && (a.defaultValue = "" + d2);
    }
    function jb(a) {
      var b2 = a.textContent;
      b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b2) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b2, c2, d2, e2);
        });
      } : a;
    }(function(a, b2) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
        a.innerHTML = b2;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = mb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b2.firstChild; )
          a.appendChild(b2.firstChild);
      }
    });
    function ob(a, b2) {
      if (b2) {
        var c2 = a.firstChild;
        if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b2;
          return;
        }
      }
      a.textContent = b2;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b2) {
        b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b2] = pb[a];
      });
    });
    function rb(a, b2, c2) {
      return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
    }
    function sb(a, b2) {
      a = a.style;
      for (var c2 in b2)
        if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a.setProperty(c2, e2) : a[c2] = e2;
        }
    }
    var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b2) {
      if (b2) {
        if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
          throw Error(p$1(137, a));
        if (null != b2.dangerouslySetInnerHTML) {
          if (null != b2.children)
            throw Error(p$1(60));
          if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
            throw Error(p$1(61));
        }
        if (null != b2.style && "object" !== typeof b2.style)
          throw Error(p$1(62));
      }
    }
    function vb(a, b2) {
      if (-1 === a.indexOf("-"))
        return "string" === typeof b2.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb)
          throw Error(p$1(280));
        var b2 = a.stateNode;
        b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b2 = Ab;
        Ab = zb = null;
        Bb(a);
        if (b2)
          for (a = 0; a < b2.length; a++)
            Bb(b2[a]);
      }
    }
    function Gb(a, b2) {
      return a(b2);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b2, c2) {
      if (Ib)
        return a(b2, c2);
      Ib = true;
      try {
        return Gb(a, b2, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a, b2) {
      var c2 = a.stateNode;
      if (null === c2)
        return null;
      var d2 = Db(c2);
      if (null === d2)
        return null;
      c2 = d2[b2];
      a:
        switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d2;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(p$1(231, b2, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
    function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b2.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p$1(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a) {
      var b2 = a, c2 = a;
      if (a.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a = b2;
        do
          b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
        while (a);
      }
      return 3 === b2.tag ? c2 : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b2 = a.memoizedState;
        null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
        if (null !== b2)
          return b2.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a)
        throw Error(p$1(188));
    }
    function Yb(a) {
      var b2 = a.alternate;
      if (!b2) {
        b2 = Vb(a);
        if (null === b2)
          throw Error(p$1(188));
        return b2 !== a ? null : a;
      }
      for (var c2 = a, d2 = b2; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d2 = e2.return;
          if (null !== d2) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return Xb(e2), a;
            if (f2 === d2)
              return Xb(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(p$1(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(p$1(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(p$1(190));
      }
      if (3 !== c2.tag)
        throw Error(p$1(188));
      return c2.stateNode.current === c2 ? a : b2;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag)
        return a;
      for (a = a.child; null !== a; ) {
        var b2 = $b(a);
        if (null !== b2)
          return b2;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b2) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b2) {
      var c2 = a.pendingLanes;
      if (0 === c2)
        return 0;
      var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
      if (0 !== g2) {
        var h2 = g2 & ~e2;
        0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
      } else
        g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
      if (0 === d2)
        return 0;
      if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
        return b2;
      0 !== (d2 & 4) && (d2 |= c2 & 16);
      b2 = a.entangledLanes;
      if (0 !== b2)
        for (a = a.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
      return d2;
    }
    function vc(a, b2) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b2 + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b2 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b2) {
      for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
        var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
        if (-1 === k2) {
          if (0 === (h2 & c2) || 0 !== (h2 & d2))
            e2[g2] = vc(h2, b2);
        } else
          k2 <= b2 && (a.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a);
      return b2;
    }
    function Ac(a, b2, c2) {
      a.pendingLanes |= b2;
      536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b2 = 31 - oc(b2);
      a[b2] = c2;
    }
    function Bc(a, b2) {
      var c2 = a.pendingLanes & ~b2;
      a.pendingLanes = b2;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b2;
      a.mutableReadLanes &= b2;
      a.entangledLanes &= b2;
      b2 = a.entanglements;
      var d2 = a.eventTimes;
      for (a = a.expirationTimes; 0 < c2; ) {
        var e2 = 31 - oc(c2), f2 = 1 << e2;
        b2[e2] = 0;
        d2[e2] = -1;
        a[e2] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a, b2) {
      var c2 = a.entangledLanes |= b2;
      for (a = a.entanglements; c2; ) {
        var d2 = 31 - oc(c2), e2 = 1 << d2;
        e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
        c2 &= ~e2;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b2) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b2.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b2.pointerId);
      }
    }
    function Tc(a, b2, c2, d2, e2, f2) {
      if (null === a || a.nativeEvent !== f2)
        return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
      a.eventSystemFlags |= d2;
      b2 = a.targetContainers;
      null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
      return a;
    }
    function Uc(a, b2, c2, d2, e2) {
      switch (b2) {
        case "focusin":
          return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
      }
      return false;
    }
    function Vc(a) {
      var b2 = Wc(a.target);
      if (null !== b2) {
        var c2 = Vb(b2);
        if (null !== c2) {
          if (b2 = c2.tag, 13 === b2) {
            if (b2 = Wb(c2), null !== b2) {
              a.blockedOn = b2;
              Ic(a.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn)
        return false;
      for (var b2 = a.targetContainers; 0 < b2.length; ) {
        var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
        if (null === c2) {
          c2 = a.nativeEvent;
          var d2 = new c2.constructor(c2.type, c2);
          wb = d2;
          c2.target.dispatchEvent(d2);
          wb = null;
        } else
          return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
        b2.shift();
      }
      return true;
    }
    function Zc(a, b2, c2) {
      Xc(a) && c2.delete(b2);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b2) {
      a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b2(b3) {
        return ad(b3, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d2 = Kc[c2];
          d2.blockedOn === a && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b2);
      Pc.forEach(b2);
      for (c2 = 0; c2 < Qc.length; c2++)
        d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
        Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function gd(a, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function fd(a, b2, c2, d2) {
      if (dd) {
        var e2 = Yc(a, b2, c2, d2);
        if (null === e2)
          hd(a, b2, d2, id, c2), Sc(a, d2);
        else if (Uc(e2, a, b2, c2, d2))
          d2.stopPropagation();
        else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e2; ) {
            var f2 = Cb(e2);
            null !== f2 && Ec(f2);
            f2 = Yc(a, b2, c2, d2);
            null === f2 && hd(a, b2, d2, id, c2);
            if (f2 === e2)
              break;
            e2 = f2;
          }
          null !== e2 && d2.stopPropagation();
        } else
          hd(a, b2, d2, null, c2);
      }
    }
    var id = null;
    function Yc(a, b2, c2, d2) {
      id = null;
      a = xb(d2);
      a = Wc(a);
      if (null !== a)
        if (b2 = Vb(a), null === b2)
          a = null;
        else if (c2 = b2.tag, 13 === c2) {
          a = Wb(b2);
          if (null !== a)
            return a;
          a = null;
        } else if (3 === c2) {
          if (b2.stateNode.current.memoizedState.isDehydrated)
            return 3 === b2.tag ? b2.stateNode.containerInfo : null;
          a = null;
        } else
          b2 !== a && (a = null);
      id = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a = 0; a < c2 && b2[a] === e2[a]; a++)
        ;
      var g2 = c2 - a;
      for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
        ;
      return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
    }
    function od(a) {
      var b2 = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b2(b3, d2, e2, f2, g2) {
        this._reactName = b3;
        this._targetInst = e2;
        this.type = d2;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a)
          a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A$1(b2.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b2;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b2 = this.nativeEvent;
      return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A$1({}, ud, { key: function(a) {
      if (a.key) {
        var b2 = Md[a.key] || a.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a, b2) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b2.keyCode);
        case "keydown":
          return 229 !== b2.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b2) {
      switch (a) {
        case "compositionend":
          return he(b2);
        case "keypress":
          if (32 !== b2.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b2.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b2) {
      if (ie)
        return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
            if (b2.char && 1 < b2.char.length)
              return b2.char;
            if (b2.which)
              return String.fromCharCode(b2.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b2.locale ? null : b2.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
    }
    function ne(a, b2, c2, d2) {
      Eb(d2);
      b2 = oe(b2, "onChange");
      0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
    }
    var pe = null, qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b2 = ue(a);
      if (Wa(b2))
        return a;
    }
    function ve(a, b2) {
      if ("change" === a)
        return b2;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b2 = [];
        ne(b2, qe, a, xb(a));
        Jb(re, b2);
      }
    }
    function Ce(a, b2, c2) {
      "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return te(qe);
    }
    function Ee(a, b2) {
      if ("click" === a)
        return te(b2);
    }
    function Fe(a, b2) {
      if ("input" === a || "change" === a)
        return te(b2);
    }
    function Ge(a, b2) {
      return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b2) {
      if (He(a, b2))
        return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
        return false;
      var c2 = Object.keys(a), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
          return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke(a, b2) {
      var c2 = Je(a);
      a = 0;
      for (var d2; c2; ) {
        if (3 === c2.nodeType) {
          d2 = a + c2.textContent.length;
          if (a <= b2 && d2 >= b2)
            return { node: c2, offset: b2 - a };
          a = d2;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je(c2);
      }
    }
    function Le(a, b2) {
      return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
    }
    function Me() {
      for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b2.contentWindow.location.href;
        } catch (d2) {
          c2 = false;
        }
        if (c2)
          a = b2.contentWindow;
        else
          break;
        b2 = Xa(a.document);
      }
      return b2;
    }
    function Ne(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
    }
    function Oe(a) {
      var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
      if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
        if (null !== d2 && Ne(c2)) {
          if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
            c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
          else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
            d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
            !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
            e2 = Ke(c2, f2);
            var g2 = Ke(
              c2,
              d2
            );
            e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
          }
        }
        b2 = [];
        for (a = c2; a = a.parentNode; )
          1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b2.length; c2++)
          a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a, b2, c2) {
      var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
    }
    function Ve(a, b2) {
      var c2 = {};
      c2[a.toLowerCase()] = b2.toLowerCase();
      c2["Webkit" + a] = "webkit" + b2;
      c2["Moz" + a] = "moz" + b2;
      return c2;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a])
        return Xe[a];
      if (!We[a])
        return a;
      var b2 = We[a], c2;
      for (c2 in b2)
        if (b2.hasOwnProperty(c2) && c2 in Ye)
          return Xe[a] = b2[c2];
      return a;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b2) {
      df.set(a, b2);
      fa(b2, [a]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b2, c2) {
      var d2 = a.type || "unknown-event";
      a.currentTarget = c2;
      Ub(d2, b2, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b2) {
      b2 = 0 !== (b2 & 4);
      for (var c2 = 0; c2 < a.length; c2++) {
        var d2 = a[c2], e2 = d2.event;
        d2 = d2.listeners;
        a: {
          var f2 = void 0;
          if (b2)
            for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a = Rb, Qb = false, Rb = null, a;
    }
    function D(a, b2) {
      var c2 = b2[of];
      void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
      var d2 = a + "__bubble";
      c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
    }
    function qf(a, b2, c2) {
      var d2 = 0;
      b2 && (d2 |= 4);
      pf(c2, a, d2, b2);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b3) {
          "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
        });
        var b2 = 9 === a.nodeType ? a : a.ownerDocument;
        null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
      }
    }
    function pf(a, b2, c2, d2) {
      switch (jd(b2)) {
        case 1:
          var e2 = ed;
          break;
        case 4:
          e2 = gd;
          break;
        default:
          e2 = fd;
      }
      c2 = e2.bind(null, b2, c2, a);
      e2 = void 0;
      !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
      d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
    }
    function hd(a, b2, c2, d2, e2) {
      var f2 = d2;
      if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
        a:
          for (; ; ) {
            if (null === d2)
              return;
            var g2 = d2.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d2.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d2.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = Wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d2 = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d2 = d2.return;
          }
      Jb(function() {
        var d3 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = df.get(a);
          if (void 0 !== h3) {
            var k3 = td, n2 = a;
            switch (a) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d3, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b2 & 7)) {
          a: {
            h3 = "mouseover" === a || "pointerover" === a;
            k3 = "mouseout" === a || "pointerout" === a;
            if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d3;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a || "pointerover" === a)
                  t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue(k3);
                u2 = null == n2 ? h3 : ue(n2);
                h3 = new t2(F2, w2 + "leave", k3, c2, e3);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g3, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d3 ? ue(d3) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve;
            else if (me(h3))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
            if (na && (na = na(a, d3))) {
              ne(g3, na, c2, e3);
              break a;
            }
            xa && xa(a, h3, d3);
            "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d3 ? ue(d3) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                Qe = xa, Re = d3, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g3, c2, e3);
          }
          var $a;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c2) : ke(a, c2))
            d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
        }
        se(g3, b2);
      });
    }
    function tf(a, b2, c2) {
      return { instance: a, listener: b2, currentTarget: c2 };
    }
    function oe(a, b2) {
      for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
        var e2 = a, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
        a = a.return;
      }
      return d2;
    }
    function vf(a) {
      if (null === a)
        return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b2, c2, d2, e2) {
      for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d2)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a.push({ event: b2, listeners: g2 });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b2, c2) {
      b2 = zf(b2);
      if (zf(a) !== b2 && c2)
        throw Error(p$1(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b2) {
      return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b2) {
      var c2 = b2, d2 = 0;
      do {
        var e2 = c2.nextSibling;
        a.removeChild(c2);
        if (e2 && 8 === e2.nodeType)
          if (c2 = e2.data, "/$" === c2) {
            if (0 === d2) {
              a.removeChild(e2);
              bd(b2);
              return;
            }
            d2--;
          } else
            "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
        c2 = e2;
      } while (c2);
      bd(b2);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b2 = a.nodeType;
        if (1 === b2 || 3 === b2)
          break;
        if (8 === b2) {
          b2 = a.data;
          if ("$" === b2 || "$!" === b2 || "$?" === b2)
            break;
          if ("/$" === b2)
            return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b2)
              return a;
            b2--;
          } else
            "/$" === c2 && b2++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b2 = a[Of];
      if (b2)
        return b2;
      for (var c2 = a.parentNode; c2; ) {
        if (b2 = c2[uf] || c2[Of]) {
          c2 = b2.alternate;
          if (null !== b2.child || null !== c2 && null !== c2.child)
            for (a = Mf(a); null !== a; ) {
              if (c2 = a[Of])
                return c2;
              a = Mf(a);
            }
          return b2;
        }
        a = c2;
        c2 = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag)
        return a.stateNode;
      throw Error(p$1(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b2) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b2;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a, b2) {
      var c2 = a.type.contextTypes;
      if (!c2)
        return Vf;
      var d2 = a.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b2, c2) {
      if (H.current !== Vf)
        throw Error(p$1(168));
      G(H, b2);
      G(Wf, c2);
    }
    function bg(a, b2, c2) {
      var d2 = a.stateNode;
      b2 = b2.childContextTypes;
      if ("function" !== typeof d2.getChildContext)
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in b2))
          throw Error(p$1(108, Ra(a) || "Unknown", e2));
      return A$1({}, c2, d2);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b2, c2) {
      var d2 = a.stateNode;
      if (!d2)
        throw Error(p$1(169));
      c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b2 = C;
        try {
          var c2 = eg;
          for (C = 1; a < c2.length; a++) {
            var d2 = c2[a];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e2) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
        } finally {
          C = b2, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b2) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b2;
    }
    function ug(a, b2, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d2 = rg;
      a = sg;
      var e2 = 32 - oc(d2) - 1;
      d2 &= ~(1 << e2);
      c2 += 1;
      var f2 = 32 - oc(b2) + e2;
      if (30 < f2) {
        var g2 = e2 - e2 % 5;
        f2 = (d2 & (1 << g2) - 1).toString(32);
        d2 >>= g2;
        e2 -= g2;
        rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
        sg = f2 + a;
      } else
        rg = 1 << f2 | c2 << e2 | d2, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a, b2) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b2;
      c2.return = a;
      b2 = a.deletions;
      null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
    }
    function Cg(a, b2) {
      switch (a.tag) {
        case 5:
          var c2 = a.type;
          b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
          return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
        case 6:
          return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
        case 13:
          return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b2 = yg;
        if (b2) {
          var c2 = b2;
          if (!Cg(a, b2)) {
            if (Dg(a))
              throw Error(p$1(418));
            b2 = Lf(c2.nextSibling);
            var d2 = xg;
            b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a))
            throw Error(p$1(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg)
        return false;
      if (!I)
        return Fg(a), I = true, false;
      var b2;
      (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
      if (b2 && (b2 = yg)) {
        if (Dg(a))
          throw Hg(), Error(p$1(418));
        for (; b2; )
          Ag(a, b2), b2 = Lf(b2.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a)
          throw Error(p$1(317));
        a: {
          a = a.nextSibling;
          for (b2 = 0; a; ) {
            if (8 === a.nodeType) {
              var c2 = a.data;
              if ("/$" === c2) {
                if (0 === b2) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b2--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; )
        a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b2) {
      if (a && a.defaultProps) {
        b2 = A$1({}, b2);
        a = a.defaultProps;
        for (var c2 in a)
          void 0 === b2[c2] && (b2[c2] = a[c2]);
        return b2;
      }
      return b2;
    }
    var Mg = Uf(null), Ng = null, Og = null, Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a) {
      var b2 = Mg.current;
      E(Mg);
      a._currentValue = b2;
    }
    function Sg(a, b2, c2) {
      for (; null !== a; ) {
        var d2 = a.alternate;
        (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
        if (a === c2)
          break;
        a = a.return;
      }
    }
    function Tg(a, b2) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
    }
    function Vg(a) {
      var b2 = a._currentValue;
      if (Pg !== a)
        if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
          if (null === Ng)
            throw Error(p$1(308));
          Og = a;
          Ng.dependencies = { lanes: 0, firstContext: a };
        } else
          Og = Og.next = a;
      return b2;
    }
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    function Yg(a, b2, c2, d2) {
      var e2 = b2.interleaved;
      null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
      b2.interleaved = c2;
      return Zg(a, d2);
    }
    function Zg(a, b2) {
      a.lanes |= b2;
      var c2 = a.alternate;
      null !== c2 && (c2.lanes |= b2);
      c2 = a;
      for (a = a.return; null !== a; )
        a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a, b2) {
      a = a.updateQueue;
      b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function ch(a, b2) {
      return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a, b2, c2) {
      var d2 = a.updateQueue;
      if (null === d2)
        return null;
      d2 = d2.shared;
      if (0 !== (K & 2)) {
        var e2 = d2.pending;
        null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
        d2.pending = b2;
        return Zg(a, c2);
      }
      e2 = d2.interleaved;
      null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
      d2.interleaved = b2;
      return Zg(a, c2);
    }
    function eh(a, b2, c2) {
      b2 = b2.updateQueue;
      if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    function fh(a, b2) {
      var c2 = a.updateQueue, d2 = a.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
        a.updateQueue = c2;
        return;
      }
      a = c2.lastBaseUpdate;
      null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function gh(a, b2, c2, d2) {
      var e2 = a.updateQueue;
      $g = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var m2 = a.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e2.baseState;
        g2 = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d2 & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a, t2 = h2;
              r2 = b2;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A$1({}, q2, r2);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = m2;
        b2 = e2.shared.interleaved;
        if (null !== b2) {
          e2 = b2;
          do
            g2 |= e2.lane, e2 = e2.next;
          while (e2 !== b2);
        } else
          null === f2 && (e2.shared.lanes = 0);
        hh |= g2;
        a.lanes = g2;
        a.memoizedState = q2;
      }
    }
    function ih(a, b2, c2) {
      a = b2.effects;
      b2.effects = null;
      if (null !== a)
        for (b2 = 0; b2 < a.length; b2++) {
          var d2 = a[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2)
              throw Error(p$1(191, e2));
            e2.call(d2);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a, b2, c2, d2) {
      b2 = a.memoizedState;
      c2 = c2(d2, b2);
      c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
      a.memoizedState = c2;
      0 === a.lanes && (a.updateQueue.baseState = c2);
    }
    var nh = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueReplaceState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueForceUpdate: function(a, b2) {
      a = a._reactInternals;
      var c2 = L(), d2 = lh(a), e2 = ch(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      b2 = dh(a, e2, d2);
      null !== b2 && (mh(b2, a, d2, c2), eh(b2, a, d2));
    } };
    function oh(a, b2, c2, d2, e2, f2, g2) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
    }
    function ph(a, b2, c2) {
      var d2 = false, e2 = Vf;
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
      b2 = new b2(c2, f2);
      a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
      b2.updater = nh;
      a.stateNode = b2;
      b2._reactInternals = a;
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function qh(a, b2, c2, d2) {
      a = b2.state;
      "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
      "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
    }
    function rh(a, b2, c2, d2) {
      var e2 = a.stateNode;
      e2.props = c2;
      e2.state = a.memoizedState;
      e2.refs = jh;
      ah(a);
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
      e2.state = a.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      "function" === typeof f2 && (kh(a, b2, f2, c2), e2.state = a.memoizedState);
      "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c2, e2, d2), e2.state = a.memoizedState);
      "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
    }
    function sh(a, b2, c2) {
      a = c2.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(p$1(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(p$1(147, a));
          var e2 = d2, f2 = "" + a;
          if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
            return b2.ref;
          b2 = function(a2) {
            var b3 = e2.refs;
            b3 === jh && (b3 = e2.refs = {});
            null === a2 ? delete b3[f2] : b3[f2] = a2;
          };
          b2._stringRef = f2;
          return b2;
        }
        if ("string" !== typeof a)
          throw Error(p$1(284));
        if (!c2._owner)
          throw Error(p$1(290, a));
      }
      return a;
    }
    function th(a, b2) {
      a = Object.prototype.toString.call(b2);
      throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
    }
    function uh(a) {
      var b2 = a._init;
      return b2(a._payload);
    }
    function vh(a) {
      function b2(b3, c3) {
        if (a) {
          var d3 = b3.deletions;
          null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
        }
      }
      function c2(c3, d3) {
        if (!a)
          return null;
        for (; null !== d3; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a2, b3) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
          null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
        return a2;
      }
      function e2(a2, b3) {
        a2 = wh(a2, b3);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a)
          return b3.flags |= 1048576, c3;
        d3 = b3.alternate;
        if (null !== d3)
          return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
        b3.flags |= 2;
        return c3;
      }
      function g2(b3) {
        a && null === b3.alternate && (b3.flags |= 2);
        return b3;
      }
      function h2(a2, b3, c3, d3) {
        if (null === b3 || 6 !== b3.tag)
          return b3 = xh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function k2(a2, b3, c3, d3) {
        var f3 = c3.type;
        if (f3 === ya)
          return m2(a2, b3, c3.props.children, d3, c3.key);
        if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
          return d3 = e2(b3, c3.props), d3.ref = sh(a2, b3, c3), d3.return = a2, d3;
        d3 = yh(c3.type, c3.key, c3.props, null, a2.mode, d3);
        d3.ref = sh(a2, b3, c3);
        d3.return = a2;
        return d3;
      }
      function l2(a2, b3, c3, d3) {
        if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = zh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a2;
        return b3;
      }
      function m2(a2, b3, c3, d3, f3) {
        if (null === b3 || 7 !== b3.tag)
          return b3 = Ah(c3, a2.mode, d3, f3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function q2(a2, b3, c3) {
        if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
          return b3 = xh("" + b3, a2.mode, c3), b3.return = a2, b3;
        if ("object" === typeof b3 && null !== b3) {
          switch (b3.$$typeof) {
            case va:
              return c3 = yh(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = sh(a2, null, b3), c3.return = a2, c3;
            case wa:
              return b3 = zh(b3, a2.mode, c3), b3.return = a2, b3;
            case Ha:
              var d3 = b3._init;
              return q2(a2, d3(b3._payload), c3);
          }
          if (eb(b3) || Ka(b3))
            return b3 = Ah(b3, a2.mode, c3, null), b3.return = a2, b3;
          th(a2, b3);
        }
        return null;
      }
      function r2(a2, b3, c3, d3) {
        var e3 = null !== b3 ? b3.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va:
              return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
            case wa:
              return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
            case Ha:
              return e3 = c3._init, r2(
                a2,
                b3,
                e3(c3._payload),
                d3
              );
          }
          if (eb(c3) || Ka(c3))
            return null !== e3 ? null : m2(a2, b3, c3, d3, null);
          th(a2, c3);
        }
        return null;
      }
      function y2(a2, b3, c3, d3, e3) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
          return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
            case wa:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
            case Ha:
              var f3 = d3._init;
              return y2(a2, b3, c3, f3(d3._payload), e3);
          }
          if (eb(d3) || Ka(d3))
            return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
          th(b3, d3);
        }
        return null;
      }
      function n2(e3, g3, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a && u2 && null === n3.alternate && b2(e3, u2);
          g3 = f2(n3, g3, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c2(e3, u2), I && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I && tg(e3, w2);
          return l3;
        }
        for (u2 = d2(e3, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a && u2.forEach(function(a2) {
          return b2(e3, a2);
        });
        I && tg(e3, w2);
        return l3;
      }
      function t2(e3, g3, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p$1(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p$1(151));
        for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a && m3 && null === t3.alternate && b2(e3, m3);
          g3 = f2(t3, g3, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c2(
            e3,
            m3
          ), I && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I && tg(e3, w2);
          return l3;
        }
        for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a && m3.forEach(function(a2) {
          return b2(e3, a2);
        });
        I && tg(e3, w2);
        return l3;
      }
      function J2(a2, d3, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c2(a2, l3.sibling);
                        d3 = e2(l3, f3.props.children);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                      c2(a2, l3.sibling);
                      d3 = e2(l3, f3.props);
                      d3.ref = sh(a2, l3, f3);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                    c2(a2, l3);
                    break;
                  } else
                    b2(a2, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d3, f3), h3.return = a2, a2 = h3);
              }
              return g2(a2);
            case wa:
              a: {
                for (l3 = f3.key; null !== d3; ) {
                  if (d3.key === l3)
                    if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a2, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    } else {
                      c2(a2, d3);
                      break;
                    }
                  else
                    b2(a2, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f3, a2.mode, h3);
                d3.return = a2;
                a2 = d3;
              }
              return g2(a2);
            case Ha:
              return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a2, d3, f3, h3);
          if (Ka(f3))
            return t2(a2, d3, f3, h3);
          th(a2, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
      }
      return J2;
    }
    var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh)
        throw Error(p$1(174));
      return a;
    }
    function Ih(a, b2) {
      G(Gh, b2);
      G(Fh, a);
      G(Eh, Dh);
      a = b2.nodeType;
      switch (a) {
        case 9:
        case 11:
          b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
      }
      E(Eh);
      G(Eh, b2);
    }
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    function Kh(a) {
      Hh(Gh.current);
      var b2 = Hh(Eh.current);
      var c2 = lb(b2, a.type);
      b2 !== c2 && (G(Fh, a), G(Eh, c2));
    }
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    var M = Uf(0);
    function Mh(a) {
      for (var b2 = a; null !== b2; ) {
        if (13 === b2.tag) {
          var c2 = b2.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b2;
        } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
          if (0 !== (b2.flags & 128))
            return b2;
        } else if (null !== b2.child) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++)
        Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
    function Q() {
      throw Error(p$1(321));
    }
    function Wh(a, b2) {
      if (null === b2)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
        if (!He(a[c2], b2[c2]))
          return false;
      return true;
    }
    function Xh(a, b2, c2, d2, e2, f2) {
      Rh = f2;
      N = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c2(d2, e2);
      if (Th) {
        f2 = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f2)
            throw Error(p$1(301));
          f2 += 1;
          P = O = null;
          b2.updateQueue = null;
          Ph.current = $h;
          a = c2(d2, e2);
        } while (Th);
      }
      Ph.current = ai;
      b2 = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b2)
        throw Error(p$1(300));
      return a;
    }
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else
        a = O.next;
      var b2 = null === P ? N.memoizedState : P.next;
      if (null !== b2)
        P = b2, O = a;
      else {
        if (null === a)
          throw Error(p$1(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    function ei(a, b2) {
      return "function" === typeof b2 ? b2(a) : b2;
    }
    function fi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$1(311));
      c2.lastRenderedReducer = a;
      var d2 = O, e2 = d2.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        f2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Rh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
            N.lanes |= m2;
            hh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g2 = d2 : k2.next = h2;
        He(d2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = d2;
        b2.baseState = g2;
        b2.baseQueue = k2;
        c2.lastRenderedState = d2;
      }
      a = c2.interleaved;
      if (null !== a) {
        e2 = a;
        do
          f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
        while (e2 !== a);
      } else
        null === e2 && (c2.lanes = 0);
      return [b2.memoizedState, c2.dispatch];
    }
    function gi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$1(311));
      c2.lastRenderedReducer = a;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He(f2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = f2;
        null === b2.baseQueue && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function hi() {
    }
    function ii(a, b2) {
      var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
      f2 && (d2.memoizedState = e2, Ug = true);
      d2 = d2.queue;
      ji(ki.bind(null, c2, d2, a), [a]);
      if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
        c2.flags |= 2048;
        li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
        if (null === R)
          throw Error(p$1(349));
        0 !== (Rh & 30) || ni(c2, b2, e2);
      }
      return e2;
    }
    function ni(a, b2, c2) {
      a.flags |= 16384;
      a = { getSnapshot: b2, value: c2 };
      b2 = N.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
    }
    function mi(a, b2, c2, d2) {
      b2.value = c2;
      b2.getSnapshot = d2;
      oi(b2) && pi(a);
    }
    function ki(a, b2, c2) {
      return c2(function() {
        oi(b2) && pi(a);
      });
    }
    function oi(a) {
      var b2 = a.getSnapshot;
      a = a.value;
      try {
        var c2 = b2();
        return !He(a, c2);
      } catch (d2) {
        return true;
      }
    }
    function pi(a) {
      var b2 = Zg(a, 1);
      null !== b2 && mh(b2, a, 1, -1);
    }
    function qi(a) {
      var b2 = ci();
      "function" === typeof a && (a = a());
      b2.memoizedState = b2.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b2.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b2.memoizedState, a];
    }
    function li(a, b2, c2, d2) {
      a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
      b2 = N.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
      return a;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a, b2, c2, d2) {
      var e2 = ci();
      N.flags |= a;
      e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
    }
    function ui(a, b2, c2, d2) {
      var e2 = di();
      d2 = void 0 === d2 ? null : d2;
      var f2 = void 0;
      if (null !== O) {
        var g2 = O.memoizedState;
        f2 = g2.destroy;
        if (null !== d2 && Wh(d2, g2.deps)) {
          e2.memoizedState = li(b2, c2, f2, d2);
          return;
        }
      }
      N.flags |= a;
      e2.memoizedState = li(1 | b2, c2, f2, d2);
    }
    function vi(a, b2) {
      return ti(8390656, 8, a, b2);
    }
    function ji(a, b2) {
      return ui(2048, 8, a, b2);
    }
    function wi(a, b2) {
      return ui(4, 2, a, b2);
    }
    function xi(a, b2) {
      return ui(4, 4, a, b2);
    }
    function yi(a, b2) {
      if ("function" === typeof b2)
        return a = a(), b2(a), function() {
          b2(null);
        };
      if (null !== b2 && void 0 !== b2)
        return a = a(), b2.current = a, function() {
          b2.current = null;
        };
    }
    function zi(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b2, a), c2);
    }
    function Ai() {
    }
    function Bi(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a, b2];
      return a;
    }
    function Ci(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }
    function Di(a, b2, c2) {
      if (0 === (Rh & 21))
        return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c2;
      He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a.baseState = true);
      return b2;
    }
    function Ei(a, b2) {
      var c2 = C;
      C = 0 !== c2 && 4 > c2 ? c2 : 4;
      a(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b2();
      } finally {
        C = c2, Qh.transition = d2;
      }
    }
    function Fi() {
      return di().memoizedState;
    }
    function Gi(a, b2, c2) {
      var d2 = lh(a);
      c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b2, c2);
      else if (c2 = Yg(a, b2, c2, d2), null !== c2) {
        var e2 = L();
        mh(c2, a, d2, e2);
        Ji(c2, b2, d2);
      }
    }
    function ri(a, b2, c2) {
      var d2 = lh(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b2, e2);
      else {
        var f2 = a.alternate;
        if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
          try {
            var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He(h2, g2)) {
              var k2 = b2.interleaved;
              null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
              b2.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c2 = Yg(a, b2, e2, d2);
        null !== c2 && (e2 = L(), mh(c2, a, d2, e2), Ji(c2, b2, d2));
      }
    }
    function Hi(a) {
      var b2 = a.alternate;
      return a === N || null !== b2 && b2 === N;
    }
    function Ii(a, b2) {
      Th = Sh = true;
      var c2 = a.pending;
      null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
      a.pending = b2;
    }
    function Ji(a, b2, c2) {
      if (0 !== (c2 & 4194240)) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
      ci().memoizedState = [a, void 0 === b2 ? null : b2];
      return a;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b2, a),
        c2
      );
    }, useLayoutEffect: function(a, b2) {
      return ti(4194308, 4, a, b2);
    }, useInsertionEffect: function(a, b2) {
      return ti(4, 2, a, b2);
    }, useMemo: function(a, b2) {
      var c2 = ci();
      b2 = void 0 === b2 ? null : b2;
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }, useReducer: function(a, b2, c2) {
      var d2 = ci();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
      d2.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d2.memoizedState, a];
    }, useRef: function(a) {
      var b2 = ci();
      a = { current: a };
      return b2.memoizedState = a;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
      return ci().memoizedState = a;
    }, useTransition: function() {
      var a = qi(false), b2 = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b2, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b2, c2) {
      var d2 = N, e2 = ci();
      if (I) {
        if (void 0 === c2)
          throw Error(p$1(407));
        c2 = c2();
      } else {
        c2 = b2();
        if (null === R)
          throw Error(p$1(349));
        0 !== (Rh & 30) || ni(d2, b2, c2);
      }
      e2.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b2 };
      e2.queue = f2;
      vi(ki.bind(
        null,
        d2,
        f2,
        a
      ), [a]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
      return c2;
    }, useId: function() {
      var a = ci(), b2 = R.identifierPrefix;
      if (I) {
        var c2 = sg;
        var d2 = rg;
        c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
        b2 = ":" + b2 + "R" + c2;
        c2 = Uh++;
        0 < c2 && (b2 += "H" + c2.toString(32));
        b2 += ":";
      } else
        c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
      return a.memoizedState = b2;
    }, unstable_isNewReconciler: false }, Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a) {
        var b2 = di();
        return Di(b2, O.memoizedState, a);
      },
      useTransition: function() {
        var a = fi(ei)[0], b2 = di().memoizedState;
        return [a, b2];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a) {
      var b2 = di();
      return null === O ? b2.memoizedState = a : Di(b2, O.memoizedState, a);
    }, useTransition: function() {
      var a = gi(ei)[0], b2 = di().memoizedState;
      return [a, b2];
    }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Pa(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a, source: b2, stack: e2, digest: null };
    }
    function Li(a, b2, c2) {
      return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
    }
    function Mi(a, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d2 = b2.value;
      c2.callback = function() {
        Pi || (Pi = true, Qi = d2);
        Mi(a, b2);
      };
      return c2;
    }
    function Ri(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      var d2 = a.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e2 = b2.value;
        c2.payload = function() {
          return d2(e2);
        };
        c2.callback = function() {
          Mi(a, b2);
        };
      }
      var f2 = a.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Mi(a, b2);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Ti(a, b2, c2) {
      var d2 = a.pingCache;
      if (null === d2) {
        d2 = a.pingCache = new Ni();
        var e2 = /* @__PURE__ */ new Set();
        d2.set(b2, e2);
      } else
        e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
      e2.has(c2) || (e2.add(c2), a = Ui.bind(null, a, b2, c2), b2.then(a, a));
    }
    function Vi(a) {
      do {
        var b2;
        if (b2 = 13 === a.tag)
          b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
        if (b2)
          return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Wi(a, b2, c2, d2, e2) {
      if (0 === (a.mode & 1))
        return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e2;
      return a;
    }
    var Xi = ua.ReactCurrentOwner, Ug = false;
    function Yi(a, b2, c2, d2) {
      b2.child = null === a ? Ch(b2, null, c2, d2) : Bh(b2, a.child, c2, d2);
    }
    function Zi(a, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      Tg(b2, e2);
      d2 = Xh(a, b2, c2, d2, f2, e2);
      c2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I && c2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, d2, e2);
      return b2.child;
    }
    function aj(a, b2, c2, d2, e2) {
      if (null === a) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d2, e2);
        a = yh(c2.type, null, d2, b2, b2.mode, e2);
        a.ref = b2.ref;
        a.return = b2;
        return b2.child = a;
      }
      f2 = a.child;
      if (0 === (a.lanes & e2)) {
        var g2 = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie;
        if (c2(g2, d2) && a.ref === b2.ref)
          return $i(a, b2, e2);
      }
      b2.flags |= 1;
      a = wh(f2, d2);
      a.ref = b2.ref;
      a.return = b2;
      return b2.child = a;
    }
    function cj(a, b2, c2, d2, e2) {
      if (null !== a) {
        var f2 = a.memoizedProps;
        if (Ie(f2, d2) && a.ref === b2.ref)
          if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
            0 !== (a.flags & 131072) && (Ug = true);
          else
            return b2.lanes = a.lanes, $i(a, b2, e2);
      }
      return dj(a, b2, c2, d2, e2);
    }
    function ej(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
      if ("hidden" === d2.mode)
        if (0 === (b2.mode & 1))
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
        else {
          if (0 === (c2 & 1073741824))
            return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a, null;
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d2 = null !== f2 ? f2.baseLanes : c2;
          G(fj, gj);
          gj |= d2;
        }
      else
        null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
      Yi(a, b2, e2, c2);
      return b2.child;
    }
    function hj(a, b2) {
      var c2 = b2.ref;
      if (null === a && null !== c2 || null !== a && a.ref !== c2)
        b2.flags |= 512, b2.flags |= 2097152;
    }
    function dj(a, b2, c2, d2, e2) {
      var f2 = Zf(c2) ? Xf : H.current;
      f2 = Yf(b2, f2);
      Tg(b2, e2);
      c2 = Xh(a, b2, c2, d2, f2, e2);
      d2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I && d2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, c2, e2);
      return b2.child;
    }
    function ij(a, b2, c2, d2, e2) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b2);
      } else
        f2 = false;
      Tg(b2, e2);
      if (null === b2.stateNode)
        jj(a, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
      else if (null === a) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
        $g = false;
        var r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
      } else {
        g2 = b2.stateNode;
        bh(a, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
        g2.props = l2;
        q2 = b2.pendingProps;
        r2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
        $g = false;
        r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        var n2 = b2.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
      }
      return kj(a, b2, c2, d2, f2, e2);
    }
    function kj(a, b2, c2, d2, e2, f2) {
      hj(a, b2);
      var g2 = 0 !== (b2.flags & 128);
      if (!d2 && !g2)
        return e2 && dg(b2, c2, false), $i(a, b2, f2);
      d2 = b2.stateNode;
      Xi.current = b2;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
      b2.flags |= 1;
      null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && dg(b2, c2, true);
      return b2.child;
    }
    function lj(a) {
      var b2 = a.stateNode;
      b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
      Ih(a, b2.containerInfo);
    }
    function mj(a, b2, c2, d2, e2) {
      Ig();
      Jg(e2);
      b2.flags |= 256;
      Yi(a, b2, c2, d2);
      return b2.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function pj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = M.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
      (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
      if (h2)
        f2 = true, b2.flags &= -129;
      else if (null === a || null !== a.memoizedState)
        e2 |= 1;
      G(M, e2 & 1);
      if (null === a) {
        Eg(b2);
        a = b2.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a))
          return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
        g2 = d2.children;
        a = d2.fallback;
        return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a = Ah(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a) : rj(b2, g2);
      }
      e2 = a.memoizedState;
      if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
        return sj(a, b2, g2, d2, h2, e2, c2);
      if (f2) {
        f2 = d2.fallback;
        g2 = b2.mode;
        e2 = a.child;
        h2 = e2.sibling;
        var k2 = { mode: "hidden", children: d2.children };
        0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
        null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
        f2.return = b2;
        d2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        d2 = f2;
        f2 = b2.child;
        g2 = a.child.memoizedState;
        g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
        f2.memoizedState = g2;
        f2.childLanes = a.childLanes & ~c2;
        b2.memoizedState = nj;
        return d2;
      }
      f2 = a.child;
      a = f2.sibling;
      d2 = wh(f2, { mode: "visible", children: d2.children });
      0 === (b2.mode & 1) && (d2.lanes = c2);
      d2.return = b2;
      d2.sibling = null;
      null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
      b2.child = d2;
      b2.memoizedState = null;
      return d2;
    }
    function rj(a, b2) {
      b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
      b2.return = a;
      return a.child = b2;
    }
    function tj(a, b2, c2, d2) {
      null !== d2 && Jg(d2);
      Bh(b2, a.child, null, c2);
      a = rj(b2, b2.pendingProps.children);
      a.flags |= 2;
      b2.memoizedState = null;
      return a;
    }
    function sj(a, b2, c2, d2, e2, f2, g2) {
      if (c2) {
        if (b2.flags & 256)
          return b2.flags &= -257, d2 = Li(Error(p$1(422))), tj(a, b2, g2, d2);
        if (null !== b2.memoizedState)
          return b2.child = a.child, b2.flags |= 128, null;
        f2 = d2.fallback;
        e2 = b2.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
        f2 = Ah(f2, e2, g2, null);
        f2.flags |= 2;
        d2.return = b2;
        f2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
        b2.child.memoizedState = oj(g2);
        b2.memoizedState = nj;
        return f2;
      }
      if (0 === (b2.mode & 1))
        return tj(a, b2, g2, null);
      if ("$!" === e2.data) {
        d2 = e2.nextSibling && e2.nextSibling.dataset;
        if (d2)
          var h2 = d2.dgst;
        d2 = h2;
        f2 = Error(p$1(419));
        d2 = Li(f2, d2, void 0);
        return tj(a, b2, g2, d2);
      }
      h2 = 0 !== (g2 & a.childLanes);
      if (Ug || h2) {
        d2 = R;
        if (null !== d2) {
          switch (g2 & -g2) {
            case 4:
              e2 = 2;
              break;
            case 16:
              e2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e2 = 32;
              break;
            case 536870912:
              e2 = 268435456;
              break;
            default:
              e2 = 0;
          }
          e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
          0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
        }
        uj();
        d2 = Li(Error(p$1(421)));
        return tj(a, b2, g2, d2);
      }
      if ("$?" === e2.data)
        return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
      a = f2.treeContext;
      yg = Lf(e2.nextSibling);
      xg = b2;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
      b2 = rj(b2, d2.children);
      b2.flags |= 4096;
      return b2;
    }
    function wj(a, b2, c2) {
      a.lanes |= b2;
      var d2 = a.alternate;
      null !== d2 && (d2.lanes |= b2);
      Sg(a.return, b2, c2);
    }
    function xj(a, b2, c2, d2, e2) {
      var f2 = a.memoizedState;
      null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
    }
    function yj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      Yi(a, b2, d2.children, c2);
      d2 = M.current;
      if (0 !== (d2 & 2))
        d2 = d2 & 1 | 2, b2.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128))
          a:
            for (a = b2.child; null !== a; ) {
              if (13 === a.tag)
                null !== a.memoizedState && wj(a, c2, b2);
              else if (19 === a.tag)
                wj(a, c2, b2);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b2)
                break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b2)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d2 &= 1;
      }
      G(M, d2);
      if (0 === (b2.mode & 1))
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; )
              a = c2.alternate, null !== a && null === Mh(a) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            xj(b2, false, e2, c2, f2);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a = e2.alternate;
              if (null !== a && null === Mh(a)) {
                b2.child = e2;
                break;
              }
              a = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a;
            }
            xj(b2, true, c2, null, f2);
            break;
          case "together":
            xj(b2, false, null, null, void 0);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function jj(a, b2) {
      0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
    }
    function $i(a, b2, c2) {
      null !== a && (b2.dependencies = a.dependencies);
      hh |= b2.lanes;
      if (0 === (c2 & b2.childLanes))
        return null;
      if (null !== a && b2.child !== a.child)
        throw Error(p$1(153));
      if (null !== b2.child) {
        a = b2.child;
        c2 = wh(a, a.pendingProps);
        b2.child = c2;
        for (c2.return = b2; null !== a.sibling; )
          a = a.sibling, c2 = c2.sibling = wh(a, a.pendingProps), c2.return = b2;
        c2.sibling = null;
      }
      return b2.child;
    }
    function zj(a, b2, c2) {
      switch (b2.tag) {
        case 3:
          lj(b2);
          Ig();
          break;
        case 5:
          Kh(b2);
          break;
        case 1:
          Zf(b2.type) && cg(b2);
          break;
        case 4:
          Ih(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b2.type._context, e2 = b2.memoizedProps.value;
          G(Mg, d2._currentValue);
          d2._currentValue = e2;
          break;
        case 13:
          d2 = b2.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated)
              return G(M, M.current & 1), b2.flags |= 128, null;
            if (0 !== (c2 & b2.child.childLanes))
              return pj(a, b2, c2);
            G(M, M.current & 1);
            a = $i(a, b2, c2);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d2)
              return yj(a, b2, c2);
            b2.flags |= 128;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          G(M, M.current);
          if (d2)
            break;
          else
            return null;
        case 22:
        case 23:
          return b2.lanes = 0, ej(a, b2, c2);
      }
      return $i(a, b2, c2);
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(a, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a, b2, c2, d2) {
      var e2 = a.memoizedProps;
      if (e2 !== d2) {
        a = b2.stateNode;
        Hh(Eh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a, e2);
            d2 = Ya(a, d2);
            f2 = [];
            break;
          case "select":
            e2 = A$1({}, e2, { value: void 0 });
            d2 = A$1({}, d2, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a, e2);
            d2 = gb(a, d2);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
        }
        ub(c2, d2);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d2) {
          var k2 = d2[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(
                  l2,
                  c2
                )), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b2.updateQueue = l2)
          b2.flags |= 4;
      }
    };
    Dj = function(a, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    function Ej(a, b2) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b2 = a.tail;
            for (var c2 = null; null !== b2; )
              null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a.tail;
            for (var d2 = null; null !== c2; )
              null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
        }
    }
    function S(a) {
      var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
      if (b2)
        for (var e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
      else
        for (e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
      a.subtreeFlags |= d2;
      a.childLanes = c2;
      return b2;
    }
    function Fj(a, b2, c2) {
      var d2 = b2.pendingProps;
      wg(b2);
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b2), null;
        case 1:
          return Zf(b2.type) && $f(), S(b2), null;
        case 3:
          d2 = b2.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a || null === a.child)
            Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b2);
          S(b2);
          return null;
        case 5:
          Lh(b2);
          var e2 = Hh(Gh.current);
          c2 = b2.type;
          if (null !== a && null != b2.stateNode)
            Cj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b2.stateNode)
                throw Error(p$1(166));
              S(b2);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.type;
              var f2 = b2.memoizedProps;
              d2[Of] = b2;
              d2[Pf] = f2;
              a = 0 !== (b2.mode & 1);
              switch (c2) {
                case "dialog":
                  D("cancel", d2);
                  D("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D(lf[e2], d2);
                  break;
                case "source":
                  D("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d2
                  );
                  D("load", d2);
                  break;
                case "details":
                  D("toggle", d2);
                  break;
                case "input":
                  Za(d2, f2);
                  D("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f2.multiple };
                  D("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f2), D("invalid", d2);
              }
              ub(c2, f2);
              e2 = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d2.textContent,
                    h2,
                    a
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
                }
              switch (c2) {
                case "input":
                  Va(d2);
                  db(d2, f2, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d2.onclick = Bf);
              }
              d2 = e2;
              b2.updateQueue = d2;
              null !== d2 && (b2.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
              a[Of] = b2;
              a[Pf] = d2;
              Aj(a, b2, false, false);
              b2.stateNode = a;
              a: {
                g2 = vb(c2, d2);
                switch (c2) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e2 = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e2 = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D(lf[e2], a);
                    e2 = d2;
                    break;
                  case "source":
                    D("error", a);
                    e2 = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e2 = d2;
                    break;
                  case "details":
                    D("toggle", a);
                    e2 = d2;
                    break;
                  case "input":
                    Za(a, d2);
                    e2 = Ya(a, d2);
                    D("invalid", a);
                    break;
                  case "option":
                    e2 = d2;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d2.multiple };
                    e2 = A$1({}, d2, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d2);
                    e2 = gb(a, d2);
                    D("invalid", a);
                    break;
                  default:
                    e2 = d2;
                }
                ub(c2, e2);
                h2 = e2;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
                  }
                switch (c2) {
                  case "input":
                    Va(a);
                    db(a, d2, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                    break;
                  case "select":
                    a.multiple = !!d2.multiple;
                    f2 = d2.value;
                    null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                      a,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e2.onClick && (a.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b2.flags |= 4);
            }
            null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          }
          S(b2);
          return null;
        case 6:
          if (a && null != b2.stateNode)
            Dj(a, b2, a.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b2.stateNode)
              throw Error(p$1(166));
            c2 = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.memoizedProps;
              d2[Of] = b2;
              if (f2 = d2.nodeValue !== c2) {
                if (a = xg, null !== a)
                  switch (a.tag) {
                    case 3:
                      Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  }
              }
              f2 && (b2.flags |= 4);
            } else
              d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
          }
          S(b2);
          return null;
        case 13:
          E(M);
          d2 = b2.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
              Hg(), Ig(), b2.flags |= 98560, f2 = false;
            else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
              if (null === a) {
                if (!f2)
                  throw Error(p$1(318));
                f2 = b2.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p$1(317));
                f2[Of] = b2;
              } else
                Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
              S(b2);
              f2 = false;
            } else
              null !== zg && (Gj(zg), zg = null), f2 = true;
            if (!f2)
              return b2.flags & 65536 ? b2 : null;
          }
          if (0 !== (b2.flags & 128))
            return b2.lanes = c2, b2;
          d2 = null !== d2;
          d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b2.updateQueue && (b2.flags |= 4);
          S(b2);
          return null;
        case 4:
          return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
        case 10:
          return Rg(b2.type._context), S(b2), null;
        case 17:
          return Zf(b2.type) && $f(), S(b2), null;
        case 19:
          E(M);
          f2 = b2.memoizedState;
          if (null === f2)
            return S(b2), null;
          d2 = 0 !== (b2.flags & 128);
          g2 = f2.rendering;
          if (null === g2)
            if (d2)
              Ej(f2, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128))
                for (a = b2.child; null !== a; ) {
                  g2 = Mh(a);
                  if (null !== g2) {
                    b2.flags |= 128;
                    Ej(f2, false);
                    d2 = g2.updateQueue;
                    null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                    b2.subtreeFlags = 0;
                    d2 = c2;
                    for (c2 = b2.child; null !== c2; )
                      f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                    G(M, M.current & 1 | 2);
                    return b2.child;
                  }
                  a = a.sibling;
                }
              null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            }
          else {
            if (!d2)
              if (a = Mh(g2), null !== a) {
                if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
                  return S(b2), null;
              } else
                2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
          }
          if (null !== f2.tail)
            return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
          S(b2);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p$1(156, b2.tag));
    }
    function Jj(a, b2) {
      wg(b2);
      switch (b2.tag) {
        case 1:
          return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 3:
          return Jh(), E(Wf), E(H), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
        case 5:
          return Lh(b2), null;
        case 13:
          E(M);
          a = b2.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b2.alternate)
              throw Error(p$1(340));
            Ig();
          }
          a = b2.flags;
          return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b2.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Mj(a, b2) {
      var c2 = a.ref;
      if (null !== c2)
        if ("function" === typeof c2)
          try {
            c2(null);
          } catch (d2) {
            W(a, b2, d2);
          }
        else
          c2.current = null;
    }
    function Nj(a, b2, c2) {
      try {
        c2();
      } catch (d2) {
        W(a, b2, d2);
      }
    }
    var Oj = false;
    function Pj(a, b2) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a)
          var c2 = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
            var d2 = c2.getSelection && c2.getSelection();
            if (d2 && 0 !== d2.rangeCount) {
              c2 = d2.anchorNode;
              var e2 = d2.anchorOffset, f2 = d2.focusNode;
              d2 = d2.focusOffset;
              try {
                c2.nodeType, f2.nodeType;
              } catch (F2) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                    q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                    3 === q2.nodeType && (g2 += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a)
                      break b;
                    r2 === c2 && ++l2 === e2 && (h2 = g2);
                    r2 === f2 && ++m2 === d2 && (k2 = g2);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c2 = null;
          }
        c2 = c2 || { start: 0, end: 0 };
      } else
        c2 = null;
      Df = { focusedElem: a, selectionRange: c2 };
      dd = false;
      for (V = b2; null !== V; )
        if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
          a.return = b2, V = a;
        else
          for (; null !== V; ) {
            b2 = V;
            try {
              var n2 = b2.alternate;
              if (0 !== (b2.flags & 1024))
                switch (b2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b2.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p$1(163));
                }
            } catch (F2) {
              W(b2, b2.return, F2);
            }
            a = b2.sibling;
            if (null !== a) {
              a.return = b2.return;
              V = a;
              break;
            }
            V = b2.return;
          }
      n2 = Oj;
      Oj = false;
      return n2;
    }
    function Qj(a, b2, c2) {
      var d2 = b2.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e2 = d2 = d2.next;
        do {
          if ((e2.tag & a) === a) {
            var f2 = e2.destroy;
            e2.destroy = void 0;
            void 0 !== f2 && Nj(b2, c2, f2);
          }
          e2 = e2.next;
        } while (e2 !== d2);
      }
    }
    function Rj(a, b2) {
      b2 = b2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        var c2 = b2 = b2.next;
        do {
          if ((c2.tag & a) === a) {
            var d2 = c2.create;
            c2.destroy = d2();
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
    }
    function Sj(a) {
      var b2 = a.ref;
      if (null !== b2) {
        var c2 = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c2;
            break;
          default:
            a = c2;
        }
        "function" === typeof b2 ? b2(a) : b2.current = a;
      }
    }
    function Tj(a) {
      var b2 = a.alternate;
      null !== b2 && (a.alternate = null, Tj(b2));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Vj(a) {
      a:
        for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Uj(a.return))
              return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2)
              continue a;
            if (null === a.child || 4 === a.tag)
              continue a;
            else
              a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Wj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Wj(a, b2, c2), a = a.sibling; null !== a; )
          Wj(a, b2, c2), a = a.sibling;
    }
    function Xj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Xj(a, b2, c2), a = a.sibling; null !== a; )
          Xj(a, b2, c2), a = a.sibling;
    }
    var X = null, Yj = false;
    function Zj(a, b2, c2) {
      for (c2 = c2.child; null !== c2; )
        ak(a, b2, c2), c2 = c2.sibling;
    }
    function ak(a, b2, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
      switch (c2.tag) {
        case 5:
          U || Mj(c2, b2);
        case 6:
          var d2 = X, e2 = Yj;
          X = null;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
          break;
        case 4:
          d2 = X;
          e2 = Yj;
          X = c2.stateNode.containerInfo;
          Yj = true;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e2 = d2 = d2.next;
            do {
              var f2 = e2, g2 = f2.destroy;
              f2 = f2.tag;
              void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
              e2 = e2.next;
            } while (e2 !== d2);
          }
          Zj(a, b2, c2);
          break;
        case 1:
          if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
            try {
              d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
            } catch (h2) {
              W(c2, b2, h2);
            }
          Zj(a, b2, c2);
          break;
        case 21:
          Zj(a, b2, c2);
          break;
        case 22:
          c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a, b2, c2), U = d2) : Zj(a, b2, c2);
          break;
        default:
          Zj(a, b2, c2);
      }
    }
    function bk(a) {
      var b2 = a.updateQueue;
      if (null !== b2) {
        a.updateQueue = null;
        var c2 = a.stateNode;
        null === c2 && (c2 = a.stateNode = new Lj());
        b2.forEach(function(b3) {
          var d2 = ck.bind(null, a, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function dk(a, b2) {
      var c2 = b2.deletions;
      if (null !== c2)
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          try {
            var f2 = a, g2 = b2, h2 = g2;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X = h2.stateNode;
                    Yj = false;
                    break a;
                  case 3:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                  case 4:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X)
              throw Error(p$1(160));
            ak(f2, g2, e2);
            X = null;
            Yj = false;
            var k2 = e2.alternate;
            null !== k2 && (k2.return = null);
            e2.return = null;
          } catch (l2) {
            W(e2, b2, l2);
          }
        }
      if (b2.subtreeFlags & 12854)
        for (b2 = b2.child; null !== b2; )
          ek(b2, a), b2 = b2.sibling;
    }
    function ek(a, b2) {
      var c2 = a.alternate, d2 = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t2) {
              W(a, a.return, t2);
            }
            try {
              Qj(5, a, a.return);
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 1:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          break;
        case 5:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          if (a.flags & 32) {
            var e2 = a.stateNode;
            try {
              ob(e2, "");
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
            var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
            a.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
                vb(h2, g2);
                var l2 = vb(h2, f2);
                for (g2 = 0; g2 < k2.length; g2 += 2) {
                  var m2 = k2[g2], q2 = k2[g2 + 1];
                  "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f2);
                    break;
                  case "textarea":
                    ib(e2, f2);
                    break;
                  case "select":
                    var r2 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e2,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e2[Pf] = f2;
              } catch (t2) {
                W(a, a.return, t2);
              }
          }
          break;
        case 6:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            if (null === a.stateNode)
              throw Error(p$1(162));
            e2 = a.stateNode;
            f2 = a.memoizedProps;
            try {
              e2.nodeValue = f2;
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 3:
          dk(b2, a);
          fk(a);
          if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
            try {
              bd(b2.containerInfo);
            } catch (t2) {
              W(a, a.return, t2);
            }
          break;
        case 4:
          dk(b2, a);
          fk(a);
          break;
        case 13:
          dk(b2, a);
          fk(a);
          e2 = a.child;
          e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
          d2 & 4 && bk(a);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a), U = l2) : dk(b2, a);
          fk(a);
          if (d2 & 8192) {
            l2 = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
              for (V = a, m2 = a.child; null !== m2; ) {
                for (q2 = V = m2; null !== V; ) {
                  r2 = V;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r2, r2.return);
                      break;
                    case 1:
                      Mj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d2 = r2;
                        c2 = r2.return;
                        try {
                          b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W(d2, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        hk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          dk(b2, a);
          fk(a);
          d2 & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b2,
            a
          ), fk(a);
      }
    }
    function fk(a) {
      var b2 = a.flags;
      if (b2 & 2) {
        try {
          a: {
            for (var c2 = a.return; null !== c2; ) {
              if (Uj(c2)) {
                var d2 = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p$1(160));
          }
          switch (d2.tag) {
            case 5:
              var e2 = d2.stateNode;
              d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
              var f2 = Vj(a);
              Xj(a, f2, e2);
              break;
            case 3:
            case 4:
              var g2 = d2.stateNode.containerInfo, h2 = Vj(a);
              Wj(a, h2, g2);
              break;
            default:
              throw Error(p$1(161));
          }
        } catch (k2) {
          W(a, a.return, k2);
        }
        a.flags &= -3;
      }
      b2 & 4096 && (a.flags &= -4097);
    }
    function ik(a, b2, c2) {
      V = a;
      jk(a);
    }
    function jk(a, b2, c2) {
      for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
        var e2 = V, f2 = e2.child;
        if (22 === e2.tag && d2) {
          var g2 = null !== e2.memoizedState || Kj;
          if (!g2) {
            var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
            h2 = Kj;
            var l2 = U;
            Kj = g2;
            if ((U = k2) && !l2)
              for (V = e2; null !== V; )
                g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
            for (; null !== f2; )
              V = f2, jk(f2), f2 = f2.sibling;
            V = e2;
            Kj = h2;
            U = l2;
          }
          lk(a);
        } else
          0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a);
      }
    }
    function lk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (0 !== (b2.flags & 8772)) {
          var c2 = b2.alternate;
          try {
            if (0 !== (b2.flags & 8772))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  U || Rj(5, b2);
                  break;
                case 1:
                  var d2 = b2.stateNode;
                  if (b2.flags & 4 && !U)
                    if (null === c2)
                      d2.componentDidMount();
                    else {
                      var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                      d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b2.updateQueue;
                  null !== f2 && ih(b2, f2, d2);
                  break;
                case 3:
                  var g2 = b2.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b2.child)
                      switch (b2.child.tag) {
                        case 5:
                          c2 = b2.child.stateNode;
                          break;
                        case 1:
                          c2 = b2.child.stateNode;
                      }
                    ih(b2, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b2.stateNode;
                  if (null === c2 && b2.flags & 4) {
                    c2 = h2;
                    var k2 = b2.memoizedProps;
                    switch (b2.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c2.focus();
                        break;
                      case "img":
                        k2.src && (c2.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b2.memoizedState) {
                    var l2 = b2.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p$1(163));
              }
            U || b2.flags & 512 && Sj(b2);
          } catch (r2) {
            W(b2, b2.return, r2);
          }
        }
        if (b2 === a) {
          V = null;
          break;
        }
        c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function hk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (b2 === a) {
          V = null;
          break;
        }
        var c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b2 = V;
        try {
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b2.return;
              try {
                Rj(4, b2);
              } catch (k2) {
                W(b2, c2, k2);
              }
              break;
            case 1:
              var d2 = b2.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e2 = b2.return;
                try {
                  d2.componentDidMount();
                } catch (k2) {
                  W(b2, e2, k2);
                }
              }
              var f2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W(b2, f2, k2);
              }
              break;
            case 5:
              var g2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W(b2, g2, k2);
              }
          }
        } catch (k2) {
          W(b2, b2.return, k2);
        }
        if (b2 === a) {
          V = null;
          break;
        }
        var h2 = b2.sibling;
        if (null !== h2) {
          h2.return = b2.return;
          V = h2;
          break;
        }
        V = b2.return;
      }
    }
    var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
    }
    function lh(a) {
      if (0 === (a.mode & 1))
        return 1;
      if (0 !== (K & 2) && 0 !== Z)
        return Z & -Z;
      if (null !== Kg.transition)
        return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a)
        return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function mh(a, b2, c2, d2) {
      if (50 < zk)
        throw zk = 0, Ak = null, Error(p$1(185));
      Ac(a, c2, d2);
      if (0 === (K & 2) || a !== R)
        a === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
    }
    function Ek(a, b2) {
      var c2 = a.callbackNode;
      wc(a, b2);
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
      else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
        null != c2 && bc(c2);
        if (1 === b2)
          0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c2 = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Gk(c2, Hk.bind(null, a));
        }
        a.callbackPriority = b2;
        a.callbackNode = c2;
      }
    }
    function Hk(a, b2) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6))
        throw Error(p$1(327));
      var c2 = a.callbackNode;
      if (Ik() && a.callbackNode !== c2)
        return null;
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
        b2 = Jk(a, d2);
      else {
        b2 = d2;
        var e2 = K;
        K |= 2;
        var f2 = Kk();
        if (R !== a || Z !== b2)
          vk = null, Hj = B() + 500, Lk(a, b2);
        do
          try {
            Mk();
            break;
          } catch (h2) {
            Nk(a, h2);
          }
        while (1);
        Qg();
        nk.current = f2;
        K = e2;
        null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
      }
      if (0 !== b2) {
        2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Ok(a, e2)));
        if (1 === b2)
          throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
        if (6 === b2)
          Dk(a, d2);
        else {
          e2 = a.current.alternate;
          if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Ok(a, f2))), 1 === b2))
            throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
          a.finishedWork = e2;
          a.finishedLanes = d2;
          switch (b2) {
            case 0:
            case 1:
              throw Error(p$1(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d2);
              if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
                if (0 !== uc(a, 0))
                  break;
                e2 = a.suspendedLanes;
                if ((e2 & d2) !== d2) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e2;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d2);
              if ((d2 & 4194240) === d2)
                break;
              b2 = a.eventTimes;
              for (e2 = -1; 0 < d2; ) {
                var g2 = 31 - oc(d2);
                f2 = 1 << g2;
                g2 = b2[g2];
                g2 > e2 && (e2 = g2);
                d2 &= ~f2;
              }
              d2 = e2;
              d2 = B() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p$1(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c2 ? Hk.bind(null, a) : null;
    }
    function Ok(a, b2) {
      var c2 = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
      a = Jk(a, b2);
      2 !== a && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
      return a;
    }
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    function Pk(a) {
      for (var b2 = a; ; ) {
        if (b2.flags & 16384) {
          var c2 = b2.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2))
            for (var d2 = 0; d2 < c2.length; d2++) {
              var e2 = c2[d2], f2 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He(f2(), e2))
                  return false;
              } catch (g2) {
                return false;
              }
            }
        }
        c2 = b2.child;
        if (b2.subtreeFlags & 16384 && null !== c2)
          c2.return = b2, b2 = c2;
        else {
          if (b2 === a)
            break;
          for (; null === b2.sibling; ) {
            if (null === b2.return || b2.return === a)
              return true;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return true;
    }
    function Dk(a, b2) {
      b2 &= ~sk;
      b2 &= ~rk;
      a.suspendedLanes |= b2;
      a.pingedLanes &= ~b2;
      for (a = a.expirationTimes; 0 < b2; ) {
        var c2 = 31 - oc(b2), d2 = 1 << c2;
        a[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Fk(a) {
      if (0 !== (K & 6))
        throw Error(p$1(327));
      Ik();
      var b2 = uc(a, 0);
      if (0 === (b2 & 1))
        return Ek(a, B()), null;
      var c2 = Jk(a, b2);
      if (0 !== a.tag && 2 === c2) {
        var d2 = xc(a);
        0 !== d2 && (b2 = d2, c2 = Ok(a, d2));
      }
      if (1 === c2)
        throw c2 = qk, Lk(a, 0), Dk(a, b2), Ek(a, B()), c2;
      if (6 === c2)
        throw Error(p$1(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b2;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    function Rk(a, b2) {
      var c2 = K;
      K |= 1;
      try {
        return a(b2);
      } finally {
        K = c2, 0 === K && (Hj = B() + 500, fg && jg());
      }
    }
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b2 = K;
      K |= 1;
      var c2 = pk.transition, d2 = C;
      try {
        if (pk.transition = null, C = 1, a)
          return a();
      } finally {
        C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    function Lk(a, b2) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c2 = a.timeoutHandle;
      -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
      if (null !== Y)
        for (c2 = Y.return; null !== c2; ) {
          var d2 = c2;
          wg(d2);
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && $f();
              break;
            case 3:
              Jh();
              E(Wf);
              E(H);
              Oh();
              break;
            case 5:
              Lh(d2);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E(M);
              break;
            case 19:
              E(M);
              break;
            case 10:
              Rg(d2.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c2 = c2.return;
        }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b2;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b2 = 0; b2 < Wg.length; b2++)
          if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
            c2.interleaved = null;
            var e2 = d2.next, f2 = c2.pending;
            if (null !== f2) {
              var g2 = f2.next;
              f2.next = e2;
              d2.next = g2;
            }
            c2.pending = d2;
          }
        Wg = null;
      }
      return a;
    }
    function Nk(a, b2) {
      do {
        var c2 = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d2 = N.memoizedState; null !== d2; ) {
              var e2 = d2.queue;
              null !== e2 && (e2.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c2 || null === c2.return) {
            T = 1;
            qk = b2;
            Y = null;
            break;
          }
          a: {
            var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = Z;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Vi(g2);
              if (null !== y2) {
                y2.flags &= -257;
                Wi(y2, g2, h2, f2, b2);
                y2.mode & 1 && Ti(f2, l2, b2);
                b2 = y2;
                k2 = l2;
                var n2 = b2.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b2.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b2 & 1)) {
                  Ti(f2, l2, b2);
                  uj();
                  break a;
                }
                k2 = Error(p$1(426));
              }
            } else if (I && h2.mode & 1) {
              var J2 = Vi(g2);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Wi(J2, g2, h2, f2, b2);
                Jg(Ki(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ki(k2, h2);
            4 !== T && (T = 2);
            null === tk ? tk = [f2] : tk.push(f2);
            f2 = g2;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var x2 = Oi(f2, k2, b2);
                  fh(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                    f2.flags |= 65536;
                    b2 &= -b2;
                    f2.lanes |= b2;
                    var F2 = Ri(f2, h2, b2);
                    fh(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Tk(c2);
        } catch (na) {
          b2 = na;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    function uj() {
      if (0 === T || 3 === T || 2 === T)
        T = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    function Jk(a, b2) {
      var c2 = K;
      K |= 2;
      var d2 = Kk();
      if (R !== a || Z !== b2)
        vk = null, Lk(a, b2);
      do
        try {
          Uk();
          break;
        } catch (e2) {
          Nk(a, e2);
        }
      while (1);
      Qg();
      K = c2;
      nk.current = d2;
      if (null !== Y)
        throw Error(p$1(261));
      R = null;
      Z = 0;
      return T;
    }
    function Uk() {
      for (; null !== Y; )
        Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); )
        Vk(Y);
    }
    function Vk(a) {
      var b2 = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b2 ? Tk(a) : Y = b2;
      ok.current = null;
    }
    function Tk(a) {
      var b2 = a;
      do {
        var c2 = b2.alternate;
        a = b2.return;
        if (0 === (b2.flags & 32768)) {
          if (c2 = Fj(c2, b2, gj), null !== c2) {
            Y = c2;
            return;
          }
        } else {
          c2 = Jj(c2, b2);
          if (null !== c2) {
            c2.flags &= 32767;
            Y = c2;
            return;
          }
          if (null !== a)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b2 = b2.sibling;
        if (null !== b2) {
          Y = b2;
          return;
        }
        Y = b2 = a;
      } while (null !== b2);
      0 === T && (T = 5);
    }
    function Qk(a, b2, c2) {
      var d2 = C, e2 = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a, b2, c2, d2);
      } finally {
        pk.transition = e2, C = d2;
      }
      return null;
    }
    function Xk(a, b2, c2, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6))
        throw Error(p$1(327));
      c2 = a.finishedWork;
      var e2 = a.finishedLanes;
      if (null === c2)
        return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c2 === a.current)
        throw Error(p$1(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a, f2);
      a === R && (Y = R = null, Z = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = pk.transition;
        pk.transition = null;
        var g2 = C;
        C = 1;
        var h2 = K;
        K |= 4;
        ok.current = null;
        Pj(a, c2);
        ek(c2, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c2;
        ik(c2);
        dc();
        K = h2;
        C = g2;
        pk.transition = f2;
      } else
        a.current = c2;
      wk && (wk = false, xk = a, yk = e2);
      f2 = a.pendingLanes;
      0 === f2 && (Si = null);
      mc(c2.stateNode);
      Ek(a, B());
      if (null !== b2)
        for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
          e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
      if (Pi)
        throw Pi = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f2 = a.pendingLanes;
      0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b2 = pk.transition, c2 = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk)
            var d2 = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6))
              throw Error(p$1(331));
            var e2 = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f2 = V, g2 = f2.child;
              if (0 !== (V.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V = q2;
                      else
                        for (; null !== V; ) {
                          m2 = V;
                          var r2 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V = r2;
                            break;
                          }
                          V = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
                g2.return = f2, V = g2;
              else
                b:
                  for (; null !== V; ) {
                    f2 = V;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V = x2;
                      break b;
                    }
                    V = f2.return;
                  }
            }
            var w2 = a.current;
            for (V = w2; null !== V; ) {
              g2 = V;
              var u2 = g2.child;
              if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
                u2.return = g2, V = u2;
              else
                b:
                  for (g2 = w2; null !== V; ) {
                    h2 = V;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h2);
                        }
                      } catch (na) {
                        W(h2, h2.return, na);
                      }
                    if (h2 === g2) {
                      V = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V = F2;
                      break b;
                    }
                    V = h2.return;
                  }
            }
            K = e2;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
            d2 = true;
          }
          return d2;
        } finally {
          C = c2, pk.transition = b2;
        }
      }
      return false;
    }
    function Yk(a, b2, c2) {
      b2 = Ki(c2, b2);
      b2 = Oi(a, b2, 1);
      a = dh(a, b2, 1);
      b2 = L();
      null !== a && (Ac(a, 1, b2), Ek(a, b2));
    }
    function W(a, b2, c2) {
      if (3 === a.tag)
        Yk(a, a, c2);
      else
        for (; null !== b2; ) {
          if (3 === b2.tag) {
            Yk(b2, a, c2);
            break;
          } else if (1 === b2.tag) {
            var d2 = b2.stateNode;
            if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
              a = Ki(c2, a);
              a = Ri(b2, a, 1);
              b2 = dh(b2, a, 1);
              a = L();
              null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
              break;
            }
          }
          b2 = b2.return;
        }
    }
    function Ui(a, b2, c2) {
      var d2 = a.pingCache;
      null !== d2 && d2.delete(b2);
      b2 = L();
      a.pingedLanes |= a.suspendedLanes & c2;
      R === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c2);
      Ek(a, b2);
    }
    function Zk(a, b2) {
      0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = L();
      a = Zg(a, b2);
      null !== a && (Ac(a, b2, c2), Ek(a, c2));
    }
    function vj(a) {
      var b2 = a.memoizedState, c2 = 0;
      null !== b2 && (c2 = b2.retryLane);
      Zk(a, c2);
    }
    function ck(a, b2) {
      var c2 = 0;
      switch (a.tag) {
        case 13:
          var d2 = a.stateNode;
          var e2 = a.memoizedState;
          null !== e2 && (c2 = e2.retryLane);
          break;
        case 19:
          d2 = a.stateNode;
          break;
        default:
          throw Error(p$1(314));
      }
      null !== d2 && d2.delete(b2);
      Zk(a, c2);
    }
    var Wk;
    Wk = function(a, b2, c2) {
      if (null !== a)
        if (a.memoizedProps !== b2.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
            return Ug = false, zj(a, b2, c2);
          Ug = 0 !== (a.flags & 131072) ? true : false;
        }
      else
        Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          var d2 = b2.type;
          jj(a, b2);
          a = b2.pendingProps;
          var e2 = Yf(b2, H.current);
          Tg(b2, c2);
          e2 = Xh(null, b2, d2, a, e2, c2);
          var f2 = bi();
          b2.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
          return b2;
        case 16:
          d2 = b2.elementType;
          a: {
            jj(a, b2);
            a = b2.pendingProps;
            e2 = d2._init;
            d2 = e2(d2._payload);
            b2.type = d2;
            e2 = b2.tag = $k(d2);
            a = Lg(d2, a);
            switch (e2) {
              case 0:
                b2 = dj(null, b2, d2, a, c2);
                break a;
              case 1:
                b2 = ij(null, b2, d2, a, c2);
                break a;
              case 11:
                b2 = Zi(null, b2, d2, a, c2);
                break a;
              case 14:
                b2 = aj(null, b2, d2, Lg(d2.type, a), c2);
                break a;
            }
            throw Error(p$1(
              306,
              d2,
              ""
            ));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b2, d2, e2, c2);
        case 3:
          a: {
            lj(b2);
            if (null === a)
              throw Error(p$1(387));
            d2 = b2.pendingProps;
            f2 = b2.memoizedState;
            e2 = f2.element;
            bh(a, b2);
            gh(b2, d2, null, c2);
            var g2 = b2.memoizedState;
            d2 = g2.element;
            if (f2.isDehydrated)
              if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
                e2 = Ki(Error(p$1(423)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p$1(424)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else
                for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d2 === e2) {
                b2 = $i(a, b2, c2);
                break a;
              }
              Yi(a, b2, d2, c2);
            }
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Kh(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c2), b2.child;
        case 6:
          return null === a && Eg(b2), null;
        case 13:
          return pj(a, b2, c2);
        case 4:
          return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d2, c2) : Yi(a, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b2, d2, e2, c2);
        case 7:
          return Yi(a, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            f2 = b2.memoizedProps;
            g2 = e2.value;
            G(Mg, d2._currentValue);
            d2._currentValue = g2;
            if (null !== f2)
              if (He(f2.value, g2)) {
                if (f2.children === e2.children && !Wf.current) {
                  b2 = $i(a, b2, c2);
                  break a;
                }
              } else
                for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g2 = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d2) {
                        if (1 === f2.tag) {
                          k2 = ch(-1, c2 & -c2);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c2;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c2);
                        Sg(
                          f2.return,
                          c2,
                          b2
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g2 = f2.type === b2.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g2 = f2.return;
                    if (null === g2)
                      throw Error(p$1(341));
                    g2.lanes |= c2;
                    h2 = g2.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    Sg(g2, c2, b2);
                    g2 = f2.sibling;
                  } else
                    g2 = f2.child;
                  if (null !== g2)
                    g2.return = f2;
                  else
                    for (g2 = f2; null !== g2; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      f2 = g2.sibling;
                      if (null !== f2) {
                        f2.return = g2.return;
                        g2 = f2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  f2 = g2;
                }
            Yi(a, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a, b2, d2, c2), b2.child;
        case 14:
          return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a, b2, d2, e2, c2);
        case 15:
          return cj(a, b2, b2.type, b2.pendingProps, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a, c2);
        case 19:
          return yj(a, b2, c2);
        case 22:
          return ej(a, b2, c2);
      }
      throw Error(p$1(156, b2.tag));
    };
    function Gk(a, b2) {
      return ac(a, b2);
    }
    function al(a, b2, c2, d2) {
      this.tag = a;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b2, c2, d2) {
      return new al(a, b2, c2, d2);
    }
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function $k(a) {
      if ("function" === typeof a)
        return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da)
          return 11;
        if (a === Ga)
          return 14;
      }
      return 2;
    }
    function wh(a, b2) {
      var c2 = a.alternate;
      null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a.flags & 14680064;
      c2.childLanes = a.childLanes;
      c2.lanes = a.lanes;
      c2.child = a.child;
      c2.memoizedProps = a.memoizedProps;
      c2.memoizedState = a.memoizedState;
      c2.updateQueue = a.updateQueue;
      b2 = a.dependencies;
      c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
      c2.sibling = a.sibling;
      c2.index = a.index;
      c2.ref = a.ref;
      return c2;
    }
    function yh(a, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a;
      if ("function" === typeof a)
        bj(a) && (g2 = 1);
      else if ("string" === typeof a)
        g2 = 5;
      else
        a:
          switch (a) {
            case ya:
              return Ah(c2.children, e2, f2, b2);
            case za:
              g2 = 8;
              e2 |= 8;
              break;
            case Aa:
              return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
            case Ea:
              return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
            case Fa:
              return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
            case Ia:
              return qj(c2, e2, f2, b2);
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba:
                    g2 = 10;
                    break a;
                  case Ca:
                    g2 = 9;
                    break a;
                  case Da:
                    g2 = 11;
                    break a;
                  case Ga:
                    g2 = 14;
                    break a;
                  case Ha:
                    g2 = 16;
                    d2 = null;
                    break a;
                }
              throw Error(p$1(130, null == a ? a : typeof a, ""));
          }
      b2 = Bg(g2, c2, b2, e2);
      b2.elementType = a;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Ah(a, b2, c2, d2) {
      a = Bg(7, a, d2, b2);
      a.lanes = c2;
      return a;
    }
    function qj(a, b2, c2, d2) {
      a = Bg(22, a, d2, b2);
      a.elementType = Ia;
      a.lanes = c2;
      a.stateNode = { isHidden: false };
      return a;
    }
    function xh(a, b2, c2) {
      a = Bg(6, a, null, b2);
      a.lanes = c2;
      return a;
    }
    function zh(a, b2, c2) {
      b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
      b2.lanes = c2;
      b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b2;
    }
    function bl(a, b2, c2, d2, e2) {
      this.tag = b2;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e2;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = new bl(a, b2, c2, h2, k2);
      1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
      f2 = Bg(3, null, null, b2);
      a.current = f2;
      f2.stateNode = a;
      f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f2);
      return a;
    }
    function dl(a, b2, c2) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
    }
    function el(a) {
      if (!a)
        return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag)
          throw Error(p$1(170));
        var b2 = a;
        do {
          switch (b2.tag) {
            case 3:
              b2 = b2.stateNode.context;
              break a;
            case 1:
              if (Zf(b2.type)) {
                b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b2 = b2.return;
        } while (null !== b2);
        throw Error(p$1(171));
      }
      if (1 === a.tag) {
        var c2 = a.type;
        if (Zf(c2))
          return bg(a, c2, b2);
      }
      return b2;
    }
    function fl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = cl(c2, d2, true, a, e2, f2, g2, h2, k2);
      a.context = el(null);
      c2 = a.current;
      d2 = L();
      e2 = lh(c2);
      f2 = ch(d2, e2);
      f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
      dh(c2, f2, e2);
      a.current.lanes = e2;
      Ac(a, e2, d2);
      Ek(a, d2);
      return a;
    }
    function gl(a, b2, c2, d2) {
      var e2 = b2.current, f2 = L(), g2 = lh(e2);
      c2 = el(c2);
      null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
      b2 = ch(f2, g2);
      b2.payload = { element: a };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b2.callback = d2);
      a = dh(e2, b2, g2);
      null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
      return g2;
    }
    function hl(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function il(a, b2) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c2 = a.retryLane;
        a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
      }
    }
    function jl(a, b2) {
      il(a, b2);
      (a = a.alternate) && il(a, b2);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    nl.prototype.render = ml.prototype.render = function(a) {
      var b2 = this._internalRoot;
      if (null === b2)
        throw Error(p$1(409));
      gl(a, b2, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b2 = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b2[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b2 = Hc();
        a = { blockedOn: null, target: a, priority: b2 };
        for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a);
        0 === c2 && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function ql() {
    }
    function rl(a, b2, c2, d2, e2) {
      if (e2) {
        if ("function" === typeof d2) {
          var f2 = d2;
          d2 = function() {
            var a2 = hl(g2);
            f2.call(a2);
          };
        }
        var g2 = fl(b2, d2, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g2;
        a[uf] = g2.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g2;
      }
      for (; e2 = a.lastChild; )
        a.removeChild(e2);
      if ("function" === typeof d2) {
        var h2 = d2;
        d2 = function() {
          var a2 = hl(k2);
          h2.call(a2);
        };
      }
      var k2 = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k2;
      a[uf] = k2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b2, k2, c2, d2);
      });
      return k2;
    }
    function sl(a, b2, c2, d2, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a2 = hl(g2);
            h2.call(a2);
          };
        }
        gl(b2, g2, a, e2);
      } else
        g2 = rl(c2, b2, a, e2, d2);
      return hl(g2);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b2 = a.stateNode;
          if (b2.current.memoizedState.isDehydrated) {
            var c2 = tc(b2.pendingLanes);
            0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b3 = Zg(a, 1);
            if (null !== b3) {
              var c3 = L();
              mh(b3, a, 1, c3);
            }
          }), jl(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b2 = Zg(a, 134217728);
        if (null !== b2) {
          var c2 = L();
          mh(b2, a, 134217728, c2);
        }
        jl(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b2 = lh(a), c2 = Zg(a, b2);
        if (null !== c2) {
          var d2 = L();
          mh(c2, a, b2, d2);
        }
        jl(a, b2);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b2) {
      var c2 = C;
      try {
        return C = a, b2();
      } finally {
        C = c2;
      }
    };
    yb = function(a, b2, c2) {
      switch (b2) {
        case "input":
          bb(a, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a && d2.form === a.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(p$1(90));
                Wa(d2);
                bb(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b2))
        throw Error(p$1(200));
      return dl(a, b2, null, c2);
    };
    reactDom_production_min.createRoot = function(a, b2) {
      if (!ol(a))
        throw Error(p$1(299));
      var c2 = false, d2 = "", e2 = ll;
      null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
      b2 = cl(a, 1, false, null, null, c2, false, d2, e2);
      a[uf] = b2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b2);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a)
        return null;
      if (1 === a.nodeType)
        return a;
      var b2 = a._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a.render)
          throw Error(p$1(188));
        a = Object.keys(a).join(",");
        throw Error(p$1(268, a));
      }
      a = Zb(b2);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Sk(a);
    };
    reactDom_production_min.hydrate = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$1(200));
      return sl(null, a, b2, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a, b2, c2) {
      if (!ol(a))
        throw Error(p$1(405));
      var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
      b2 = fl(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
      a[uf] = b2.current;
      sf(a);
      if (d2)
        for (a = 0; a < d2.length; a++)
          c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new nl(b2);
    };
    reactDom_production_min.render = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$1(200));
      return sl(null, a, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!pl(a))
        throw Error(p$1(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
      if (!pl(c2))
        throw Error(p$1(200));
      if (null == a || void 0 === a._reactInternals)
        throw Error(p$1(38));
      return sl(a, b2, c2, false, d2);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    (function(module2) {
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        module2.exports = reactDom_production_min;
      }
    })(reactDom);
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: ReactDOM
    }, [reactDomExports]);
    var m$1 = reactDomExports;
    {
      client.createRoot = m$1.createRoot;
      client.hydrateRoot = m$1.hydrateRoot;
    }
    var browserExports = {};
    var browser$2 = {
      get exports() {
        return browserExports;
      },
      set exports(v2) {
        browserExports = v2;
      }
    };
    var process$1 = browser$2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e2) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e2) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e2) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e3) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e2) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e3) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len2 = queue.length;
      while (len2) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len2) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len2 = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process$1.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          args[i2 - 1] = arguments[i2];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array2) {
      this.fun = fun;
      this.array = array2;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process$1.title = "browser";
    process$1.browser = true;
    process$1.env = {};
    process$1.argv = [];
    process$1.version = "";
    process$1.versions = {};
    function noop$1() {
    }
    process$1.on = noop$1;
    process$1.addListener = noop$1;
    process$1.once = noop$1;
    process$1.off = noop$1;
    process$1.removeListener = noop$1;
    process$1.removeAllListeners = noop$1;
    process$1.emit = noop$1;
    process$1.prependListener = noop$1;
    process$1.prependOnceListener = noop$1;
    process$1.listeners = function(name) {
      return [];
    };
    process$1.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process$1.cwd = function() {
      return "/";
    };
    process$1.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process$1.umask = function() {
      return 0;
    };
    const process$2 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      get default() {
        return browserExports;
      }
    }, [browserExports]);
    var buffer = {};
    var base64Js = {};
    base64Js.byteLength = byteLength;
    base64Js.toByteArray = toByteArray;
    base64Js.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    var ieee754 = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e2, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s = buffer2[offset + i2];
      i2 += d2;
      e2 = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m2 ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
    };
    ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e2, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m2 = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m2 = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
      }
      buffer2[offset + i2 - d2] |= s * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(exports2) {
      const base64 = base64Js;
      const ieee754$1 = ieee754;
      const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports2.Buffer = Buffer2;
      exports2.SlowBuffer = SlowBuffer;
      exports2.INSPECT_MAX_BYTES = 50;
      const K_MAX_LENGTH = 2147483647;
      exports2.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e2) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length2) {
        if (length2 > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length2);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length2) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe2(arg);
        }
        return from2(arg, encodingOrOffset, length2);
      }
      Buffer2.poolSize = 8192;
      function from2(value, encodingOrOffset, length2) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length2);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length2);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length2);
        }
        const b2 = fromObject(value);
        if (b2)
          return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length2) {
        return from2(value, encodingOrOffset, length2);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc2(size, fill, encoding2) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding2 === "string" ? createBuffer(size).fill(fill, encoding2) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding2) {
        return alloc2(size, fill, encoding2);
      };
      function allocUnsafe2(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe2(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe2(size);
      };
      function fromString(string2, encoding2) {
        if (typeof encoding2 !== "string" || encoding2 === "") {
          encoding2 = "utf8";
        }
        if (!Buffer2.isEncoding(encoding2)) {
          throw new TypeError("Unknown encoding: " + encoding2);
        }
        const length2 = byteLength2(string2, encoding2) | 0;
        let buf = createBuffer(length2);
        const actual = buf.write(string2, encoding2);
        if (actual !== length2) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array2) {
        const length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
        const buf = createBuffer(length2);
        for (let i2 = 0; i2 < length2; i2 += 1) {
          buf[i2] = array2[i2] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy2 = new Uint8Array(arrayView);
          return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array2, byteOffset, length2) {
        if (byteOffset < 0 || array2.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array2.byteLength < byteOffset + (length2 || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length2 === void 0) {
          buf = new Uint8Array(array2);
        } else if (length2 === void 0) {
          buf = new Uint8Array(array2, byteOffset);
        } else {
          buf = new Uint8Array(array2, byteOffset, length2);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len2 = checked(obj.length) | 0;
          const buf = createBuffer(len2);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len2);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length2) {
        if (length2 >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length2 | 0;
      }
      function SlowBuffer(length2) {
        if (+length2 != length2) {
          length2 = 0;
        }
        return Buffer2.alloc(+length2);
      }
      Buffer2.isBuffer = function isBuffer2(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b2) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b2, Uint8Array))
          b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b2)
          return 0;
        let x2 = a.length;
        let y2 = b2.length;
        for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
          if (a[i2] !== b2[i2]) {
            x2 = a[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding2) {
        switch (String(encoding2).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length2) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i2;
        if (length2 === void 0) {
          length2 = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length2 += list[i2].length;
          }
        }
        const buffer2 = Buffer2.allocUnsafe(length2);
        let pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          let buf = list[i2];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength2(string2, encoding2) {
        if (Buffer2.isBuffer(string2)) {
          return string2.length;
        }
        if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
          );
        }
        const len2 = string2.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len2 === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding2) {
            case "ascii":
            case "latin1":
            case "binary":
              return len2;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len2 * 2;
            case "hex":
              return len2 >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string2).length;
              }
              encoding2 = ("" + encoding2).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength2;
      function slowToString(encoding2, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding2)
          encoding2 = "utf8";
        while (true) {
          switch (encoding2) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding2);
              encoding2 = (encoding2 + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b2, n2, m2) {
        const i2 = b2[n2];
        b2[n2] = b2[m2];
        b2[m2] = i2;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len2 = this.length;
        if (len2 % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len2 = this.length;
        if (len2 % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len2 = this.length;
        if (len2 % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString2() {
        const length2 = this.length;
        if (length2 === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length2);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b2) {
        if (!Buffer2.isBuffer(b2))
          throw new TypeError("Argument must be a Buffer");
        if (this === b2)
          return true;
        return Buffer2.compare(this, b2) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports2.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x2 = thisEnd - thisStart;
        let y2 = end - start;
        const len2 = Math.min(x2, y2);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i2 = 0; i2 < len2; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x2 = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x2 < y2)
          return -1;
        if (y2 < x2)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
        if (buffer2.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding2 = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding2);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding2 !== void 0) {
          encoding2 = String(encoding2).toLowerCase();
          if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        let i2;
        if (dir) {
          let foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i2 + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i2;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
        return this.indexOf(val, byteOffset, encoding2) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
      };
      function hexWrite(buf, string2, offset, length2) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length2) {
          length2 = remaining;
        } else {
          length2 = Number(length2);
          if (length2 > remaining) {
            length2 = remaining;
          }
        }
        const strLen = string2.length;
        if (length2 > strLen / 2) {
          length2 = strLen / 2;
        }
        let i2;
        for (i2 = 0; i2 < length2; ++i2) {
          const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i2;
          buf[offset + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string2, offset, length2) {
        return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
      }
      function asciiWrite(buf, string2, offset, length2) {
        return blitBuffer(asciiToBytes(string2), buf, offset, length2);
      }
      function base64Write(buf, string2, offset, length2) {
        return blitBuffer(base64ToBytes(string2), buf, offset, length2);
      }
      function ucs2Write(buf, string2, offset, length2) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
      }
      Buffer2.prototype.write = function write(string2, offset, length2, encoding2) {
        if (offset === void 0) {
          encoding2 = "utf8";
          length2 = this.length;
          offset = 0;
        } else if (length2 === void 0 && typeof offset === "string") {
          encoding2 = offset;
          length2 = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length2)) {
            length2 = length2 >>> 0;
            if (encoding2 === void 0)
              encoding2 = "utf8";
          } else {
            encoding2 = length2;
            length2 = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length2 === void 0 || length2 > remaining)
          length2 = remaining;
        if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding2)
          encoding2 = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding2) {
            case "hex":
              return hexWrite(this, string2, offset, length2);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset, length2);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string2, offset, length2);
            case "base64":
              return base64Write(this, string2, offset, length2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset, length2);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding2);
              encoding2 = ("" + encoding2).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i2 = start;
        while (i2 < end) {
          const firstByte = buf[i2];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      const MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len2 = codePoints.length;
        if (len2 <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i2 = 0;
        while (i2 < len2) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len2 = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len2)
          end = len2;
        let out = "";
        for (let i2 = start; i2 < end; ++i2) {
          out += hexSliceLookupTable[buf[i2]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
          res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice2(start, end) {
        const len2 = this.length;
        start = ~~start;
        end = end === void 0 ? len2 : ~~end;
        if (start < 0) {
          start += len2;
          if (start < 0)
            start = 0;
        } else if (start > len2) {
          start = len2;
        }
        if (end < 0) {
          end += len2;
          if (end < 0)
            end = 0;
        } else if (end > len2) {
          end = len2;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length2) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length2)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let val = this[offset];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength3, this.length);
        }
        let val = this[offset + --byteLength3];
        let mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength3] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi2) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let val = this[offset];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength3, this.length);
        let i2 = byteLength3;
        let mul = 1;
        let val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        let mul = 1;
        let i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        let i2 = byteLength3 - 1;
        let mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi2;
        hi2 = hi2 >> 8;
        buf[offset++] = hi2;
        hi2 = hi2 >> 8;
        buf[offset++] = hi2;
        hi2 = hi2 >> 8;
        buf[offset++] = hi2;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi2;
        hi2 = hi2 >> 8;
        buf[offset + 2] = hi2;
        hi2 = hi2 >> 8;
        buf[offset + 1] = hi2;
        hi2 = hi2 >> 8;
        buf[offset] = hi2;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        let i2 = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        let i2 = byteLength3 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len2 = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len2;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding2) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding2 = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding2 = end;
            end = this.length;
          }
          if (encoding2 !== void 0 && typeof encoding2 !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
            throw new TypeError("Unknown encoding: " + encoding2);
          }
          if (val.length === 1) {
            const code2 = val.charCodeAt(0);
            if (encoding2 === "utf8" && code2 < 128 || encoding2 === "latin1") {
              val = code2;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
          const len2 = bytes.length;
          if (len2 === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len2];
          }
        }
        return this;
      };
      const errors2 = {};
      function E2(sym, getMessage, Base2) {
        errors2[sym] = class NodeError extends Base2 {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E2(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E2(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E2(
        "ERR_OUT_OF_RANGE",
        function(str, range2, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range2}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i2 = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i2 >= start + 4; i2 -= 3) {
          res = `_${val.slice(i2 - 3, i2)}${res}`;
        }
        return `${val.slice(0, i2)}${res}`;
      }
      function checkBounds(buf, offset, byteLength3) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
          boundsError(offset, buf.length - (byteLength3 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength3) {
        if (value > max || value < min) {
          const n2 = typeof min === "bigint" ? "n" : "";
          let range2;
          if (byteLength3 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
            } else {
              range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
            }
          } else {
            range2 = `>= ${min}${n2} and <= ${max}${n2}`;
          }
          throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
        }
        checkBounds(buf, offset, byteLength3);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length2, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors2.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
        }
        if (length2 < 0) {
          throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors2.ERR_OUT_OF_RANGE(
          type2 || "offset",
          `>= ${type2 ? 1 : 0} and <= ${length2}`,
          value
        );
      }
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string2, units) {
        units = units || Infinity;
        let codePoint;
        const length2 = string2.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i2 = 0; i2 < length2; ++i2) {
          codePoint = string2.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length2) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          byteArray.push(str.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c2, hi2, lo;
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          if ((units -= 2) < 0)
            break;
          c2 = str.charCodeAt(i2);
          hi2 = c2 >> 8;
          lo = c2 % 256;
          byteArray.push(lo);
          byteArray.push(hi2);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src2, dst, offset, length2) {
        let i2;
        for (i2 = 0; i2 < length2; ++i2) {
          if (i2 + offset >= dst.length || i2 >= src2.length)
            break;
          dst[i2 + offset] = src2[i2];
        }
        return i2;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      const hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i2 = 0; i2 < 16; ++i2) {
          const i16 = i2 * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i2] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    })(buffer);
    Object.assign(self, {
      process: process$2,
      global: self,
      Buffer: buffer.Buffer
    });
    var browserIndex$1 = {};
    var browserIndex = {};
    var keystore = {};
    Object.defineProperty(keystore, "__esModule", { value: true });
    keystore.KeyStore = void 0;
    class KeyStore {
    }
    keystore.KeyStore = KeyStore;
    var in_memory_key_store = {};
    var key_pair = {};
    function commonjsRequire(path) {
      throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var naclFastExports = {};
    var naclFast = {
      get exports() {
        return naclFastExports;
      },
      set exports(v2) {
        naclFastExports = v2;
      }
    };
    const __viteBrowserExternal = {};
    const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: __viteBrowserExternal
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
    (function(module2) {
      (function(nacl) {
        var gf2 = function(init) {
          var i2, r2 = new Float64Array(16);
          if (init)
            for (i2 = 0; i2 < init.length; i2++)
              r2[i2] = init[i2];
          return r2;
        };
        var randombytes = function() {
          throw new Error("no PRNG");
        };
        var _0 = new Uint8Array(16);
        var _9 = new Uint8Array(32);
        _9[0] = 9;
        var gf0 = gf2(), gf1 = gf2([1]), _121665 = gf2([56129, 1]), D2 = gf2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ts64(x2, i2, h2, l2) {
          x2[i2] = h2 >> 24 & 255;
          x2[i2 + 1] = h2 >> 16 & 255;
          x2[i2 + 2] = h2 >> 8 & 255;
          x2[i2 + 3] = h2 & 255;
          x2[i2 + 4] = l2 >> 24 & 255;
          x2[i2 + 5] = l2 >> 16 & 255;
          x2[i2 + 6] = l2 >> 8 & 255;
          x2[i2 + 7] = l2 & 255;
        }
        function vn(x2, xi2, y2, yi2, n2) {
          var i2, d2 = 0;
          for (i2 = 0; i2 < n2; i2++)
            d2 |= x2[xi2 + i2] ^ y2[yi2 + i2];
          return (1 & d2 - 1 >>> 8) - 1;
        }
        function crypto_verify_16(x2, xi2, y2, yi2) {
          return vn(x2, xi2, y2, yi2, 16);
        }
        function crypto_verify_32(x2, xi2, y2, yi2) {
          return vn(x2, xi2, y2, yi2, 32);
        }
        function core_salsa20(o, p2, k2, c2) {
          var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
          for (var i2 = 0; i2 < 20; i2 += 2) {
            u2 = x0 + x12 | 0;
            x4 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x4 + x0 | 0;
            x8 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x8 + x4 | 0;
            x12 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x12 + x8 | 0;
            x0 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x5 + x1 | 0;
            x9 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x9 + x5 | 0;
            x13 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x13 + x9 | 0;
            x1 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x1 + x13 | 0;
            x5 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x10 + x6 | 0;
            x14 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x14 + x10 | 0;
            x2 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x2 + x14 | 0;
            x6 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x6 + x2 | 0;
            x10 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x15 + x11 | 0;
            x3 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x3 + x15 | 0;
            x7 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x7 + x3 | 0;
            x11 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x11 + x7 | 0;
            x15 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x0 + x3 | 0;
            x1 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x1 + x0 | 0;
            x2 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x2 + x1 | 0;
            x3 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x3 + x2 | 0;
            x0 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x5 + x4 | 0;
            x6 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x6 + x5 | 0;
            x7 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x7 + x6 | 0;
            x4 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x4 + x7 | 0;
            x5 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x10 + x9 | 0;
            x11 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x11 + x10 | 0;
            x8 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x8 + x11 | 0;
            x9 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x9 + x8 | 0;
            x10 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x15 + x14 | 0;
            x12 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x12 + x15 | 0;
            x13 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x13 + x12 | 0;
            x14 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x14 + x13 | 0;
            x15 ^= u2 << 18 | u2 >>> 32 - 18;
          }
          x0 = x0 + j0 | 0;
          x1 = x1 + j1 | 0;
          x2 = x2 + j2 | 0;
          x3 = x3 + j3 | 0;
          x4 = x4 + j4 | 0;
          x5 = x5 + j5 | 0;
          x6 = x6 + j6 | 0;
          x7 = x7 + j7 | 0;
          x8 = x8 + j8 | 0;
          x9 = x9 + j9 | 0;
          x10 = x10 + j10 | 0;
          x11 = x11 + j11 | 0;
          x12 = x12 + j12 | 0;
          x13 = x13 + j13 | 0;
          x14 = x14 + j14 | 0;
          x15 = x15 + j15 | 0;
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x1 >>> 0 & 255;
          o[5] = x1 >>> 8 & 255;
          o[6] = x1 >>> 16 & 255;
          o[7] = x1 >>> 24 & 255;
          o[8] = x2 >>> 0 & 255;
          o[9] = x2 >>> 8 & 255;
          o[10] = x2 >>> 16 & 255;
          o[11] = x2 >>> 24 & 255;
          o[12] = x3 >>> 0 & 255;
          o[13] = x3 >>> 8 & 255;
          o[14] = x3 >>> 16 & 255;
          o[15] = x3 >>> 24 & 255;
          o[16] = x4 >>> 0 & 255;
          o[17] = x4 >>> 8 & 255;
          o[18] = x4 >>> 16 & 255;
          o[19] = x4 >>> 24 & 255;
          o[20] = x5 >>> 0 & 255;
          o[21] = x5 >>> 8 & 255;
          o[22] = x5 >>> 16 & 255;
          o[23] = x5 >>> 24 & 255;
          o[24] = x6 >>> 0 & 255;
          o[25] = x6 >>> 8 & 255;
          o[26] = x6 >>> 16 & 255;
          o[27] = x6 >>> 24 & 255;
          o[28] = x7 >>> 0 & 255;
          o[29] = x7 >>> 8 & 255;
          o[30] = x7 >>> 16 & 255;
          o[31] = x7 >>> 24 & 255;
          o[32] = x8 >>> 0 & 255;
          o[33] = x8 >>> 8 & 255;
          o[34] = x8 >>> 16 & 255;
          o[35] = x8 >>> 24 & 255;
          o[36] = x9 >>> 0 & 255;
          o[37] = x9 >>> 8 & 255;
          o[38] = x9 >>> 16 & 255;
          o[39] = x9 >>> 24 & 255;
          o[40] = x10 >>> 0 & 255;
          o[41] = x10 >>> 8 & 255;
          o[42] = x10 >>> 16 & 255;
          o[43] = x10 >>> 24 & 255;
          o[44] = x11 >>> 0 & 255;
          o[45] = x11 >>> 8 & 255;
          o[46] = x11 >>> 16 & 255;
          o[47] = x11 >>> 24 & 255;
          o[48] = x12 >>> 0 & 255;
          o[49] = x12 >>> 8 & 255;
          o[50] = x12 >>> 16 & 255;
          o[51] = x12 >>> 24 & 255;
          o[52] = x13 >>> 0 & 255;
          o[53] = x13 >>> 8 & 255;
          o[54] = x13 >>> 16 & 255;
          o[55] = x13 >>> 24 & 255;
          o[56] = x14 >>> 0 & 255;
          o[57] = x14 >>> 8 & 255;
          o[58] = x14 >>> 16 & 255;
          o[59] = x14 >>> 24 & 255;
          o[60] = x15 >>> 0 & 255;
          o[61] = x15 >>> 8 & 255;
          o[62] = x15 >>> 16 & 255;
          o[63] = x15 >>> 24 & 255;
        }
        function core_hsalsa20(o, p2, k2, c2) {
          var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
          for (var i2 = 0; i2 < 20; i2 += 2) {
            u2 = x0 + x12 | 0;
            x4 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x4 + x0 | 0;
            x8 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x8 + x4 | 0;
            x12 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x12 + x8 | 0;
            x0 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x5 + x1 | 0;
            x9 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x9 + x5 | 0;
            x13 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x13 + x9 | 0;
            x1 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x1 + x13 | 0;
            x5 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x10 + x6 | 0;
            x14 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x14 + x10 | 0;
            x2 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x2 + x14 | 0;
            x6 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x6 + x2 | 0;
            x10 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x15 + x11 | 0;
            x3 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x3 + x15 | 0;
            x7 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x7 + x3 | 0;
            x11 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x11 + x7 | 0;
            x15 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x0 + x3 | 0;
            x1 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x1 + x0 | 0;
            x2 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x2 + x1 | 0;
            x3 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x3 + x2 | 0;
            x0 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x5 + x4 | 0;
            x6 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x6 + x5 | 0;
            x7 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x7 + x6 | 0;
            x4 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x4 + x7 | 0;
            x5 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x10 + x9 | 0;
            x11 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x11 + x10 | 0;
            x8 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x8 + x11 | 0;
            x9 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x9 + x8 | 0;
            x10 ^= u2 << 18 | u2 >>> 32 - 18;
            u2 = x15 + x14 | 0;
            x12 ^= u2 << 7 | u2 >>> 32 - 7;
            u2 = x12 + x15 | 0;
            x13 ^= u2 << 9 | u2 >>> 32 - 9;
            u2 = x13 + x12 | 0;
            x14 ^= u2 << 13 | u2 >>> 32 - 13;
            u2 = x14 + x13 | 0;
            x15 ^= u2 << 18 | u2 >>> 32 - 18;
          }
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x5 >>> 0 & 255;
          o[5] = x5 >>> 8 & 255;
          o[6] = x5 >>> 16 & 255;
          o[7] = x5 >>> 24 & 255;
          o[8] = x10 >>> 0 & 255;
          o[9] = x10 >>> 8 & 255;
          o[10] = x10 >>> 16 & 255;
          o[11] = x10 >>> 24 & 255;
          o[12] = x15 >>> 0 & 255;
          o[13] = x15 >>> 8 & 255;
          o[14] = x15 >>> 16 & 255;
          o[15] = x15 >>> 24 & 255;
          o[16] = x6 >>> 0 & 255;
          o[17] = x6 >>> 8 & 255;
          o[18] = x6 >>> 16 & 255;
          o[19] = x6 >>> 24 & 255;
          o[20] = x7 >>> 0 & 255;
          o[21] = x7 >>> 8 & 255;
          o[22] = x7 >>> 16 & 255;
          o[23] = x7 >>> 24 & 255;
          o[24] = x8 >>> 0 & 255;
          o[25] = x8 >>> 8 & 255;
          o[26] = x8 >>> 16 & 255;
          o[27] = x8 >>> 24 & 255;
          o[28] = x9 >>> 0 & 255;
          o[29] = x9 >>> 8 & 255;
          o[30] = x9 >>> 16 & 255;
          o[31] = x9 >>> 24 & 255;
        }
        function crypto_core_salsa20(out, inp, k2, c2) {
          core_salsa20(out, inp, k2, c2);
        }
        function crypto_core_hsalsa20(out, inp, k2, c2) {
          core_hsalsa20(out, inp, k2, c2);
        }
        var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function crypto_stream_salsa20_xor(c2, cpos, m2, mpos, b2, n2, k2) {
          var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
          var u2, i2;
          for (i2 = 0; i2 < 16; i2++)
            z2[i2] = 0;
          for (i2 = 0; i2 < 8; i2++)
            z2[i2] = n2[i2];
          while (b2 >= 64) {
            crypto_core_salsa20(x2, z2, k2, sigma);
            for (i2 = 0; i2 < 64; i2++)
              c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
            u2 = 1;
            for (i2 = 8; i2 < 16; i2++) {
              u2 = u2 + (z2[i2] & 255) | 0;
              z2[i2] = u2 & 255;
              u2 >>>= 8;
            }
            b2 -= 64;
            cpos += 64;
            mpos += 64;
          }
          if (b2 > 0) {
            crypto_core_salsa20(x2, z2, k2, sigma);
            for (i2 = 0; i2 < b2; i2++)
              c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
          }
          return 0;
        }
        function crypto_stream_salsa20(c2, cpos, b2, n2, k2) {
          var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
          var u2, i2;
          for (i2 = 0; i2 < 16; i2++)
            z2[i2] = 0;
          for (i2 = 0; i2 < 8; i2++)
            z2[i2] = n2[i2];
          while (b2 >= 64) {
            crypto_core_salsa20(x2, z2, k2, sigma);
            for (i2 = 0; i2 < 64; i2++)
              c2[cpos + i2] = x2[i2];
            u2 = 1;
            for (i2 = 8; i2 < 16; i2++) {
              u2 = u2 + (z2[i2] & 255) | 0;
              z2[i2] = u2 & 255;
              u2 >>>= 8;
            }
            b2 -= 64;
            cpos += 64;
          }
          if (b2 > 0) {
            crypto_core_salsa20(x2, z2, k2, sigma);
            for (i2 = 0; i2 < b2; i2++)
              c2[cpos + i2] = x2[i2];
          }
          return 0;
        }
        function crypto_stream(c2, cpos, d2, n2, k2) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n2, k2, sigma);
          var sn = new Uint8Array(8);
          for (var i2 = 0; i2 < 8; i2++)
            sn[i2] = n2[i2 + 16];
          return crypto_stream_salsa20(c2, cpos, d2, sn, s);
        }
        function crypto_stream_xor(c2, cpos, m2, mpos, d2, n2, k2) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n2, k2, sigma);
          var sn = new Uint8Array(8);
          for (var i2 = 0; i2 < 8; i2++)
            sn[i2] = n2[i2 + 16];
          return crypto_stream_salsa20_xor(c2, cpos, m2, mpos, d2, sn, s);
        }
        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16);
          this.r = new Uint16Array(10);
          this.h = new Uint16Array(10);
          this.pad = new Uint16Array(8);
          this.leftover = 0;
          this.fin = 0;
          var t0, t1, t2, t3, t4, t5, t6, t7;
          t0 = key[0] & 255 | (key[1] & 255) << 8;
          this.r[0] = t0 & 8191;
          t1 = key[2] & 255 | (key[3] & 255) << 8;
          this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          t2 = key[4] & 255 | (key[5] & 255) << 8;
          this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          t3 = key[6] & 255 | (key[7] & 255) << 8;
          this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          t4 = key[8] & 255 | (key[9] & 255) << 8;
          this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this.r[5] = t4 >>> 1 & 8190;
          t5 = key[10] & 255 | (key[11] & 255) << 8;
          this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          t6 = key[12] & 255 | (key[13] & 255) << 8;
          this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          t7 = key[14] & 255 | (key[15] & 255) << 8;
          this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this.r[9] = t7 >>> 5 & 127;
          this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
          this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
          this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
          this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
          this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
          this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
          this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
          this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
        };
        poly1305.prototype.blocks = function(m2, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11;
          var t0, t1, t2, t3, t4, t5, t6, t7, c2;
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
          var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
          var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
          while (bytes >= 16) {
            t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
            h0 += t0 & 8191;
            t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            c2 = 0;
            d0 = c2;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c2 = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c2 += d0 >>> 13;
            d0 &= 8191;
            d1 = c2;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c2 = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c2 += d1 >>> 13;
            d1 &= 8191;
            d2 = c2;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c2 = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c2 += d2 >>> 13;
            d2 &= 8191;
            d3 = c2;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c2 = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c2 += d3 >>> 13;
            d3 &= 8191;
            d4 = c2;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c2 = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c2 += d4 >>> 13;
            d4 &= 8191;
            d5 = c2;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c2 = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c2 += d5 >>> 13;
            d5 &= 8191;
            d6 = c2;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c2 = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c2 += d6 >>> 13;
            d6 &= 8191;
            d7 = c2;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c2 = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c2 += d7 >>> 13;
            d7 &= 8191;
            d8 = c2;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c2 = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c2 += d8 >>> 13;
            d8 &= 8191;
            d9 = c2;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c2 = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c2 += d9 >>> 13;
            d9 &= 8191;
            c2 = (c2 << 2) + c2 | 0;
            c2 = c2 + d0 | 0;
            d0 = c2 & 8191;
            c2 = c2 >>> 13;
            d1 += c2;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this.h[0] = h0;
          this.h[1] = h1;
          this.h[2] = h2;
          this.h[3] = h3;
          this.h[4] = h4;
          this.h[5] = h5;
          this.h[6] = h6;
          this.h[7] = h7;
          this.h[8] = h8;
          this.h[9] = h9;
        };
        poly1305.prototype.finish = function(mac, macpos) {
          var g2 = new Uint16Array(10);
          var c2, mask, f2, i2;
          if (this.leftover) {
            i2 = this.leftover;
            this.buffer[i2++] = 1;
            for (; i2 < 16; i2++)
              this.buffer[i2] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
          }
          c2 = this.h[1] >>> 13;
          this.h[1] &= 8191;
          for (i2 = 2; i2 < 10; i2++) {
            this.h[i2] += c2;
            c2 = this.h[i2] >>> 13;
            this.h[i2] &= 8191;
          }
          this.h[0] += c2 * 5;
          c2 = this.h[0] >>> 13;
          this.h[0] &= 8191;
          this.h[1] += c2;
          c2 = this.h[1] >>> 13;
          this.h[1] &= 8191;
          this.h[2] += c2;
          g2[0] = this.h[0] + 5;
          c2 = g2[0] >>> 13;
          g2[0] &= 8191;
          for (i2 = 1; i2 < 10; i2++) {
            g2[i2] = this.h[i2] + c2;
            c2 = g2[i2] >>> 13;
            g2[i2] &= 8191;
          }
          g2[9] -= 1 << 13;
          mask = (c2 ^ 1) - 1;
          for (i2 = 0; i2 < 10; i2++)
            g2[i2] &= mask;
          mask = ~mask;
          for (i2 = 0; i2 < 10; i2++)
            this.h[i2] = this.h[i2] & mask | g2[i2];
          this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
          this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
          this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
          this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
          this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
          this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
          this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
          this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
          f2 = this.h[0] + this.pad[0];
          this.h[0] = f2 & 65535;
          for (i2 = 1; i2 < 8; i2++) {
            f2 = (this.h[i2] + this.pad[i2] | 0) + (f2 >>> 16) | 0;
            this.h[i2] = f2 & 65535;
          }
          mac[macpos + 0] = this.h[0] >>> 0 & 255;
          mac[macpos + 1] = this.h[0] >>> 8 & 255;
          mac[macpos + 2] = this.h[1] >>> 0 & 255;
          mac[macpos + 3] = this.h[1] >>> 8 & 255;
          mac[macpos + 4] = this.h[2] >>> 0 & 255;
          mac[macpos + 5] = this.h[2] >>> 8 & 255;
          mac[macpos + 6] = this.h[3] >>> 0 & 255;
          mac[macpos + 7] = this.h[3] >>> 8 & 255;
          mac[macpos + 8] = this.h[4] >>> 0 & 255;
          mac[macpos + 9] = this.h[4] >>> 8 & 255;
          mac[macpos + 10] = this.h[5] >>> 0 & 255;
          mac[macpos + 11] = this.h[5] >>> 8 & 255;
          mac[macpos + 12] = this.h[6] >>> 0 & 255;
          mac[macpos + 13] = this.h[6] >>> 8 & 255;
          mac[macpos + 14] = this.h[7] >>> 0 & 255;
          mac[macpos + 15] = this.h[7] >>> 8 & 255;
        };
        poly1305.prototype.update = function(m2, mpos, bytes) {
          var i2, want;
          if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes)
              want = bytes;
            for (i2 = 0; i2 < want; i2++)
              this.buffer[this.leftover + i2] = m2[mpos + i2];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16)
              return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m2, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (i2 = 0; i2 < bytes; i2++)
              this.buffer[this.leftover + i2] = m2[mpos + i2];
            this.leftover += bytes;
          }
        };
        function crypto_onetimeauth(out, outpos, m2, mpos, n2, k2) {
          var s = new poly1305(k2);
          s.update(m2, mpos, n2);
          s.finish(out, outpos);
          return 0;
        }
        function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n2, k2) {
          var x2 = new Uint8Array(16);
          crypto_onetimeauth(x2, 0, m2, mpos, n2, k2);
          return crypto_verify_16(h2, hpos, x2, 0);
        }
        function crypto_secretbox(c2, m2, d2, n2, k2) {
          var i2;
          if (d2 < 32)
            return -1;
          crypto_stream_xor(c2, 0, m2, 0, d2, n2, k2);
          crypto_onetimeauth(c2, 16, c2, 32, d2 - 32, c2);
          for (i2 = 0; i2 < 16; i2++)
            c2[i2] = 0;
          return 0;
        }
        function crypto_secretbox_open(m2, c2, d2, n2, k2) {
          var i2;
          var x2 = new Uint8Array(32);
          if (d2 < 32)
            return -1;
          crypto_stream(x2, 0, 32, n2, k2);
          if (crypto_onetimeauth_verify(c2, 16, c2, 32, d2 - 32, x2) !== 0)
            return -1;
          crypto_stream_xor(m2, 0, c2, 0, d2, n2, k2);
          for (i2 = 0; i2 < 32; i2++)
            m2[i2] = 0;
          return 0;
        }
        function set25519(r2, a) {
          var i2;
          for (i2 = 0; i2 < 16; i2++)
            r2[i2] = a[i2] | 0;
        }
        function car25519(o) {
          var i2, v2, c2 = 1;
          for (i2 = 0; i2 < 16; i2++) {
            v2 = o[i2] + c2 + 65535;
            c2 = Math.floor(v2 / 65536);
            o[i2] = v2 - c2 * 65536;
          }
          o[0] += c2 - 1 + 37 * (c2 - 1);
        }
        function sel25519(p2, q2, b2) {
          var t2, c2 = ~(b2 - 1);
          for (var i2 = 0; i2 < 16; i2++) {
            t2 = c2 & (p2[i2] ^ q2[i2]);
            p2[i2] ^= t2;
            q2[i2] ^= t2;
          }
        }
        function pack25519(o, n2) {
          var i2, j, b2;
          var m2 = gf2(), t2 = gf2();
          for (i2 = 0; i2 < 16; i2++)
            t2[i2] = n2[i2];
          car25519(t2);
          car25519(t2);
          car25519(t2);
          for (j = 0; j < 2; j++) {
            m2[0] = t2[0] - 65517;
            for (i2 = 1; i2 < 15; i2++) {
              m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
              m2[i2 - 1] &= 65535;
            }
            m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
            b2 = m2[15] >> 16 & 1;
            m2[14] &= 65535;
            sel25519(t2, m2, 1 - b2);
          }
          for (i2 = 0; i2 < 16; i2++) {
            o[2 * i2] = t2[i2] & 255;
            o[2 * i2 + 1] = t2[i2] >> 8;
          }
        }
        function neq25519(a, b2) {
          var c2 = new Uint8Array(32), d2 = new Uint8Array(32);
          pack25519(c2, a);
          pack25519(d2, b2);
          return crypto_verify_32(c2, 0, d2, 0);
        }
        function par25519(a) {
          var d2 = new Uint8Array(32);
          pack25519(d2, a);
          return d2[0] & 1;
        }
        function unpack25519(o, n2) {
          var i2;
          for (i2 = 0; i2 < 16; i2++)
            o[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
          o[15] &= 32767;
        }
        function A2(o, a, b2) {
          for (var i2 = 0; i2 < 16; i2++)
            o[i2] = a[i2] + b2[i2];
        }
        function Z2(o, a, b2) {
          for (var i2 = 0; i2 < 16; i2++)
            o[i2] = a[i2] - b2[i2];
        }
        function M2(o, a, b2) {
          var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
          v2 = a[0];
          t0 += v2 * b0;
          t1 += v2 * b1;
          t2 += v2 * b22;
          t3 += v2 * b3;
          t4 += v2 * b4;
          t5 += v2 * b5;
          t6 += v2 * b6;
          t7 += v2 * b7;
          t8 += v2 * b8;
          t9 += v2 * b9;
          t10 += v2 * b10;
          t11 += v2 * b11;
          t12 += v2 * b12;
          t13 += v2 * b13;
          t14 += v2 * b14;
          t15 += v2 * b15;
          v2 = a[1];
          t1 += v2 * b0;
          t2 += v2 * b1;
          t3 += v2 * b22;
          t4 += v2 * b3;
          t5 += v2 * b4;
          t6 += v2 * b5;
          t7 += v2 * b6;
          t8 += v2 * b7;
          t9 += v2 * b8;
          t10 += v2 * b9;
          t11 += v2 * b10;
          t12 += v2 * b11;
          t13 += v2 * b12;
          t14 += v2 * b13;
          t15 += v2 * b14;
          t16 += v2 * b15;
          v2 = a[2];
          t2 += v2 * b0;
          t3 += v2 * b1;
          t4 += v2 * b22;
          t5 += v2 * b3;
          t6 += v2 * b4;
          t7 += v2 * b5;
          t8 += v2 * b6;
          t9 += v2 * b7;
          t10 += v2 * b8;
          t11 += v2 * b9;
          t12 += v2 * b10;
          t13 += v2 * b11;
          t14 += v2 * b12;
          t15 += v2 * b13;
          t16 += v2 * b14;
          t17 += v2 * b15;
          v2 = a[3];
          t3 += v2 * b0;
          t4 += v2 * b1;
          t5 += v2 * b22;
          t6 += v2 * b3;
          t7 += v2 * b4;
          t8 += v2 * b5;
          t9 += v2 * b6;
          t10 += v2 * b7;
          t11 += v2 * b8;
          t12 += v2 * b9;
          t13 += v2 * b10;
          t14 += v2 * b11;
          t15 += v2 * b12;
          t16 += v2 * b13;
          t17 += v2 * b14;
          t18 += v2 * b15;
          v2 = a[4];
          t4 += v2 * b0;
          t5 += v2 * b1;
          t6 += v2 * b22;
          t7 += v2 * b3;
          t8 += v2 * b4;
          t9 += v2 * b5;
          t10 += v2 * b6;
          t11 += v2 * b7;
          t12 += v2 * b8;
          t13 += v2 * b9;
          t14 += v2 * b10;
          t15 += v2 * b11;
          t16 += v2 * b12;
          t17 += v2 * b13;
          t18 += v2 * b14;
          t19 += v2 * b15;
          v2 = a[5];
          t5 += v2 * b0;
          t6 += v2 * b1;
          t7 += v2 * b22;
          t8 += v2 * b3;
          t9 += v2 * b4;
          t10 += v2 * b5;
          t11 += v2 * b6;
          t12 += v2 * b7;
          t13 += v2 * b8;
          t14 += v2 * b9;
          t15 += v2 * b10;
          t16 += v2 * b11;
          t17 += v2 * b12;
          t18 += v2 * b13;
          t19 += v2 * b14;
          t20 += v2 * b15;
          v2 = a[6];
          t6 += v2 * b0;
          t7 += v2 * b1;
          t8 += v2 * b22;
          t9 += v2 * b3;
          t10 += v2 * b4;
          t11 += v2 * b5;
          t12 += v2 * b6;
          t13 += v2 * b7;
          t14 += v2 * b8;
          t15 += v2 * b9;
          t16 += v2 * b10;
          t17 += v2 * b11;
          t18 += v2 * b12;
          t19 += v2 * b13;
          t20 += v2 * b14;
          t21 += v2 * b15;
          v2 = a[7];
          t7 += v2 * b0;
          t8 += v2 * b1;
          t9 += v2 * b22;
          t10 += v2 * b3;
          t11 += v2 * b4;
          t12 += v2 * b5;
          t13 += v2 * b6;
          t14 += v2 * b7;
          t15 += v2 * b8;
          t16 += v2 * b9;
          t17 += v2 * b10;
          t18 += v2 * b11;
          t19 += v2 * b12;
          t20 += v2 * b13;
          t21 += v2 * b14;
          t22 += v2 * b15;
          v2 = a[8];
          t8 += v2 * b0;
          t9 += v2 * b1;
          t10 += v2 * b22;
          t11 += v2 * b3;
          t12 += v2 * b4;
          t13 += v2 * b5;
          t14 += v2 * b6;
          t15 += v2 * b7;
          t16 += v2 * b8;
          t17 += v2 * b9;
          t18 += v2 * b10;
          t19 += v2 * b11;
          t20 += v2 * b12;
          t21 += v2 * b13;
          t22 += v2 * b14;
          t23 += v2 * b15;
          v2 = a[9];
          t9 += v2 * b0;
          t10 += v2 * b1;
          t11 += v2 * b22;
          t12 += v2 * b3;
          t13 += v2 * b4;
          t14 += v2 * b5;
          t15 += v2 * b6;
          t16 += v2 * b7;
          t17 += v2 * b8;
          t18 += v2 * b9;
          t19 += v2 * b10;
          t20 += v2 * b11;
          t21 += v2 * b12;
          t22 += v2 * b13;
          t23 += v2 * b14;
          t24 += v2 * b15;
          v2 = a[10];
          t10 += v2 * b0;
          t11 += v2 * b1;
          t12 += v2 * b22;
          t13 += v2 * b3;
          t14 += v2 * b4;
          t15 += v2 * b5;
          t16 += v2 * b6;
          t17 += v2 * b7;
          t18 += v2 * b8;
          t19 += v2 * b9;
          t20 += v2 * b10;
          t21 += v2 * b11;
          t22 += v2 * b12;
          t23 += v2 * b13;
          t24 += v2 * b14;
          t25 += v2 * b15;
          v2 = a[11];
          t11 += v2 * b0;
          t12 += v2 * b1;
          t13 += v2 * b22;
          t14 += v2 * b3;
          t15 += v2 * b4;
          t16 += v2 * b5;
          t17 += v2 * b6;
          t18 += v2 * b7;
          t19 += v2 * b8;
          t20 += v2 * b9;
          t21 += v2 * b10;
          t22 += v2 * b11;
          t23 += v2 * b12;
          t24 += v2 * b13;
          t25 += v2 * b14;
          t26 += v2 * b15;
          v2 = a[12];
          t12 += v2 * b0;
          t13 += v2 * b1;
          t14 += v2 * b22;
          t15 += v2 * b3;
          t16 += v2 * b4;
          t17 += v2 * b5;
          t18 += v2 * b6;
          t19 += v2 * b7;
          t20 += v2 * b8;
          t21 += v2 * b9;
          t22 += v2 * b10;
          t23 += v2 * b11;
          t24 += v2 * b12;
          t25 += v2 * b13;
          t26 += v2 * b14;
          t27 += v2 * b15;
          v2 = a[13];
          t13 += v2 * b0;
          t14 += v2 * b1;
          t15 += v2 * b22;
          t16 += v2 * b3;
          t17 += v2 * b4;
          t18 += v2 * b5;
          t19 += v2 * b6;
          t20 += v2 * b7;
          t21 += v2 * b8;
          t22 += v2 * b9;
          t23 += v2 * b10;
          t24 += v2 * b11;
          t25 += v2 * b12;
          t26 += v2 * b13;
          t27 += v2 * b14;
          t28 += v2 * b15;
          v2 = a[14];
          t14 += v2 * b0;
          t15 += v2 * b1;
          t16 += v2 * b22;
          t17 += v2 * b3;
          t18 += v2 * b4;
          t19 += v2 * b5;
          t20 += v2 * b6;
          t21 += v2 * b7;
          t22 += v2 * b8;
          t23 += v2 * b9;
          t24 += v2 * b10;
          t25 += v2 * b11;
          t26 += v2 * b12;
          t27 += v2 * b13;
          t28 += v2 * b14;
          t29 += v2 * b15;
          v2 = a[15];
          t15 += v2 * b0;
          t16 += v2 * b1;
          t17 += v2 * b22;
          t18 += v2 * b3;
          t19 += v2 * b4;
          t20 += v2 * b5;
          t21 += v2 * b6;
          t22 += v2 * b7;
          t23 += v2 * b8;
          t24 += v2 * b9;
          t25 += v2 * b10;
          t26 += v2 * b11;
          t27 += v2 * b12;
          t28 += v2 * b13;
          t29 += v2 * b14;
          t30 += v2 * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c2 = 1;
          v2 = t0 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t0 = v2 - c2 * 65536;
          v2 = t1 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t1 = v2 - c2 * 65536;
          v2 = t2 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t2 = v2 - c2 * 65536;
          v2 = t3 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t3 = v2 - c2 * 65536;
          v2 = t4 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t4 = v2 - c2 * 65536;
          v2 = t5 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t5 = v2 - c2 * 65536;
          v2 = t6 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t6 = v2 - c2 * 65536;
          v2 = t7 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t7 = v2 - c2 * 65536;
          v2 = t8 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t8 = v2 - c2 * 65536;
          v2 = t9 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t9 = v2 - c2 * 65536;
          v2 = t10 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t10 = v2 - c2 * 65536;
          v2 = t11 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t11 = v2 - c2 * 65536;
          v2 = t12 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t12 = v2 - c2 * 65536;
          v2 = t13 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t13 = v2 - c2 * 65536;
          v2 = t14 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t14 = v2 - c2 * 65536;
          v2 = t15 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t15 = v2 - c2 * 65536;
          t0 += c2 - 1 + 37 * (c2 - 1);
          c2 = 1;
          v2 = t0 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t0 = v2 - c2 * 65536;
          v2 = t1 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t1 = v2 - c2 * 65536;
          v2 = t2 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t2 = v2 - c2 * 65536;
          v2 = t3 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t3 = v2 - c2 * 65536;
          v2 = t4 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t4 = v2 - c2 * 65536;
          v2 = t5 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t5 = v2 - c2 * 65536;
          v2 = t6 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t6 = v2 - c2 * 65536;
          v2 = t7 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t7 = v2 - c2 * 65536;
          v2 = t8 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t8 = v2 - c2 * 65536;
          v2 = t9 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t9 = v2 - c2 * 65536;
          v2 = t10 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t10 = v2 - c2 * 65536;
          v2 = t11 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t11 = v2 - c2 * 65536;
          v2 = t12 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t12 = v2 - c2 * 65536;
          v2 = t13 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t13 = v2 - c2 * 65536;
          v2 = t14 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t14 = v2 - c2 * 65536;
          v2 = t15 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t15 = v2 - c2 * 65536;
          t0 += c2 - 1 + 37 * (c2 - 1);
          o[0] = t0;
          o[1] = t1;
          o[2] = t2;
          o[3] = t3;
          o[4] = t4;
          o[5] = t5;
          o[6] = t6;
          o[7] = t7;
          o[8] = t8;
          o[9] = t9;
          o[10] = t10;
          o[11] = t11;
          o[12] = t12;
          o[13] = t13;
          o[14] = t14;
          o[15] = t15;
        }
        function S2(o, a) {
          M2(o, a, a);
        }
        function inv25519(o, i2) {
          var c2 = gf2();
          var a;
          for (a = 0; a < 16; a++)
            c2[a] = i2[a];
          for (a = 253; a >= 0; a--) {
            S2(c2, c2);
            if (a !== 2 && a !== 4)
              M2(c2, c2, i2);
          }
          for (a = 0; a < 16; a++)
            o[a] = c2[a];
        }
        function pow2523(o, i2) {
          var c2 = gf2();
          var a;
          for (a = 0; a < 16; a++)
            c2[a] = i2[a];
          for (a = 250; a >= 0; a--) {
            S2(c2, c2);
            if (a !== 1)
              M2(c2, c2, i2);
          }
          for (a = 0; a < 16; a++)
            o[a] = c2[a];
        }
        function crypto_scalarmult(q2, n2, p2) {
          var z2 = new Uint8Array(32);
          var x2 = new Float64Array(80), r2, i2;
          var a = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2();
          for (i2 = 0; i2 < 31; i2++)
            z2[i2] = n2[i2];
          z2[31] = n2[31] & 127 | 64;
          z2[0] &= 248;
          unpack25519(x2, p2);
          for (i2 = 0; i2 < 16; i2++) {
            b2[i2] = x2[i2];
            d2[i2] = a[i2] = c2[i2] = 0;
          }
          a[0] = d2[0] = 1;
          for (i2 = 254; i2 >= 0; --i2) {
            r2 = z2[i2 >>> 3] >>> (i2 & 7) & 1;
            sel25519(a, b2, r2);
            sel25519(c2, d2, r2);
            A2(e2, a, c2);
            Z2(a, a, c2);
            A2(c2, b2, d2);
            Z2(b2, b2, d2);
            S2(d2, e2);
            S2(f2, a);
            M2(a, c2, a);
            M2(c2, b2, e2);
            A2(e2, a, c2);
            Z2(a, a, c2);
            S2(b2, a);
            Z2(c2, d2, f2);
            M2(a, c2, _121665);
            A2(a, a, d2);
            M2(c2, c2, a);
            M2(a, d2, f2);
            M2(d2, b2, x2);
            S2(b2, e2);
            sel25519(a, b2, r2);
            sel25519(c2, d2, r2);
          }
          for (i2 = 0; i2 < 16; i2++) {
            x2[i2 + 16] = a[i2];
            x2[i2 + 32] = c2[i2];
            x2[i2 + 48] = b2[i2];
            x2[i2 + 64] = d2[i2];
          }
          var x32 = x2.subarray(32);
          var x16 = x2.subarray(16);
          inv25519(x32, x32);
          M2(x16, x16, x32);
          pack25519(q2, x16);
          return 0;
        }
        function crypto_scalarmult_base(q2, n2) {
          return crypto_scalarmult(q2, n2, _9);
        }
        function crypto_box_keypair(y2, x2) {
          randombytes(x2, 32);
          return crypto_scalarmult_base(y2, x2);
        }
        function crypto_box_beforenm(k2, y2, x2) {
          var s = new Uint8Array(32);
          crypto_scalarmult(s, x2, y2);
          return crypto_core_hsalsa20(k2, _0, s, sigma);
        }
        var crypto_box_afternm = crypto_secretbox;
        var crypto_box_open_afternm = crypto_secretbox_open;
        function crypto_box(c2, m2, d2, n2, y2, x2) {
          var k2 = new Uint8Array(32);
          crypto_box_beforenm(k2, y2, x2);
          return crypto_box_afternm(c2, m2, d2, n2, k2);
        }
        function crypto_box_open(m2, c2, d2, n2, y2, x2) {
          var k2 = new Uint8Array(32);
          crypto_box_beforenm(k2, y2, x2);
          return crypto_box_open_afternm(m2, c2, d2, n2, k2);
        }
        var K2 = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        function crypto_hashblocks_hl(hh2, hl2, m2, n2) {
          var wh2 = new Int32Array(16), wl2 = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th2, tl2, i2, j, h2, l2, a, b2, c2, d2;
          var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
          var pos = 0;
          while (n2 >= 128) {
            for (i2 = 0; i2 < 16; i2++) {
              j = 8 * i2 + pos;
              wh2[i2] = m2[j + 0] << 24 | m2[j + 1] << 16 | m2[j + 2] << 8 | m2[j + 3];
              wl2[i2] = m2[j + 4] << 24 | m2[j + 5] << 16 | m2[j + 6] << 8 | m2[j + 7];
            }
            for (i2 = 0; i2 < 80; i2++) {
              bh0 = ah0;
              bh1 = ah1;
              bh2 = ah2;
              bh3 = ah3;
              bh4 = ah4;
              bh5 = ah5;
              bh6 = ah6;
              bh7 = ah7;
              bl0 = al0;
              bl1 = al1;
              bl2 = al2;
              bl3 = al3;
              bl4 = al4;
              bl5 = al5;
              bl6 = al6;
              bl7 = al7;
              h2 = ah7;
              l2 = al7;
              a = l2 & 65535;
              b2 = l2 >>> 16;
              c2 = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
              l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              h2 = ah4 & ah5 ^ ~ah4 & ah6;
              l2 = al4 & al5 ^ ~al4 & al6;
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              h2 = K2[i2 * 2];
              l2 = K2[i2 * 2 + 1];
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              h2 = wh2[i2 % 16];
              l2 = wl2[i2 % 16];
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              b2 += a >>> 16;
              c2 += b2 >>> 16;
              d2 += c2 >>> 16;
              th2 = c2 & 65535 | d2 << 16;
              tl2 = a & 65535 | b2 << 16;
              h2 = th2;
              l2 = tl2;
              a = l2 & 65535;
              b2 = l2 >>> 16;
              c2 = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
              l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
              l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              b2 += a >>> 16;
              c2 += b2 >>> 16;
              d2 += c2 >>> 16;
              bh7 = c2 & 65535 | d2 << 16;
              bl7 = a & 65535 | b2 << 16;
              h2 = bh3;
              l2 = bl3;
              a = l2 & 65535;
              b2 = l2 >>> 16;
              c2 = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = th2;
              l2 = tl2;
              a += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              b2 += a >>> 16;
              c2 += b2 >>> 16;
              d2 += c2 >>> 16;
              bh3 = c2 & 65535 | d2 << 16;
              bl3 = a & 65535 | b2 << 16;
              ah1 = bh0;
              ah2 = bh1;
              ah3 = bh2;
              ah4 = bh3;
              ah5 = bh4;
              ah6 = bh5;
              ah7 = bh6;
              ah0 = bh7;
              al1 = bl0;
              al2 = bl1;
              al3 = bl2;
              al4 = bl3;
              al5 = bl4;
              al6 = bl5;
              al7 = bl6;
              al0 = bl7;
              if (i2 % 16 === 15) {
                for (j = 0; j < 16; j++) {
                  h2 = wh2[j];
                  l2 = wl2[j];
                  a = l2 & 65535;
                  b2 = l2 >>> 16;
                  c2 = h2 & 65535;
                  d2 = h2 >>> 16;
                  h2 = wh2[(j + 9) % 16];
                  l2 = wl2[(j + 9) % 16];
                  a += l2 & 65535;
                  b2 += l2 >>> 16;
                  c2 += h2 & 65535;
                  d2 += h2 >>> 16;
                  th2 = wh2[(j + 1) % 16];
                  tl2 = wl2[(j + 1) % 16];
                  h2 = (th2 >>> 1 | tl2 << 32 - 1) ^ (th2 >>> 8 | tl2 << 32 - 8) ^ th2 >>> 7;
                  l2 = (tl2 >>> 1 | th2 << 32 - 1) ^ (tl2 >>> 8 | th2 << 32 - 8) ^ (tl2 >>> 7 | th2 << 32 - 7);
                  a += l2 & 65535;
                  b2 += l2 >>> 16;
                  c2 += h2 & 65535;
                  d2 += h2 >>> 16;
                  th2 = wh2[(j + 14) % 16];
                  tl2 = wl2[(j + 14) % 16];
                  h2 = (th2 >>> 19 | tl2 << 32 - 19) ^ (tl2 >>> 61 - 32 | th2 << 32 - (61 - 32)) ^ th2 >>> 6;
                  l2 = (tl2 >>> 19 | th2 << 32 - 19) ^ (th2 >>> 61 - 32 | tl2 << 32 - (61 - 32)) ^ (tl2 >>> 6 | th2 << 32 - 6);
                  a += l2 & 65535;
                  b2 += l2 >>> 16;
                  c2 += h2 & 65535;
                  d2 += h2 >>> 16;
                  b2 += a >>> 16;
                  c2 += b2 >>> 16;
                  d2 += c2 >>> 16;
                  wh2[j] = c2 & 65535 | d2 << 16;
                  wl2[j] = a & 65535 | b2 << 16;
                }
              }
            }
            h2 = ah0;
            l2 = al0;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = hh2[0];
            l2 = hl2[0];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            hh2[0] = ah0 = c2 & 65535 | d2 << 16;
            hl2[0] = al0 = a & 65535 | b2 << 16;
            h2 = ah1;
            l2 = al1;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = hh2[1];
            l2 = hl2[1];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            hh2[1] = ah1 = c2 & 65535 | d2 << 16;
            hl2[1] = al1 = a & 65535 | b2 << 16;
            h2 = ah2;
            l2 = al2;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = hh2[2];
            l2 = hl2[2];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            hh2[2] = ah2 = c2 & 65535 | d2 << 16;
            hl2[2] = al2 = a & 65535 | b2 << 16;
            h2 = ah3;
            l2 = al3;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = hh2[3];
            l2 = hl2[3];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            hh2[3] = ah3 = c2 & 65535 | d2 << 16;
            hl2[3] = al3 = a & 65535 | b2 << 16;
            h2 = ah4;
            l2 = al4;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = hh2[4];
            l2 = hl2[4];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            hh2[4] = ah4 = c2 & 65535 | d2 << 16;
            hl2[4] = al4 = a & 65535 | b2 << 16;
            h2 = ah5;
            l2 = al5;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = hh2[5];
            l2 = hl2[5];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            hh2[5] = ah5 = c2 & 65535 | d2 << 16;
            hl2[5] = al5 = a & 65535 | b2 << 16;
            h2 = ah6;
            l2 = al6;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = hh2[6];
            l2 = hl2[6];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            hh2[6] = ah6 = c2 & 65535 | d2 << 16;
            hl2[6] = al6 = a & 65535 | b2 << 16;
            h2 = ah7;
            l2 = al7;
            a = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = hh2[7];
            l2 = hl2[7];
            a += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            hh2[7] = ah7 = c2 & 65535 | d2 << 16;
            hl2[7] = al7 = a & 65535 | b2 << 16;
            pos += 128;
            n2 -= 128;
          }
          return n2;
        }
        function crypto_hash(out, m2, n2) {
          var hh2 = new Int32Array(8), hl2 = new Int32Array(8), x2 = new Uint8Array(256), i2, b2 = n2;
          hh2[0] = 1779033703;
          hh2[1] = 3144134277;
          hh2[2] = 1013904242;
          hh2[3] = 2773480762;
          hh2[4] = 1359893119;
          hh2[5] = 2600822924;
          hh2[6] = 528734635;
          hh2[7] = 1541459225;
          hl2[0] = 4089235720;
          hl2[1] = 2227873595;
          hl2[2] = 4271175723;
          hl2[3] = 1595750129;
          hl2[4] = 2917565137;
          hl2[5] = 725511199;
          hl2[6] = 4215389547;
          hl2[7] = 327033209;
          crypto_hashblocks_hl(hh2, hl2, m2, n2);
          n2 %= 128;
          for (i2 = 0; i2 < n2; i2++)
            x2[i2] = m2[b2 - n2 + i2];
          x2[n2] = 128;
          n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
          x2[n2 - 9] = 0;
          ts64(x2, n2 - 8, b2 / 536870912 | 0, b2 << 3);
          crypto_hashblocks_hl(hh2, hl2, x2, n2);
          for (i2 = 0; i2 < 8; i2++)
            ts64(out, 8 * i2, hh2[i2], hl2[i2]);
          return 0;
        }
        function add(p2, q2) {
          var a = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2(), g2 = gf2(), h2 = gf2(), t2 = gf2();
          Z2(a, p2[1], p2[0]);
          Z2(t2, q2[1], q2[0]);
          M2(a, a, t2);
          A2(b2, p2[0], p2[1]);
          A2(t2, q2[0], q2[1]);
          M2(b2, b2, t2);
          M2(c2, p2[3], q2[3]);
          M2(c2, c2, D22);
          M2(d2, p2[2], q2[2]);
          A2(d2, d2, d2);
          Z2(e2, b2, a);
          Z2(f2, d2, c2);
          A2(g2, d2, c2);
          A2(h2, b2, a);
          M2(p2[0], e2, f2);
          M2(p2[1], h2, g2);
          M2(p2[2], g2, f2);
          M2(p2[3], e2, h2);
        }
        function cswap(p2, q2, b2) {
          var i2;
          for (i2 = 0; i2 < 4; i2++) {
            sel25519(p2[i2], q2[i2], b2);
          }
        }
        function pack(r2, p2) {
          var tx = gf2(), ty = gf2(), zi2 = gf2();
          inv25519(zi2, p2[2]);
          M2(tx, p2[0], zi2);
          M2(ty, p2[1], zi2);
          pack25519(r2, ty);
          r2[31] ^= par25519(tx) << 7;
        }
        function scalarmult(p2, q2, s) {
          var b2, i2;
          set25519(p2[0], gf0);
          set25519(p2[1], gf1);
          set25519(p2[2], gf1);
          set25519(p2[3], gf0);
          for (i2 = 255; i2 >= 0; --i2) {
            b2 = s[i2 / 8 | 0] >> (i2 & 7) & 1;
            cswap(p2, q2, b2);
            add(q2, p2);
            add(p2, p2);
            cswap(p2, q2, b2);
          }
        }
        function scalarbase(p2, s) {
          var q2 = [gf2(), gf2(), gf2(), gf2()];
          set25519(q2[0], X2);
          set25519(q2[1], Y2);
          set25519(q2[2], gf1);
          M2(q2[3], X2, Y2);
          scalarmult(p2, q2, s);
        }
        function crypto_sign_keypair(pk2, sk2, seeded) {
          var d2 = new Uint8Array(64);
          var p2 = [gf2(), gf2(), gf2(), gf2()];
          var i2;
          if (!seeded)
            randombytes(sk2, 32);
          crypto_hash(d2, sk2, 32);
          d2[0] &= 248;
          d2[31] &= 127;
          d2[31] |= 64;
          scalarbase(p2, d2);
          pack(pk2, p2);
          for (i2 = 0; i2 < 32; i2++)
            sk2[i2 + 32] = pk2[i2];
          return 0;
        }
        var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function modL(r2, x2) {
          var carry, i2, j, k2;
          for (i2 = 63; i2 >= 32; --i2) {
            carry = 0;
            for (j = i2 - 32, k2 = i2 - 12; j < k2; ++j) {
              x2[j] += carry - 16 * x2[i2] * L2[j - (i2 - 32)];
              carry = Math.floor((x2[j] + 128) / 256);
              x2[j] -= carry * 256;
            }
            x2[j] += carry;
            x2[i2] = 0;
          }
          carry = 0;
          for (j = 0; j < 32; j++) {
            x2[j] += carry - (x2[31] >> 4) * L2[j];
            carry = x2[j] >> 8;
            x2[j] &= 255;
          }
          for (j = 0; j < 32; j++)
            x2[j] -= carry * L2[j];
          for (i2 = 0; i2 < 32; i2++) {
            x2[i2 + 1] += x2[i2] >> 8;
            r2[i2] = x2[i2] & 255;
          }
        }
        function reduce(r2) {
          var x2 = new Float64Array(64), i2;
          for (i2 = 0; i2 < 64; i2++)
            x2[i2] = r2[i2];
          for (i2 = 0; i2 < 64; i2++)
            r2[i2] = 0;
          modL(r2, x2);
        }
        function crypto_sign(sm, m2, n2, sk2) {
          var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r2 = new Uint8Array(64);
          var i2, j, x2 = new Float64Array(64);
          var p2 = [gf2(), gf2(), gf2(), gf2()];
          crypto_hash(d2, sk2, 32);
          d2[0] &= 248;
          d2[31] &= 127;
          d2[31] |= 64;
          var smlen = n2 + 64;
          for (i2 = 0; i2 < n2; i2++)
            sm[64 + i2] = m2[i2];
          for (i2 = 0; i2 < 32; i2++)
            sm[32 + i2] = d2[32 + i2];
          crypto_hash(r2, sm.subarray(32), n2 + 32);
          reduce(r2);
          scalarbase(p2, r2);
          pack(sm, p2);
          for (i2 = 32; i2 < 64; i2++)
            sm[i2] = sk2[i2];
          crypto_hash(h2, sm, n2 + 64);
          reduce(h2);
          for (i2 = 0; i2 < 64; i2++)
            x2[i2] = 0;
          for (i2 = 0; i2 < 32; i2++)
            x2[i2] = r2[i2];
          for (i2 = 0; i2 < 32; i2++) {
            for (j = 0; j < 32; j++) {
              x2[i2 + j] += h2[i2] * d2[j];
            }
          }
          modL(sm.subarray(32), x2);
          return smlen;
        }
        function unpackneg(r2, p2) {
          var t2 = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
          set25519(r2[2], gf1);
          unpack25519(r2[1], p2);
          S2(num, r2[1]);
          M2(den, num, D2);
          Z2(num, num, r2[2]);
          A2(den, r2[2], den);
          S2(den2, den);
          S2(den4, den2);
          M2(den6, den4, den2);
          M2(t2, den6, num);
          M2(t2, t2, den);
          pow2523(t2, t2);
          M2(t2, t2, num);
          M2(t2, t2, den);
          M2(t2, t2, den);
          M2(r2[0], t2, den);
          S2(chk, r2[0]);
          M2(chk, chk, den);
          if (neq25519(chk, num))
            M2(r2[0], r2[0], I2);
          S2(chk, r2[0]);
          M2(chk, chk, den);
          if (neq25519(chk, num))
            return -1;
          if (par25519(r2[0]) === p2[31] >> 7)
            Z2(r2[0], gf0, r2[0]);
          M2(r2[3], r2[0], r2[1]);
          return 0;
        }
        function crypto_sign_open(m2, sm, n2, pk2) {
          var i2;
          var t2 = new Uint8Array(32), h2 = new Uint8Array(64);
          var p2 = [gf2(), gf2(), gf2(), gf2()], q2 = [gf2(), gf2(), gf2(), gf2()];
          if (n2 < 64)
            return -1;
          if (unpackneg(q2, pk2))
            return -1;
          for (i2 = 0; i2 < n2; i2++)
            m2[i2] = sm[i2];
          for (i2 = 0; i2 < 32; i2++)
            m2[i2 + 32] = pk2[i2];
          crypto_hash(h2, m2, n2);
          reduce(h2);
          scalarmult(p2, q2, h2);
          scalarbase(q2, sm.subarray(32));
          add(p2, q2);
          pack(t2, p2);
          n2 -= 64;
          if (crypto_verify_32(sm, 0, t2, 0)) {
            for (i2 = 0; i2 < n2; i2++)
              m2[i2] = 0;
            return -1;
          }
          for (i2 = 0; i2 < n2; i2++)
            m2[i2] = sm[i2 + 64];
          return n2;
        }
        var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
        nacl.lowlevel = {
          crypto_core_hsalsa20,
          crypto_stream_xor,
          crypto_stream,
          crypto_stream_salsa20_xor,
          crypto_stream_salsa20,
          crypto_onetimeauth,
          crypto_onetimeauth_verify,
          crypto_verify_16,
          crypto_verify_32,
          crypto_secretbox,
          crypto_secretbox_open,
          crypto_scalarmult,
          crypto_scalarmult_base,
          crypto_box_beforenm,
          crypto_box_afternm,
          crypto_box,
          crypto_box_open,
          crypto_box_keypair,
          crypto_hash,
          crypto_sign,
          crypto_sign_keypair,
          crypto_sign_open,
          crypto_secretbox_KEYBYTES,
          crypto_secretbox_NONCEBYTES,
          crypto_secretbox_ZEROBYTES,
          crypto_secretbox_BOXZEROBYTES,
          crypto_scalarmult_BYTES,
          crypto_scalarmult_SCALARBYTES,
          crypto_box_PUBLICKEYBYTES,
          crypto_box_SECRETKEYBYTES,
          crypto_box_BEFORENMBYTES,
          crypto_box_NONCEBYTES,
          crypto_box_ZEROBYTES,
          crypto_box_BOXZEROBYTES,
          crypto_sign_BYTES,
          crypto_sign_PUBLICKEYBYTES,
          crypto_sign_SECRETKEYBYTES,
          crypto_sign_SEEDBYTES,
          crypto_hash_BYTES,
          gf: gf2,
          D: D2,
          L: L2,
          pack25519,
          unpack25519,
          M: M2,
          A: A2,
          S: S2,
          Z: Z2,
          pow2523,
          add,
          set25519,
          modL,
          scalarmult,
          scalarbase
        };
        function checkLengths(k2, n2) {
          if (k2.length !== crypto_secretbox_KEYBYTES)
            throw new Error("bad key size");
          if (n2.length !== crypto_secretbox_NONCEBYTES)
            throw new Error("bad nonce size");
        }
        function checkBoxLengths(pk2, sk2) {
          if (pk2.length !== crypto_box_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          if (sk2.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
        }
        function checkArrayTypes() {
          for (var i2 = 0; i2 < arguments.length; i2++) {
            if (!(arguments[i2] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
          }
        }
        function cleanup2(arr) {
          for (var i2 = 0; i2 < arr.length; i2++)
            arr[i2] = 0;
        }
        nacl.randomBytes = function(n2) {
          var b2 = new Uint8Array(n2);
          randombytes(b2, n2);
          return b2;
        };
        nacl.secretbox = function(msg, nonce, key) {
          checkArrayTypes(msg, nonce, key);
          checkLengths(key, nonce);
          var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
          var c2 = new Uint8Array(m2.length);
          for (var i2 = 0; i2 < msg.length; i2++)
            m2[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
          crypto_secretbox(c2, m2, m2.length, nonce, key);
          return c2.subarray(crypto_secretbox_BOXZEROBYTES);
        };
        nacl.secretbox.open = function(box, nonce, key) {
          checkArrayTypes(box, nonce, key);
          checkLengths(key, nonce);
          var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
          var m2 = new Uint8Array(c2.length);
          for (var i2 = 0; i2 < box.length; i2++)
            c2[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
          if (c2.length < 32)
            return null;
          if (crypto_secretbox_open(m2, c2, c2.length, nonce, key) !== 0)
            return null;
          return m2.subarray(crypto_secretbox_ZEROBYTES);
        };
        nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
        nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
        nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
        nacl.scalarMult = function(n2, p2) {
          checkArrayTypes(n2, p2);
          if (n2.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          if (p2.length !== crypto_scalarmult_BYTES)
            throw new Error("bad p size");
          var q2 = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult(q2, n2, p2);
          return q2;
        };
        nacl.scalarMult.base = function(n2) {
          checkArrayTypes(n2);
          if (n2.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          var q2 = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult_base(q2, n2);
          return q2;
        };
        nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
        nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
        nacl.box = function(msg, nonce, publicKey, secretKey) {
          var k2 = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox(msg, nonce, k2);
        };
        nacl.box.before = function(publicKey, secretKey) {
          checkArrayTypes(publicKey, secretKey);
          checkBoxLengths(publicKey, secretKey);
          var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
          crypto_box_beforenm(k2, publicKey, secretKey);
          return k2;
        };
        nacl.box.after = nacl.secretbox;
        nacl.box.open = function(msg, nonce, publicKey, secretKey) {
          var k2 = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox.open(msg, nonce, k2);
        };
        nacl.box.open.after = nacl.secretbox.open;
        nacl.box.keyPair = function() {
          var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          var sk2 = new Uint8Array(crypto_box_SECRETKEYBYTES);
          crypto_box_keypair(pk2, sk2);
          return { publicKey: pk2, secretKey: sk2 };
        };
        nacl.box.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          crypto_scalarmult_base(pk2, secretKey);
          return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
        };
        nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
        nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
        nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
        nacl.box.nonceLength = crypto_box_NONCEBYTES;
        nacl.box.overheadLength = nacl.secretbox.overheadLength;
        nacl.sign = function(msg, secretKey) {
          checkArrayTypes(msg, secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
          crypto_sign(signedMsg, msg, msg.length, secretKey);
          return signedMsg;
        };
        nacl.sign.open = function(signedMsg, publicKey) {
          checkArrayTypes(signedMsg, publicKey);
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var tmp = new Uint8Array(signedMsg.length);
          var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
          if (mlen < 0)
            return null;
          var m2 = new Uint8Array(mlen);
          for (var i2 = 0; i2 < m2.length; i2++)
            m2[i2] = tmp[i2];
          return m2;
        };
        nacl.sign.detached = function(msg, secretKey) {
          var signedMsg = nacl.sign(msg, secretKey);
          var sig = new Uint8Array(crypto_sign_BYTES);
          for (var i2 = 0; i2 < sig.length; i2++)
            sig[i2] = signedMsg[i2];
          return sig;
        };
        nacl.sign.detached.verify = function(msg, sig, publicKey) {
          checkArrayTypes(msg, sig, publicKey);
          if (sig.length !== crypto_sign_BYTES)
            throw new Error("bad signature size");
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
          var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
          var i2;
          for (i2 = 0; i2 < crypto_sign_BYTES; i2++)
            sm[i2] = sig[i2];
          for (i2 = 0; i2 < msg.length; i2++)
            sm[i2 + crypto_sign_BYTES] = msg[i2];
          return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
        };
        nacl.sign.keyPair = function() {
          var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          crypto_sign_keypair(pk2, sk2);
          return { publicKey: pk2, secretKey: sk2 };
        };
        nacl.sign.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          for (var i2 = 0; i2 < pk2.length; i2++)
            pk2[i2] = secretKey[32 + i2];
          return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
        };
        nacl.sign.keyPair.fromSeed = function(seed) {
          checkArrayTypes(seed);
          if (seed.length !== crypto_sign_SEEDBYTES)
            throw new Error("bad seed size");
          var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          for (var i2 = 0; i2 < 32; i2++)
            sk2[i2] = seed[i2];
          crypto_sign_keypair(pk2, sk2, true);
          return { publicKey: pk2, secretKey: sk2 };
        };
        nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
        nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
        nacl.sign.seedLength = crypto_sign_SEEDBYTES;
        nacl.sign.signatureLength = crypto_sign_BYTES;
        nacl.hash = function(msg) {
          checkArrayTypes(msg);
          var h2 = new Uint8Array(crypto_hash_BYTES);
          crypto_hash(h2, msg, msg.length);
          return h2;
        };
        nacl.hash.hashLength = crypto_hash_BYTES;
        nacl.verify = function(x2, y2) {
          checkArrayTypes(x2, y2);
          if (x2.length === 0 || y2.length === 0)
            return false;
          if (x2.length !== y2.length)
            return false;
          return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
        };
        nacl.setPRNG = function(fn) {
          randombytes = fn;
        };
        (function() {
          var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (crypto2 && crypto2.getRandomValues) {
            var QUOTA = 65536;
            nacl.setPRNG(function(x2, n2) {
              var i2, v2 = new Uint8Array(n2);
              for (i2 = 0; i2 < n2; i2 += QUOTA) {
                crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n2 - i2, QUOTA)));
              }
              for (i2 = 0; i2 < n2; i2++)
                x2[i2] = v2[i2];
              cleanup2(v2);
            });
          } else if (typeof commonjsRequire !== "undefined") {
            crypto2 = require$$0$1;
            if (crypto2 && crypto2.randomBytes) {
              nacl.setPRNG(function(x2, n2) {
                var i2, v2 = crypto2.randomBytes(n2);
                for (i2 = 0; i2 < n2; i2++)
                  x2[i2] = v2[i2];
                cleanup2(v2);
              });
            }
          }
        })();
      })(module2.exports ? module2.exports : self.nacl = self.nacl || {});
    })(naclFast);
    var serialize$2 = {};
    var lib$5 = {};
    var bnExports = {};
    var bn = {
      get exports() {
        return bnExports;
      },
      set exports(v2) {
        bnExports = v2;
      }
    };
    (function(module2) {
      (function(module3, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number2, base2, endian) {
          if (BN.isBN(number2)) {
            return number2;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number2 !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number2 || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports2.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require$$0$1.Buffer;
          }
        } catch (e2) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number2, base2, endian) {
          if (typeof number2 === "number") {
            return this._initNumber(number2, base2, endian);
          }
          if (typeof number2 === "object") {
            return this._initArray(number2, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number2 = number2.toString().replace(/\s+/g, "");
          var start = 0;
          if (number2[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number2.length) {
            if (base2 === 16) {
              this._parseHex(number2, start, endian);
            } else {
              this._parseBase(number2, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number2, base2, endian) {
          if (number2 < 0) {
            this.negative = 1;
            number2 = -number2;
          }
          if (number2 < 67108864) {
            this.words = [number2 & 67108863];
            this.length = 1;
          } else if (number2 < 4503599627370496) {
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number2 < 9007199254740992);
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN.prototype._initArray = function _initArray(number2, base2, endian) {
          assert(typeof number2.length === "number");
          if (number2.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number2.length / 3);
          this.words = new Array(this.length);
          for (var i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = 0;
          }
          var j, w2;
          var off = 0;
          if (endian === "be") {
            for (i2 = number2.length - 1, j = 0; i2 >= 0; i2 -= 3) {
              w2 = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
              this.words[j] |= w2 << off & 67108863;
              this.words[j + 1] = w2 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i2 = 0, j = 0; i2 < number2.length; i2 += 3) {
              w2 = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
              this.words[j] |= w2 << off & 67108863;
              this.words[j + 1] = w2 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string2, index2) {
          var c2 = string2.charCodeAt(index2);
          if (c2 >= 48 && c2 <= 57) {
            return c2 - 48;
          } else if (c2 >= 65 && c2 <= 70) {
            return c2 - 55;
          } else if (c2 >= 97 && c2 <= 102) {
            return c2 - 87;
          } else {
            assert(false, "Invalid character in " + string2);
          }
        }
        function parseHexByte(string2, lowerBound, index2) {
          var r2 = parseHex4Bits(string2, index2);
          if (index2 - 1 >= lowerBound) {
            r2 |= parseHex4Bits(string2, index2 - 1) << 4;
          }
          return r2;
        }
        BN.prototype._parseHex = function _parseHex(number2, start, endian) {
          this.length = Math.ceil((number2.length - start) / 6);
          this.words = new Array(this.length);
          for (var i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = 0;
          }
          var off = 0;
          var j = 0;
          var w2;
          if (endian === "be") {
            for (i2 = number2.length - 1; i2 >= start; i2 -= 2) {
              w2 = parseHexByte(number2, start, i2) << off;
              this.words[j] |= w2 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w2 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number2.length - start;
            for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number2.length; i2 += 2) {
              w2 = parseHexByte(number2, start, i2) << off;
              this.words[j] |= w2 & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w2 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r2 = 0;
          var b2 = 0;
          var len2 = Math.min(str.length, end);
          for (var i2 = start; i2 < len2; i2++) {
            var c2 = str.charCodeAt(i2) - 48;
            r2 *= mul;
            if (c2 >= 49) {
              b2 = c2 - 49 + 10;
            } else if (c2 >= 17) {
              b2 = c2 - 17 + 10;
            } else {
              b2 = c2;
            }
            assert(c2 >= 0 && b2 < mul, "Invalid character");
            r2 += b2;
          }
          return r2;
        }
        BN.prototype._parseBase = function _parseBase(number2, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number2.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i2 = start; i2 < end; i2 += limbLen) {
            word = parseBase(number2, i2, i2 + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number2, i2, number2.length, base2);
            for (i2 = 0; i2 < mod; i2++) {
              pow *= base2;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i2 = 0; i2 < this.length; i2++) {
            dest.words[i2] = this.words[i2];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move2(dest, src2) {
          dest.words = src2.words;
          dest.length = src2.length;
          dest.negative = src2.negative;
          dest.red = src2.red;
        }
        BN.prototype._move = function _move(dest) {
          move2(dest, this);
        };
        BN.prototype.clone = function clone() {
          var r2 = new BN(null);
          this.copy(r2);
          return r2;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e2) {
            BN.prototype.inspect = inspect;
          }
        } else {
          BN.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString2(base2, padding) {
          base2 = base2 || 10;
          padding = padding | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i2 = 0; i2 < this.length; i2++) {
              var w2 = this.words[i2];
              var word = ((w2 << off | carry) & 16777215).toString(16);
              carry = w2 >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i2--;
              }
              if (carry !== 0 || i2 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c2 = this.clone();
            c2.negative = 0;
            while (!c2.isZero()) {
              var r2 = c2.modrn(groupBase).toString(base2);
              c2 = c2.idivn(groupBase);
              if (!c2.isZero()) {
                out = zeros[groupSize - r2.length] + r2 + out;
              } else {
                out = r2 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber2() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN.prototype.toBuffer = function toBuffer(endian, length2) {
            return this.toArrayLike(Buffer2, endian, length2);
          };
        }
        BN.prototype.toArray = function toArray2(endian, length2) {
          return this.toArrayLike(Array, endian, length2);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
          this._strip();
          var byteLength2 = this.byteLength();
          var reqLength = length2 || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength2);
          return res;
        };
        BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
          var position2 = 0;
          var carry = 0;
          for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
            var word = this.words[i2] << shift | carry;
            res[position2++] = word & 255;
            if (position2 < res.length) {
              res[position2++] = word >> 8 & 255;
            }
            if (position2 < res.length) {
              res[position2++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position2 < res.length) {
                res[position2++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position2 < res.length) {
            res[position2++] = carry;
            while (position2 < res.length) {
              res[position2++] = 0;
            }
          }
        };
        BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
          var position2 = res.length - 1;
          var carry = 0;
          for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
            var word = this.words[i2] << shift | carry;
            res[position2--] = word & 255;
            if (position2 >= 0) {
              res[position2--] = word >> 8 & 255;
            }
            if (position2 >= 0) {
              res[position2--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position2 >= 0) {
                res[position2--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position2 >= 0) {
            res[position2--] = carry;
            while (position2 >= 0) {
              res[position2--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w2) {
            return 32 - Math.clz32(w2);
          };
        } else {
          BN.prototype._countBits = function _countBits(w2) {
            var t2 = w2;
            var r2 = 0;
            if (t2 >= 4096) {
              r2 += 13;
              t2 >>>= 13;
            }
            if (t2 >= 64) {
              r2 += 7;
              t2 >>>= 7;
            }
            if (t2 >= 8) {
              r2 += 4;
              t2 >>>= 4;
            }
            if (t2 >= 2) {
              r2 += 2;
              t2 >>>= 2;
            }
            return r2 + t2;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w2) {
          if (w2 === 0)
            return 26;
          var t2 = w2;
          var r2 = 0;
          if ((t2 & 8191) === 0) {
            r2 += 13;
            t2 >>>= 13;
          }
          if ((t2 & 127) === 0) {
            r2 += 7;
            t2 >>>= 7;
          }
          if ((t2 & 15) === 0) {
            r2 += 4;
            t2 >>>= 4;
          }
          if ((t2 & 3) === 0) {
            r2 += 2;
            t2 >>>= 2;
          }
          if ((t2 & 1) === 0) {
            r2++;
          }
          return r2;
        };
        BN.prototype.bitLength = function bitLength() {
          var w2 = this.words[this.length - 1];
          var hi2 = this._countBits(w2);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w2 = new Array(num.bitLength());
          for (var bit = 0; bit < w2.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w2[bit] = num.words[off] >>> wbit & 1;
          }
          return w2;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r2 = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var b2 = this._zeroBits(this.words[i2]);
            r2 += b2;
            if (b2 !== 26)
              break;
          }
          return r2;
        };
        BN.prototype.byteLength = function byteLength2() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i2 = 0; i2 < num.length; i2++) {
            this.words[i2] = this.words[i2] | num.words[i2];
          }
          return this._strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b2;
          if (this.length > num.length) {
            b2 = num;
          } else {
            b2 = this;
          }
          for (var i2 = 0; i2 < b2.length; i2++) {
            this.words[i2] = this.words[i2] & num.words[i2];
          }
          this.length = b2.length;
          return this._strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b2;
          if (this.length > num.length) {
            a = this;
            b2 = num;
          } else {
            a = num;
            b2 = this;
          }
          for (var i2 = 0; i2 < b2.length; i2++) {
            this.words[i2] = a.words[i2] ^ b2.words[i2];
          }
          if (this !== a) {
            for (; i2 < a.length; i2++) {
              this.words[i2] = a.words[i2];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i2 = 0; i2 < bytesNeeded; i2++) {
            this.words[i2] = ~this.words[i2] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r2;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r2 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r2 = this.isub(num);
            num.negative = 1;
            return r2._normSign();
          }
          var a, b2;
          if (this.length > num.length) {
            a = this;
            b2 = num;
          } else {
            a = num;
            b2 = this;
          }
          var carry = 0;
          for (var i2 = 0; i2 < b2.length; i2++) {
            r2 = (a.words[i2] | 0) + (b2.words[i2] | 0) + carry;
            this.words[i2] = r2 & 67108863;
            carry = r2 >>> 26;
          }
          for (; carry !== 0 && i2 < a.length; i2++) {
            r2 = (a.words[i2] | 0) + carry;
            this.words[i2] = r2 & 67108863;
            carry = r2 >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i2 < a.length; i2++) {
              this.words[i2] = a.words[i2];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r2 = this.iadd(num);
            num.negative = 1;
            return r2._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b2;
          if (cmp > 0) {
            a = this;
            b2 = num;
          } else {
            a = num;
            b2 = this;
          }
          var carry = 0;
          for (var i2 = 0; i2 < b2.length; i2++) {
            r2 = (a.words[i2] | 0) - (b2.words[i2] | 0) + carry;
            carry = r2 >> 26;
            this.words[i2] = r2 & 67108863;
          }
          for (; carry !== 0 && i2 < a.length; i2++) {
            r2 = (a.words[i2] | 0) + carry;
            carry = r2 >> 26;
            this.words[i2] = r2 & 67108863;
          }
          if (carry === 0 && i2 < a.length && a !== this) {
            for (; i2 < a.length; i2++) {
              this.words[i2] = a.words[i2];
            }
          }
          this.length = Math.max(this.length, i2);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2;
          len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0;
          var b2 = num.words[0] | 0;
          var r2 = a * b2;
          var lo = r2 & 67108863;
          var carry = r2 / 67108864 | 0;
          out.words[0] = lo;
          for (var k2 = 1; k2 < len2; k2++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k2, num.length - 1);
            for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
              var i2 = k2 - j | 0;
              a = self2.words[i2] | 0;
              b2 = num.words[j] | 0;
              r2 = a * b2 + rword;
              ncarry += r2 / 67108864 | 0;
              rword = r2 & 67108863;
            }
            out.words[k2] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k2] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b2 = num.words;
          var o = out.words;
          var c2 = 0;
          var lo;
          var mid;
          var hi2;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b2[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b2[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b22 = b2[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b3 = b2[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b2[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b2[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b2[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b2[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b2[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b2[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c2 !== 0) {
            o[19] = c2;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k2 = 0; k2 < out.length - 1; k2++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k2, num.length - 1);
            for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
              var i2 = k2 - j;
              var a = self2.words[i2] | 0;
              var b2 = num.words[j] | 0;
              var r2 = a * b2;
              var lo = r2 & 67108863;
              ncarry = ncarry + (r2 / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k2] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k2] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len2 < 63) {
            res = smallMulTo(this, num, out);
          } else if (len2 < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w2 = (this.words[i2] | 0) * num;
            var lo = (w2 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w2 / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i2] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i2] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w2 = toBitArray(num);
          if (w2.length === 0)
            return new BN(1);
          var res = this;
          for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
            if (w2[i2] !== 0)
              break;
          }
          if (++i2 < w2.length) {
            for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
              if (w2[i2] === 0)
                continue;
              res = res.mul(q2);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r2 = bits % 26;
          var s = (bits - r2) / 26;
          var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
          var i2;
          if (r2 !== 0) {
            var carry = 0;
            for (i2 = 0; i2 < this.length; i2++) {
              var newCarry = this.words[i2] & carryMask;
              var c2 = (this.words[i2] | 0) - newCarry << r2;
              this.words[i2] = c2 | carry;
              carry = newCarry >>> 26 - r2;
            }
            if (carry) {
              this.words[i2] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i2 = this.length - 1; i2 >= 0; i2--) {
              this.words[i2 + s] = this.words[i2];
            }
            for (i2 = 0; i2 < s; i2++) {
              this.words[i2] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h2;
          if (hint) {
            h2 = (hint - hint % 26) / 26;
          } else {
            h2 = 0;
          }
          var r2 = bits % 26;
          var s = Math.min((bits - r2) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          var maskedWords = extended;
          h2 -= s;
          h2 = Math.max(0, h2);
          if (maskedWords) {
            for (var i2 = 0; i2 < s; i2++) {
              maskedWords.words[i2] = this.words[i2];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i2 = 0; i2 < this.length; i2++) {
              this.words[i2] = this.words[i2 + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
            var word = this.words[i2] | 0;
            this.words[i2] = carry << 26 - r2 | word >>> r2;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r2 = bit % 26;
          var s = (bit - r2) / 26;
          var q2 = 1 << r2;
          if (this.length <= s)
            return false;
          var w2 = this.words[s];
          return !!(w2 & q2);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r2 = bits % 26;
          var s = (bits - r2) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r2 !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r2 !== 0) {
            var mask = 67108863 ^ 67108863 >>> r2 << r2;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
            this.words[i2] -= 67108864;
            if (i2 === this.length - 1) {
              this.words[i2 + 1] = 1;
            } else {
              this.words[i2 + 1]++;
            }
          }
          this.length = Math.max(this.length, i2 + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
              this.words[i2] += 67108864;
              this.words[i2 + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs2() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len2 = num.length + shift;
          var i2;
          this._expand(len2);
          var w2;
          var carry = 0;
          for (i2 = 0; i2 < num.length; i2++) {
            w2 = (this.words[i2 + shift] | 0) + carry;
            var right = (num.words[i2] | 0) * mul;
            w2 -= right & 67108863;
            carry = (w2 >> 26) - (right / 67108864 | 0);
            this.words[i2 + shift] = w2 & 67108863;
          }
          for (; i2 < this.length - shift; i2++) {
            w2 = (this.words[i2 + shift] | 0) + carry;
            carry = w2 >> 26;
            this.words[i2 + shift] = w2 & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            w2 = -(this.words[i2] | 0) + carry;
            carry = w2 >> 26;
            this.words[i2] = w2 & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b2 = num;
          var bhi = b2.words[b2.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b2 = b2.ushln(shift);
            a.iushln(shift);
            bhi = b2.words[b2.length - 1] | 0;
          }
          var m2 = a.length - b2.length;
          var q2;
          if (mode !== "mod") {
            q2 = new BN(null);
            q2.length = m2 + 1;
            q2.words = new Array(q2.length);
            for (var i2 = 0; i2 < q2.length; i2++) {
              q2.words[i2] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b2, 1, m2);
          if (diff.negative === 0) {
            a = diff;
            if (q2) {
              q2.words[m2] = 1;
            }
          }
          for (var j = m2 - 1; j >= 0; j--) {
            var qj2 = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
            qj2 = Math.min(qj2 / bhi | 0, 67108863);
            a._ishlnsubmul(b2, qj2, j);
            while (a.negative !== 0) {
              qj2--;
              a.negative = 0;
              a._ishlnsubmul(b2, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q2) {
              q2.words[j] = qj2;
            }
          }
          if (q2) {
            q2._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q2 || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p2 = (1 << 26) % num;
          var acc = 0;
          for (var i2 = this.length - 1; i2 >= 0; i2--) {
            acc = (p2 * acc + (this.words[i2] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i2 = this.length - 1; i2 >= 0; i2--) {
            var w2 = (this.words[i2] | 0) + carry * 67108864;
            this.words[i2] = w2 / num | 0;
            carry = w2 % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p2) {
          assert(p2.negative === 0);
          assert(!p2.isZero());
          var x2 = this;
          var y2 = p2.clone();
          if (x2.negative !== 0) {
            x2 = x2.umod(p2);
          } else {
            x2 = x2.clone();
          }
          var A2 = new BN(1);
          var B2 = new BN(0);
          var C2 = new BN(0);
          var D2 = new BN(1);
          var g2 = 0;
          while (x2.isEven() && y2.isEven()) {
            x2.iushrn(1);
            y2.iushrn(1);
            ++g2;
          }
          var yp = y2.clone();
          var xp = x2.clone();
          while (!x2.isZero()) {
            for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              x2.iushrn(i2);
              while (i2-- > 0) {
                if (A2.isOdd() || B2.isOdd()) {
                  A2.iadd(yp);
                  B2.isub(xp);
                }
                A2.iushrn(1);
                B2.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y2.iushrn(j);
              while (j-- > 0) {
                if (C2.isOdd() || D2.isOdd()) {
                  C2.iadd(yp);
                  D2.isub(xp);
                }
                C2.iushrn(1);
                D2.iushrn(1);
              }
            }
            if (x2.cmp(y2) >= 0) {
              x2.isub(y2);
              A2.isub(C2);
              B2.isub(D2);
            } else {
              y2.isub(x2);
              C2.isub(A2);
              D2.isub(B2);
            }
          }
          return {
            a: C2,
            b: D2,
            gcd: y2.iushln(g2)
          };
        };
        BN.prototype._invmp = function _invmp(p2) {
          assert(p2.negative === 0);
          assert(!p2.isZero());
          var a = this;
          var b2 = p2.clone();
          if (a.negative !== 0) {
            a = a.umod(p2);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b2.clone();
          while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
            for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              a.iushrn(i2);
              while (i2-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b2.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b2) >= 0) {
              a.isub(b2);
              x1.isub(x2);
            } else {
              b2.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p2);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b2 = num.clone();
          a.negative = 0;
          b2.negative = 0;
          for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
            a.iushrn(1);
            b2.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b2.isEven()) {
              b2.iushrn(1);
            }
            var r2 = a.cmp(b2);
            if (r2 < 0) {
              var t2 = a;
              a = b2;
              b2 = t2;
            } else if (r2 === 0 || b2.cmpn(1) === 0) {
              break;
            }
            a.isub(b2);
          } while (true);
          return b2.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r2 = bit % 26;
          var s = (bit - r2) / 26;
          var q2 = 1 << r2;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q2;
            return this;
          }
          var carry = q2;
          for (var i2 = s; carry !== 0 && i2 < this.length; i2++) {
            var w2 = this.words[i2] | 0;
            w2 += carry;
            carry = w2 >>> 26;
            w2 &= 67108863;
            this.words[i2] = w2;
          }
          if (carry !== 0) {
            this.words[i2] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w2 = this.words[0] | 0;
            res = w2 === num ? 0 : w2 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i2 = this.length - 1; i2 >= 0; i2--) {
            var a = this.words[i2] | 0;
            var b2 = num.words[i2] | 0;
            if (a === b2)
              continue;
            if (a < b2) {
              res = -1;
            } else if (a > b2) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red2(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p2) {
          this.name = name;
          this.p = new BN(p2, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r2 = num;
          var rlen;
          do {
            this.split(r2, this.tmp);
            r2 = this.imulK(r2);
            r2 = r2.iadd(this.tmp);
            rlen = r2.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
          if (cmp === 0) {
            r2.words[0] = 0;
            r2.length = 1;
          } else if (cmp > 0) {
            r2.isub(this.p);
          } else {
            if (r2.strip !== void 0) {
              r2.strip();
            } else {
              r2._strip();
            }
          }
          return r2;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i2 = 0; i2 < outLen; i2++) {
            output.words[i2] = input.words[i2];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev2 = input.words[9];
          output.words[output.length++] = prev2 & mask;
          for (i2 = 10; i2 < input.length; i2++) {
            var next2 = input.words[i2] | 0;
            input.words[i2 - 10] = (next2 & mask) << 4 | prev2 >>> 22;
            prev2 = next2;
          }
          prev2 >>>= 22;
          input.words[i2 - 10] = prev2;
          if (prev2 === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i2 = 0; i2 < num.length; i2++) {
            var w2 = num.words[i2] | 0;
            lo += w2 * 977;
            num.words[i2] = lo & 67108863;
            lo = w2 * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i2 = 0; i2 < num.length; i2++) {
            var hi2 = (num.words[i2] | 0) * 19 + carry;
            var lo = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i2] = lo;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m2) {
          if (typeof m2 === "string") {
            var prime = BN._prime(m2);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m2.gtn(1), "modulus must be greater than 1");
            this.m = m2;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b2) {
          assert((a.negative | b2.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b2.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move2(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b2) {
          this._verify2(a, b2);
          var res = a.add(b2);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b2) {
          this._verify2(a, b2);
          var res = a.iadd(b2);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b2) {
          this._verify2(a, b2);
          var res = a.sub(b2);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b2) {
          this._verify2(a, b2);
          var res = a.isub(b2);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b2) {
          this._verify2(a, b2);
          return this.imod(a.imul(b2));
        };
        Red.prototype.mul = function mul(a, b2) {
          this._verify2(a, b2);
          return this.imod(a.mul(b2));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q2 = this.m.subn(1);
          var s = 0;
          while (!q2.isZero() && q2.andln(1) === 0) {
            s++;
            q2.iushrn(1);
          }
          assert(!q2.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z2 = this.m.bitLength();
          z2 = new BN(2 * z2 * z2).toRed(this);
          while (this.pow(z2, lpow).cmp(nOne) !== 0) {
            z2.redIAdd(nOne);
          }
          var c2 = this.pow(z2, q2);
          var r2 = this.pow(a, q2.addn(1).iushrn(1));
          var t2 = this.pow(a, q2);
          var m2 = s;
          while (t2.cmp(one) !== 0) {
            var tmp = t2;
            for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
              tmp = tmp.redSqr();
            }
            assert(i2 < m2);
            var b2 = this.pow(c2, new BN(1).iushln(m2 - i2 - 1));
            r2 = r2.redMul(b2);
            c2 = b2.redSqr();
            t2 = t2.redMul(c2);
            m2 = i2;
          }
          return r2;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i2 = 2; i2 < wnd.length; i2++) {
            wnd[i2] = this.mul(wnd[i2 - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i2 = num.length - 1; i2 >= 0; i2--) {
            var word = num.words[i2];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r2 = num.umod(this.m);
          return r2 === num ? r2.clone() : r2;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m2) {
          Red.call(this, m2);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r2 = this.imod(num.mul(this.rinv));
          r2.red = null;
          return r2;
        };
        Mont.prototype.imul = function imul(a, b2) {
          if (a.isZero() || b2.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t2 = a.imul(b2);
          var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u2 = t2.isub(c2).iushrn(this.shift);
          var res = u2;
          if (u2.cmp(this.m) >= 0) {
            res = u2.isub(this.m);
          } else if (u2.cmpn(0) < 0) {
            res = u2.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b2) {
          if (a.isZero() || b2.isZero())
            return new BN(0)._forceRed(this);
          var t2 = a.mul(b2);
          var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u2 = t2.isub(c2).iushrn(this.shift);
          var res = u2;
          if (u2.cmp(this.m) >= 0) {
            res = u2.isub(this.m);
          } else if (u2.cmpn(0) < 0) {
            res = u2.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(module2, commonjsGlobal);
    })(bn);
    var safeBufferExports = {};
    var safeBuffer = {
      get exports() {
        return safeBufferExports;
      },
      set exports(v2) {
        safeBufferExports = v2;
      }
    };
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    (function(module2, exports2) {
      var buffer$1 = buffer;
      var Buffer2 = buffer$1.Buffer;
      function copyProps(src2, dst) {
        for (var key in src2) {
          dst[key] = src2[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer$1;
      } else {
        copyProps(buffer$1, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length2) {
        return Buffer2(arg, encodingOrOffset, length2);
      }
      SafeBuffer.prototype = Object.create(Buffer2.prototype);
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length2) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length2);
      };
      SafeBuffer.alloc = function(size, fill, encoding2) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding2 === "string") {
            buf.fill(fill, encoding2);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer$1.SlowBuffer(size);
      };
    })(safeBuffer, safeBufferExports);
    var _Buffer = safeBufferExports.Buffer;
    function base(ALPHABET2) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
        var x2 = ALPHABET2.charAt(i2);
        var xc2 = x2.charCodeAt(0);
        if (BASE_MAP[xc2] !== 255) {
          throw new TypeError(x2 + " is ambiguous");
        }
        BASE_MAP[xc2] = i2;
      }
      var BASE = ALPHABET2.length;
      var LEADER = ALPHABET2.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i3 = 0;
          for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i3;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET2.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i3 = 0;
          for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i3;
          psz++;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string2) {
        var buffer2 = decodeUnsafe(string2);
        if (buffer2) {
          return buffer2;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    var src = base;
    var basex = src;
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var bs58 = basex(ALPHABET);
    function inRange(a, min, max) {
      return min <= a && a <= max;
    }
    function ToDictionary(o) {
      if (o === void 0)
        return {};
      if (o === Object(o))
        return o;
      throw TypeError("Could not convert argument to dictionary");
    }
    function stringToCodePoints(string2) {
      var s = String(string2);
      var n2 = s.length;
      var i2 = 0;
      var u2 = [];
      while (i2 < n2) {
        var c2 = s.charCodeAt(i2);
        if (c2 < 55296 || c2 > 57343) {
          u2.push(c2);
        } else if (56320 <= c2 && c2 <= 57343) {
          u2.push(65533);
        } else if (55296 <= c2 && c2 <= 56319) {
          if (i2 === n2 - 1) {
            u2.push(65533);
          } else {
            var d2 = string2.charCodeAt(i2 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              var a = c2 & 1023;
              var b2 = d2 & 1023;
              u2.push(65536 + (a << 10) + b2);
              i2 += 1;
            } else {
              u2.push(65533);
            }
          }
        }
        i2 += 1;
      }
      return u2;
    }
    function codePointsToString(code_points) {
      var s = "";
      for (var i2 = 0; i2 < code_points.length; ++i2) {
        var cp = code_points[i2];
        if (cp <= 65535) {
          s += String.fromCharCode(cp);
        } else {
          cp -= 65536;
          s += String.fromCharCode(
            (cp >> 10) + 55296,
            (cp & 1023) + 56320
          );
        }
      }
      return s;
    }
    var end_of_stream = -1;
    function Stream(tokens) {
      this.tokens = [].slice.call(tokens);
    }
    Stream.prototype = {
      /**
       * @return {boolean} True if end-of-stream has been hit.
       */
      endOfStream: function() {
        return !this.tokens.length;
      },
      /**
       * When a token is read from a stream, the first token in the
       * stream must be returned and subsequently removed, and
       * end-of-stream must be returned otherwise.
       *
       * @return {number} Get the next token from the stream, or
       * end_of_stream.
       */
      read: function() {
        if (!this.tokens.length)
          return end_of_stream;
        return this.tokens.shift();
      },
      /**
       * When one or more tokens are prepended to a stream, those tokens
       * must be inserted, in given order, before the first token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
       */
      prepend: function(token2) {
        if (Array.isArray(token2)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token2
          );
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token2);
        }
      },
      /**
       * When one or more tokens are pushed to a stream, those tokens
       * must be inserted, in given order, after the last token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
       */
      push: function(token2) {
        if (Array.isArray(token2)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token2
          );
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token2);
        }
      }
    };
    var finished = -1;
    function decoderError(fatal, opt_code_point) {
      if (fatal)
        throw TypeError("Decoder error");
      return opt_code_point || 65533;
    }
    var DEFAULT_ENCODING = "utf-8";
    function TextDecoder$1(encoding2, options) {
      if (!(this instanceof TextDecoder$1)) {
        return new TextDecoder$1(encoding2, options);
      }
      encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
      if (encoding2 !== DEFAULT_ENCODING) {
        throw new Error("Encoding not supported. Only utf-8 is supported");
      }
      options = ToDictionary(options);
      this._streaming = false;
      this._BOMseen = false;
      this._decoder = null;
      this._fatal = Boolean(options["fatal"]);
      this._ignoreBOM = Boolean(options["ignoreBOM"]);
      Object.defineProperty(this, "encoding", { value: "utf-8" });
      Object.defineProperty(this, "fatal", { value: this._fatal });
      Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
    }
    TextDecoder$1.prototype = {
      /**
       * @param {ArrayBufferView=} input The buffer of bytes to decode.
       * @param {Object=} options
       * @return {string} The decoded string.
       */
      decode: function decode(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(
              code_points,
              /**@type {!Array.<number>}*/
              result
            );
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      }
    };
    function TextEncoder(encoding2, options) {
      if (!(this instanceof TextEncoder))
        return new TextEncoder(encoding2, options);
      encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
      if (encoding2 !== DEFAULT_ENCODING) {
        throw new Error("Encoding not supported. Only utf-8 is supported");
      }
      options = ToDictionary(options);
      this._streaming = false;
      this._encoder = null;
      this._options = { fatal: Boolean(options["fatal"]) };
      Object.defineProperty(this, "encoding", { value: "utf-8" });
    }
    TextEncoder.prototype = {
      /**
       * @param {string=} opt_string The string to encode.
       * @param {Object=} options
       * @return {Uint8Array} Encoded bytes, as a Uint8Array.
       */
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes.push.apply(
              bytes,
              /**@type {!Array.<number>}*/
              result
            );
          else
            bytes.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(
                bytes,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes);
      }
    };
    function UTF8Decoder(options) {
      var fatal = options.fatal;
      var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
      this.handler = function(stream, bite) {
        if (bite === end_of_stream && utf8_bytes_needed !== 0) {
          utf8_bytes_needed = 0;
          return decoderError(fatal);
        }
        if (bite === end_of_stream)
          return finished;
        if (utf8_bytes_needed === 0) {
          if (inRange(bite, 0, 127)) {
            return bite;
          }
          if (inRange(bite, 194, 223)) {
            utf8_bytes_needed = 1;
            utf8_code_point = bite - 192;
          } else if (inRange(bite, 224, 239)) {
            if (bite === 224)
              utf8_lower_boundary = 160;
            if (bite === 237)
              utf8_upper_boundary = 159;
            utf8_bytes_needed = 2;
            utf8_code_point = bite - 224;
          } else if (inRange(bite, 240, 244)) {
            if (bite === 240)
              utf8_lower_boundary = 144;
            if (bite === 244)
              utf8_upper_boundary = 143;
            utf8_bytes_needed = 3;
            utf8_code_point = bite - 240;
          } else {
            return decoderError(fatal);
          }
          utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
          return null;
        }
        if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          stream.prepend(bite);
          return decoderError(fatal);
        }
        utf8_lower_boundary = 128;
        utf8_upper_boundary = 191;
        utf8_bytes_seen += 1;
        utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
        if (utf8_bytes_seen !== utf8_bytes_needed)
          return null;
        var code_point = utf8_code_point;
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        return code_point;
      };
    }
    function UTF8Encoder(options) {
      options.fatal;
      this.handler = function(stream, code_point) {
        if (code_point === end_of_stream)
          return finished;
        if (inRange(code_point, 0, 127))
          return code_point;
        var count, offset;
        if (inRange(code_point, 128, 2047)) {
          count = 1;
          offset = 192;
        } else if (inRange(code_point, 2048, 65535)) {
          count = 2;
          offset = 224;
        } else if (inRange(code_point, 65536, 1114111)) {
          count = 3;
          offset = 240;
        }
        var bytes = [(code_point >> 6 * count) + offset];
        while (count > 0) {
          var temp = code_point >> 6 * (count - 1);
          bytes.push(128 | temp & 63);
          count -= 1;
        }
        return bytes;
      };
    }
    const encoding$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      TextDecoder: TextDecoder$1,
      TextEncoder
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(encoding$1);
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1; i2 >= 0; i2--)
          if (d2 = decorators[i2])
            r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    };
    var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(lib$5, "__esModule", { value: true });
    lib$5.deserializeUnchecked = lib$5.deserialize = lib$5.serialize = lib$5.BinaryReader = lib$5.BinaryWriter = lib$5.BorshError = lib$5.baseDecode = lib$5.baseEncode = void 0;
    const bn_js_1$2 = __importDefault$3(bnExports);
    const bs58_1 = __importDefault$3(bs58);
    const encoding = __importStar(require$$2$1);
    const ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
    const textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
    function baseEncode(value) {
      if (typeof value === "string") {
        value = Buffer.from(value, "utf8");
      }
      return bs58_1.default.encode(Buffer.from(value));
    }
    lib$5.baseEncode = baseEncode;
    function baseDecode(value) {
      return Buffer.from(bs58_1.default.decode(value));
    }
    lib$5.baseDecode = baseDecode;
    const INITIAL_LENGTH = 1024;
    class BorshError extends Error {
      constructor(message) {
        super(message);
        this.fieldPath = [];
        this.originalMessage = message;
      }
      addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
      }
    }
    lib$5.BorshError = BorshError;
    class BinaryWriter {
      constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
      }
      maybeResize() {
        if (this.buf.length < 16 + this.length) {
          this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
        }
      }
      writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
      }
      writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
      }
      writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
      }
      writeU64(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1$2.default(value).toArray("le", 8)));
      }
      writeU128(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1$2.default(value).toArray("le", 16)));
      }
      writeU256(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1$2.default(value).toArray("le", 32)));
      }
      writeU512(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1$2.default(value).toArray("le", 64)));
      }
      writeBuffer(buffer2) {
        this.buf = Buffer.concat([
          Buffer.from(this.buf.subarray(0, this.length)),
          buffer2,
          Buffer.alloc(INITIAL_LENGTH)
        ]);
        this.length += buffer2.length;
      }
      writeString(str) {
        this.maybeResize();
        const b2 = Buffer.from(str, "utf8");
        this.writeU32(b2.length);
        this.writeBuffer(b2);
      }
      writeFixedArray(array2) {
        this.writeBuffer(Buffer.from(array2));
      }
      writeArray(array2, fn) {
        this.maybeResize();
        this.writeU32(array2.length);
        for (const elem of array2) {
          this.maybeResize();
          fn(elem);
        }
      }
      toArray() {
        return this.buf.subarray(0, this.length);
      }
    }
    lib$5.BinaryWriter = BinaryWriter;
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
      const originalMethod = propertyDescriptor.value;
      propertyDescriptor.value = function(...args) {
        try {
          return originalMethod.apply(this, args);
        } catch (e2) {
          if (e2 instanceof RangeError) {
            const code2 = e2.code;
            if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code2) >= 0) {
              throw new BorshError("Reached the end of buffer when deserializing");
            }
          }
          throw e2;
        }
      };
    }
    class BinaryReader {
      constructor(buf) {
        this.buf = buf;
        this.offset = 0;
      }
      readU8() {
        const value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
      }
      readU16() {
        const value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
      }
      readU32() {
        const value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
      }
      readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1$2.default(buf, "le");
      }
      readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1$2.default(buf, "le");
      }
      readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1$2.default(buf, "le");
      }
      readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1$2.default(buf, "le");
      }
      readBuffer(len2) {
        if (this.offset + len2 > this.buf.length) {
          throw new BorshError(`Expected buffer length ${len2} isn't within bounds`);
        }
        const result = this.buf.slice(this.offset, this.offset + len2);
        this.offset += len2;
        return result;
      }
      readString() {
        const len2 = this.readU32();
        const buf = this.readBuffer(len2);
        try {
          return textDecoder.decode(buf);
        } catch (e2) {
          throw new BorshError(`Error decoding UTF-8 string: ${e2}`);
        }
      }
      readFixedArray(len2) {
        return new Uint8Array(this.readBuffer(len2));
      }
      readArray(fn) {
        const len2 = this.readU32();
        const result = Array();
        for (let i2 = 0; i2 < len2; ++i2) {
          result.push(fn());
        }
        return result;
      }
    }
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU8", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU16", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU32", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU64", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU128", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU256", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU512", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readString", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readFixedArray", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readArray", null);
    lib$5.BinaryReader = BinaryReader;
    function capitalizeFirstLetter(string2) {
      return string2.charAt(0).toUpperCase() + string2.slice(1);
    }
    function serializeField(schema2, fieldName, value, fieldType, writer) {
      try {
        if (typeof fieldType === "string") {
          writer[`write${capitalizeFirstLetter(fieldType)}`](value);
        } else if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            if (value.length !== fieldType[0]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
            }
            writer.writeFixedArray(value);
          } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
            if (value.length !== fieldType[1]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
            }
            for (let i2 = 0; i2 < fieldType[1]; i2++) {
              serializeField(schema2, null, value[i2], fieldType[0], writer);
            }
          } else {
            writer.writeArray(value, (item) => {
              serializeField(schema2, fieldName, item, fieldType[0], writer);
            });
          }
        } else if (fieldType.kind !== void 0) {
          switch (fieldType.kind) {
            case "option": {
              if (value === null || value === void 0) {
                writer.writeU8(0);
              } else {
                writer.writeU8(1);
                serializeField(schema2, fieldName, value, fieldType.type, writer);
              }
              break;
            }
            case "map": {
              writer.writeU32(value.size);
              value.forEach((val, key) => {
                serializeField(schema2, fieldName, key, fieldType.key, writer);
                serializeField(schema2, fieldName, val, fieldType.value, writer);
              });
              break;
            }
            default:
              throw new BorshError(`FieldType ${fieldType} unrecognized`);
          }
        } else {
          serializeStruct(schema2, value, writer);
        }
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function serializeStruct(schema2, obj, writer) {
      if (typeof obj.borshSerialize === "function") {
        obj.borshSerialize(writer);
        return;
      }
      const structSchema = schema2.get(obj.constructor);
      if (!structSchema) {
        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        structSchema.fields.map(([fieldName, fieldType]) => {
          serializeField(schema2, fieldName, obj[fieldName], fieldType, writer);
        });
      } else if (structSchema.kind === "enum") {
        const name = obj[structSchema.field];
        for (let idx = 0; idx < structSchema.values.length; ++idx) {
          const [fieldName, fieldType] = structSchema.values[idx];
          if (fieldName === name) {
            writer.writeU8(idx);
            serializeField(schema2, fieldName, obj[fieldName], fieldType, writer);
            break;
          }
        }
      } else {
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
      }
    }
    function serialize$1(schema2, obj, Writer = BinaryWriter) {
      const writer = new Writer();
      serializeStruct(schema2, obj, writer);
      return writer.toArray();
    }
    lib$5.serialize = serialize$1;
    function deserializeField(schema2, fieldName, fieldType, reader) {
      try {
        if (typeof fieldType === "string") {
          return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        }
        if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            return reader.readFixedArray(fieldType[0]);
          } else if (typeof fieldType[1] === "number") {
            const arr = [];
            for (let i2 = 0; i2 < fieldType[1]; i2++) {
              arr.push(deserializeField(schema2, null, fieldType[0], reader));
            }
            return arr;
          } else {
            return reader.readArray(() => deserializeField(schema2, fieldName, fieldType[0], reader));
          }
        }
        if (fieldType.kind === "option") {
          const option = reader.readU8();
          if (option) {
            return deserializeField(schema2, fieldName, fieldType.type, reader);
          }
          return void 0;
        }
        if (fieldType.kind === "map") {
          let map2 = /* @__PURE__ */ new Map();
          const length2 = reader.readU32();
          for (let i2 = 0; i2 < length2; i2++) {
            const key = deserializeField(schema2, fieldName, fieldType.key, reader);
            const val = deserializeField(schema2, fieldName, fieldType.value, reader);
            map2.set(key, val);
          }
          return map2;
        }
        return deserializeStruct(schema2, fieldType, reader);
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function deserializeStruct(schema2, classType, reader) {
      if (typeof classType.borshDeserialize === "function") {
        return classType.borshDeserialize(reader);
      }
      const structSchema = schema2.get(classType);
      if (!structSchema) {
        throw new BorshError(`Class ${classType.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema2.get(classType).fields) {
          result[fieldName] = deserializeField(schema2, fieldName, fieldType, reader);
        }
        return new classType(result);
      }
      if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) {
          throw new BorshError(`Enum index: ${idx} is out of range`);
        }
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(schema2, fieldName, fieldType, reader);
        return new classType({ [fieldName]: fieldValue });
      }
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    }
    function deserialize(schema2, classType, buffer2, Reader = BinaryReader) {
      const reader = new Reader(buffer2);
      const result = deserializeStruct(schema2, classType, reader);
      if (reader.offset < buffer2.length) {
        throw new BorshError(`Unexpected ${buffer2.length - reader.offset} bytes after deserialized data`);
      }
      return result;
    }
    lib$5.deserialize = deserialize;
    function deserializeUnchecked(schema2, classType, buffer2, Reader = BinaryReader) {
      const reader = new Reader(buffer2);
      return deserializeStruct(schema2, classType, reader);
    }
    lib$5.deserializeUnchecked = deserializeUnchecked;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BinaryReader = exports2.BinaryWriter = exports2.BorshError = exports2.deserialize = exports2.serialize = exports2.base_decode = exports2.base_encode = void 0;
      var borsh_1 = lib$5;
      Object.defineProperty(exports2, "base_encode", { enumerable: true, get: function() {
        return borsh_1.baseEncode;
      } });
      Object.defineProperty(exports2, "base_decode", { enumerable: true, get: function() {
        return borsh_1.baseDecode;
      } });
      Object.defineProperty(exports2, "serialize", { enumerable: true, get: function() {
        return borsh_1.serialize;
      } });
      Object.defineProperty(exports2, "deserialize", { enumerable: true, get: function() {
        return borsh_1.deserialize;
      } });
      Object.defineProperty(exports2, "BorshError", { enumerable: true, get: function() {
        return borsh_1.BorshError;
      } });
      Object.defineProperty(exports2, "BinaryWriter", { enumerable: true, get: function() {
        return borsh_1.BinaryWriter;
      } });
      Object.defineProperty(exports2, "BinaryReader", { enumerable: true, get: function() {
        return borsh_1.BinaryReader;
      } });
    })(serialize$2);
    var enums = {};
    Object.defineProperty(enums, "__esModule", { value: true });
    enums.Assignable = enums.Enum = void 0;
    class Enum {
      constructor(properties) {
        if (Object.keys(properties).length !== 1) {
          throw new Error("Enum can only take single value");
        }
        Object.keys(properties).map((key) => {
          this[key] = properties[key];
          this.enum = key;
        });
      }
    }
    enums.Enum = Enum;
    class Assignable {
      constructor(properties) {
        Object.keys(properties).map((key) => {
          this[key] = properties[key];
        });
      }
    }
    enums.Assignable = Assignable;
    (function(exports2) {
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyPairEd25519 = exports2.KeyPair = exports2.PublicKey = exports2.KeyType = void 0;
      const tweetnacl_1 = __importDefault2(naclFastExports);
      const serialize_1 = serialize$2;
      const enums_1 = enums;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["ED25519"] = 0] = "ED25519";
      })(KeyType = exports2.KeyType || (exports2.KeyType = {}));
      function key_type_to_str(keyType) {
        switch (keyType) {
          case KeyType.ED25519:
            return "ed25519";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return KeyType.ED25519;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      class PublicKey extends enums_1.Assignable {
        static from(value) {
          if (typeof value === "string") {
            return PublicKey.fromString(value);
          }
          return value;
        }
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 1) {
            return new PublicKey({ keyType: KeyType.ED25519, data: (0, serialize_1.base_decode)(parts[0]) });
          } else if (parts.length === 2) {
            return new PublicKey({ keyType: str_to_key_type(parts[0]), data: (0, serialize_1.base_decode)(parts[1]) });
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
        toString() {
          return `${key_type_to_str(this.keyType)}:${(0, serialize_1.base_encode)(this.data)}`;
        }
        verify(message, signature) {
          switch (this.keyType) {
            case KeyType.ED25519:
              return tweetnacl_1.default.sign.detached.verify(message, signature, this.data);
            default:
              throw new Error(`Unknown key type ${this.keyType}`);
          }
        }
      }
      exports2.PublicKey = PublicKey;
      class KeyPair {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return KeyPairEd25519.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 1) {
            return new KeyPairEd25519(parts[0]);
          } else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new KeyPairEd25519(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      }
      exports2.KeyPair = KeyPair;
      class KeyPairEd25519 extends KeyPair {
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param {string} secretKey
         */
        constructor(secretKey) {
          super();
          const keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey((0, serialize_1.base_decode)(secretKey));
          this.publicKey = new PublicKey({ keyType: KeyType.ED25519, data: keyPair.publicKey });
          this.secretKey = secretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const newKeyPair = tweetnacl_1.default.sign.keyPair();
          return new KeyPairEd25519((0, serialize_1.base_encode)(newKeyPair.secretKey));
        }
        sign(message) {
          const signature = tweetnacl_1.default.sign.detached(message, (0, serialize_1.base_decode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        toString() {
          return `ed25519:${this.secretKey}`;
        }
        getPublicKey() {
          return this.publicKey;
        }
      }
      exports2.KeyPairEd25519 = KeyPairEd25519;
    })(key_pair);
    var __awaiter$5 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(in_memory_key_store, "__esModule", { value: true });
    in_memory_key_store.InMemoryKeyStore = void 0;
    const keystore_1$2 = keystore;
    const key_pair_1$2 = key_pair;
    class InMemoryKeyStore extends keystore_1$2.KeyStore {
      constructor() {
        super();
        this.keys = {};
      }
      /**
       * Stores a {@link utils/key_pair!KeyPair} in in-memory storage item
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      setKey(networkId, accountId, keyPair) {
        return __awaiter$5(this, void 0, void 0, function* () {
          this.keys[`${accountId}:${networkId}`] = keyPair.toString();
        });
      }
      /**
       * Gets a {@link utils/key_pair!KeyPair} from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      getKey(networkId, accountId) {
        return __awaiter$5(this, void 0, void 0, function* () {
          const value = this.keys[`${accountId}:${networkId}`];
          if (!value) {
            return null;
          }
          return key_pair_1$2.KeyPair.fromString(value);
        });
      }
      /**
       * Removes a {@link utils/key_pair!KeyPair} from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       */
      removeKey(networkId, accountId) {
        return __awaiter$5(this, void 0, void 0, function* () {
          delete this.keys[`${accountId}:${networkId}`];
        });
      }
      /**
       * Removes all {@link utils/key_pair!KeyPair} from in-memory storage
       */
      clear() {
        return __awaiter$5(this, void 0, void 0, function* () {
          this.keys = {};
        });
      }
      /**
       * Get the network(s) from in-memory storage
       * @returns {Promise<string[]>}
       */
      getNetworks() {
        return __awaiter$5(this, void 0, void 0, function* () {
          const result = /* @__PURE__ */ new Set();
          Object.keys(this.keys).forEach((key) => {
            const parts = key.split(":");
            result.add(parts[1]);
          });
          return Array.from(result.values());
        });
      }
      /**
       * Gets the account(s) from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       */
      getAccounts(networkId) {
        return __awaiter$5(this, void 0, void 0, function* () {
          const result = new Array();
          Object.keys(this.keys).forEach((key) => {
            const parts = key.split(":");
            if (parts[parts.length - 1] === networkId) {
              result.push(parts.slice(0, parts.length - 1).join(":"));
            }
          });
          return result;
        });
      }
      /** @hidden */
      toString() {
        return "InMemoryKeyStore";
      }
    }
    in_memory_key_store.InMemoryKeyStore = InMemoryKeyStore;
    var browser_local_storage_key_store = {};
    var __awaiter$4 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(browser_local_storage_key_store, "__esModule", { value: true });
    browser_local_storage_key_store.BrowserLocalStorageKeyStore = void 0;
    const keystore_1$1 = keystore;
    const key_pair_1$1 = key_pair;
    const LOCAL_STORAGE_KEY_PREFIX = "near-api-js:keystore:";
    class BrowserLocalStorageKeyStore extends keystore_1$1.KeyStore {
      /**
       * @param localStorage defaults to window.localStorage
       * @param prefix defaults to `near-api-js:keystore:`
       */
      constructor(localStorage = window.localStorage, prefix = LOCAL_STORAGE_KEY_PREFIX) {
        super();
        this.localStorage = localStorage;
        this.prefix = prefix;
      }
      /**
       * Stores a {@link utils/key_pair!KeyPair} in local storage.
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      setKey(networkId, accountId, keyPair) {
        return __awaiter$4(this, void 0, void 0, function* () {
          this.localStorage.setItem(this.storageKeyForSecretKey(networkId, accountId), keyPair.toString());
        });
      }
      /**
       * Gets a {@link utils/key_pair!KeyPair} from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      getKey(networkId, accountId) {
        return __awaiter$4(this, void 0, void 0, function* () {
          const value = this.localStorage.getItem(this.storageKeyForSecretKey(networkId, accountId));
          if (!value) {
            return null;
          }
          return key_pair_1$1.KeyPair.fromString(value);
        });
      }
      /**
       * Removes a {@link utils/key_pair!KeyPair} from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       */
      removeKey(networkId, accountId) {
        return __awaiter$4(this, void 0, void 0, function* () {
          this.localStorage.removeItem(this.storageKeyForSecretKey(networkId, accountId));
        });
      }
      /**
       * Removes all items that start with `prefix` from local storage
       */
      clear() {
        return __awaiter$4(this, void 0, void 0, function* () {
          for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
              this.localStorage.removeItem(key);
            }
          }
        });
      }
      /**
       * Get the network(s) from local storage
       * @returns {Promise<string[]>}
       */
      getNetworks() {
        return __awaiter$4(this, void 0, void 0, function* () {
          const result = /* @__PURE__ */ new Set();
          for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
              const parts = key.substring(this.prefix.length).split(":");
              result.add(parts[1]);
            }
          }
          return Array.from(result.values());
        });
      }
      /**
       * Gets the account(s) from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc)
       */
      getAccounts(networkId) {
        return __awaiter$4(this, void 0, void 0, function* () {
          const result = new Array();
          for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
              const parts = key.substring(this.prefix.length).split(":");
              if (parts[1] === networkId) {
                result.push(parts[0]);
              }
            }
          }
          return result;
        });
      }
      /**
       * @hidden
       * Helper function to retrieve a local storage key
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the storage keythat's sought
       * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
       */
      storageKeyForSecretKey(networkId, accountId) {
        return `${this.prefix}${accountId}:${networkId}`;
      }
      /** @hidden */
      *storageKeys() {
        for (let i2 = 0; i2 < this.localStorage.length; i2++) {
          yield this.localStorage.key(i2);
        }
      }
    }
    browser_local_storage_key_store.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;
    var merge_key_store = {};
    var __awaiter$3 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(merge_key_store, "__esModule", { value: true });
    merge_key_store.MergeKeyStore = void 0;
    const keystore_1 = keystore;
    class MergeKeyStore extends keystore_1.KeyStore {
      /**
       * @param keyStores read calls are attempted from start to end of array
       * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
       */
      constructor(keyStores, options = { writeKeyStoreIndex: 0 }) {
        super();
        this.options = options;
        this.keyStores = keyStores;
      }
      /**
       * Store a {@link utils/key_pair!KeyPair} to the first index of a key store array
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      setKey(networkId, accountId, keyPair) {
        return __awaiter$3(this, void 0, void 0, function* () {
          yield this.keyStores[this.options.writeKeyStoreIndex].setKey(networkId, accountId, keyPair);
        });
      }
      /**
       * Gets a {@link utils/key_pair!KeyPair} from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      getKey(networkId, accountId) {
        return __awaiter$3(this, void 0, void 0, function* () {
          for (const keyStore of this.keyStores) {
            const keyPair = yield keyStore.getKey(networkId, accountId);
            if (keyPair) {
              return keyPair;
            }
          }
          return null;
        });
      }
      /**
       * Removes a {@link utils/key_pair!KeyPair} from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account tied to the key pair
       */
      removeKey(networkId, accountId) {
        return __awaiter$3(this, void 0, void 0, function* () {
          for (const keyStore of this.keyStores) {
            yield keyStore.removeKey(networkId, accountId);
          }
        });
      }
      /**
       * Removes all items from each key store
       */
      clear() {
        return __awaiter$3(this, void 0, void 0, function* () {
          for (const keyStore of this.keyStores) {
            yield keyStore.clear();
          }
        });
      }
      /**
       * Get the network(s) from the array of key stores
       * @returns {Promise<string[]>}
       */
      getNetworks() {
        return __awaiter$3(this, void 0, void 0, function* () {
          const result = /* @__PURE__ */ new Set();
          for (const keyStore of this.keyStores) {
            for (const network of yield keyStore.getNetworks()) {
              result.add(network);
            }
          }
          return Array.from(result);
        });
      }
      /**
       * Gets the account(s) from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc)
       */
      getAccounts(networkId) {
        return __awaiter$3(this, void 0, void 0, function* () {
          const result = /* @__PURE__ */ new Set();
          for (const keyStore of this.keyStores) {
            for (const account2 of yield keyStore.getAccounts(networkId)) {
              result.add(account2);
            }
          }
          return Array.from(result);
        });
      }
      /** @hidden */
      toString() {
        return `MergeKeyStore(${this.keyStores.join(", ")})`;
      }
    }
    merge_key_store.MergeKeyStore = MergeKeyStore;
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MergeKeyStore = exports2.BrowserLocalStorageKeyStore = exports2.InMemoryKeyStore = exports2.KeyStore = void 0;
      const keystore_12 = keystore;
      Object.defineProperty(exports2, "KeyStore", { enumerable: true, get: function() {
        return keystore_12.KeyStore;
      } });
      const in_memory_key_store_12 = in_memory_key_store;
      Object.defineProperty(exports2, "InMemoryKeyStore", { enumerable: true, get: function() {
        return in_memory_key_store_12.InMemoryKeyStore;
      } });
      const browser_local_storage_key_store_1 = browser_local_storage_key_store;
      Object.defineProperty(exports2, "BrowserLocalStorageKeyStore", { enumerable: true, get: function() {
        return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore;
      } });
      const merge_key_store_1 = merge_key_store;
      Object.defineProperty(exports2, "MergeKeyStore", { enumerable: true, get: function() {
        return merge_key_store_1.MergeKeyStore;
      } });
    })(browserIndex);
    var commonIndex = {};
    var providers = {};
    var provider = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getTransactionLastResult = exports2.Provider = exports2.IdType = exports2.FinalExecutionStatusBasic = exports2.ExecutionStatusBasic = void 0;
      (function(ExecutionStatusBasic) {
        ExecutionStatusBasic["Unknown"] = "Unknown";
        ExecutionStatusBasic["Pending"] = "Pending";
        ExecutionStatusBasic["Failure"] = "Failure";
      })(exports2.ExecutionStatusBasic || (exports2.ExecutionStatusBasic = {}));
      (function(FinalExecutionStatusBasic) {
        FinalExecutionStatusBasic["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic["Started"] = "Started";
        FinalExecutionStatusBasic["Failure"] = "Failure";
      })(exports2.FinalExecutionStatusBasic || (exports2.FinalExecutionStatusBasic = {}));
      (function(IdType) {
        IdType["Transaction"] = "transaction";
        IdType["Receipt"] = "receipt";
      })(exports2.IdType || (exports2.IdType = {}));
      class Provider {
      }
      exports2.Provider = Provider;
      function getTransactionLastResult(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e2) {
            return value;
          }
        }
        return null;
      }
      exports2.getTransactionLastResult = getTransactionLastResult;
    })(provider);
    var jsonRpcProvider = {};
    var web = {};
    var httpErrorsExports = {};
    var httpErrors = {
      get exports() {
        return httpErrorsExports;
      },
      set exports(v2) {
        httpErrorsExports = v2;
      }
    };
    /*!
     * depd
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    var browser$1 = depd$1;
    function depd$1(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate(message) {
      }
      deprecate._file = void 0;
      deprecate._ignored = true;
      deprecate._namespace = namespace;
      deprecate._traced = false;
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction$1;
      deprecate.property = wrapproperty$1;
      return deprecate;
    }
    function wrapfunction$1(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn;
    }
    function wrapproperty$1(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
    var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
    const require$$0 = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "(Unused)",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    /*!
     * statuses
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2016 Douglas Christopher Wilson
     * MIT Licensed
     */
    var codes = require$$0;
    var statuses = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function populateStatusesMap(statuses2, codes2) {
      var arr = [];
      Object.keys(codes2).forEach(function forEachCode(code2) {
        var message = codes2[code2];
        var status2 = Number(code2);
        statuses2[status2] = message;
        statuses2[message] = status2;
        statuses2[message.toLowerCase()] = status2;
        arr.push(status2);
      });
      return arr;
    }
    function status(code2) {
      if (typeof code2 === "number") {
        if (!status[code2])
          throw new Error("invalid status code: " + code2);
        return code2;
      }
      if (typeof code2 !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n2 = parseInt(code2, 10);
      if (!isNaN(n2)) {
        if (!status[n2])
          throw new Error("invalid status code: " + n2);
        return n2;
      }
      n2 = status[code2.toLowerCase()];
      if (!n2)
        throw new Error('invalid status message: "' + code2 + '"');
      return n2;
    }
    var inherits_browserExports = {};
    var inherits_browser = {
      get exports() {
        return inherits_browserExports;
      },
      set exports(v2) {
        inherits_browserExports = v2;
      }
    };
    if (typeof Object.create === "function") {
      inherits_browser.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      inherits_browser.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    /*!
     * toidentifier
     * Copyright(c) 2016 Douglas Christopher Wilson
     * MIT Licensed
     */
    var toidentifier = toIdentifier;
    function toIdentifier(str) {
      return str.split(" ").map(function(token2) {
        return token2.slice(0, 1).toUpperCase() + token2.slice(1);
      }).join("").replace(/[^ _0-9a-z]/gi, "");
    }
    /*!
     * http-errors
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2016 Douglas Christopher Wilson
     * MIT Licensed
     */
    (function(module2) {
      var deprecate = browser$1("http-errors");
      var setPrototypeOf = setprototypeof;
      var statuses$1 = statuses;
      var inherits = inherits_browserExports;
      var toIdentifier2 = toidentifier;
      module2.exports = createError;
      module2.exports.HttpError = createHttpErrorConstructor();
      module2.exports.isHttpError = createIsHttpErrorFunction(module2.exports.HttpError);
      populateConstructorExports(module2.exports, statuses$1.codes, module2.exports.HttpError);
      function codeClass(status2) {
        return Number(String(status2).charAt(0) + "00");
      }
      function createError() {
        var err;
        var msg;
        var status2 = 500;
        var props = {};
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg instanceof Error) {
            err = arg;
            status2 = err.status || err.statusCode || status2;
            continue;
          }
          switch (typeof arg) {
            case "string":
              msg = arg;
              break;
            case "number":
              status2 = arg;
              break;
            case "object":
              props = arg;
              break;
          }
        }
        if (typeof status2 !== "number" || !statuses$1[status2] && (status2 < 400 || status2 >= 600)) {
          status2 = 500;
        }
        var HttpError = createError[status2] || createError[codeClass(status2)];
        if (!err) {
          err = HttpError ? new HttpError(msg) : new Error(msg || statuses$1[status2]);
          Error.captureStackTrace(err, createError);
        }
        if (!HttpError || !(err instanceof HttpError) || err.status !== status2) {
          err.expose = status2 < 500;
          err.status = err.statusCode = status2;
        }
        for (var key in props) {
          if (key !== "status" && key !== "statusCode") {
            err[key] = props[key];
          }
        }
        return err;
      }
      function createHttpErrorConstructor() {
        function HttpError() {
          throw new TypeError("cannot construct abstract class");
        }
        inherits(HttpError, Error);
        return HttpError;
      }
      function createClientErrorConstructor(HttpError, name, code2) {
        var className = toClassName(name);
        function ClientError(message) {
          var msg = message != null ? message : statuses$1[code2];
          var err = new Error(msg);
          Error.captureStackTrace(err, ClientError);
          setPrototypeOf(err, ClientError.prototype);
          Object.defineProperty(err, "message", {
            enumerable: true,
            configurable: true,
            value: msg,
            writable: true
          });
          Object.defineProperty(err, "name", {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
          });
          return err;
        }
        inherits(ClientError, HttpError);
        nameFunc(ClientError, className);
        ClientError.prototype.status = code2;
        ClientError.prototype.statusCode = code2;
        ClientError.prototype.expose = true;
        return ClientError;
      }
      function createIsHttpErrorFunction(HttpError) {
        return function isHttpError(val) {
          if (!val || typeof val !== "object") {
            return false;
          }
          if (val instanceof HttpError) {
            return true;
          }
          return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
        };
      }
      function createServerErrorConstructor(HttpError, name, code2) {
        var className = toClassName(name);
        function ServerError(message) {
          var msg = message != null ? message : statuses$1[code2];
          var err = new Error(msg);
          Error.captureStackTrace(err, ServerError);
          setPrototypeOf(err, ServerError.prototype);
          Object.defineProperty(err, "message", {
            enumerable: true,
            configurable: true,
            value: msg,
            writable: true
          });
          Object.defineProperty(err, "name", {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
          });
          return err;
        }
        inherits(ServerError, HttpError);
        nameFunc(ServerError, className);
        ServerError.prototype.status = code2;
        ServerError.prototype.statusCode = code2;
        ServerError.prototype.expose = false;
        return ServerError;
      }
      function nameFunc(func, name) {
        var desc = Object.getOwnPropertyDescriptor(func, "name");
        if (desc && desc.configurable) {
          desc.value = name;
          Object.defineProperty(func, "name", desc);
        }
      }
      function populateConstructorExports(exports2, codes2, HttpError) {
        codes2.forEach(function forEachCode(code2) {
          var CodeError;
          var name = toIdentifier2(statuses$1[code2]);
          switch (codeClass(code2)) {
            case 400:
              CodeError = createClientErrorConstructor(HttpError, name, code2);
              break;
            case 500:
              CodeError = createServerErrorConstructor(HttpError, name, code2);
              break;
          }
          if (CodeError) {
            exports2[code2] = CodeError;
            exports2[name] = CodeError;
          }
        });
        exports2["I'mateapot"] = deprecate.function(
          exports2.ImATeapot,
          `"I'mateapot"; use "ImATeapot" instead`
        );
      }
      function toClassName(name) {
        return name.substr(-5) !== "Error" ? name + "Error" : name;
      }
    })(httpErrors);
    var exponentialBackoff$1 = {};
    var __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exponentialBackoff$1, "__esModule", { value: true });
    function exponentialBackoff(startWaitTime, retryNumber, waitBackoff, getResult) {
      return __awaiter$2(this, void 0, void 0, function* () {
        let waitTime = startWaitTime;
        for (let i2 = 0; i2 < retryNumber; i2++) {
          const result = yield getResult();
          if (result) {
            return result;
          }
          yield sleep(waitTime);
          waitTime *= waitBackoff;
        }
        return null;
      });
    }
    exponentialBackoff$1.default = exponentialBackoff;
    function sleep(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    var errors = {};
    Object.defineProperty(errors, "__esModule", { value: true });
    errors.logWarning = errors.ErrorContext = errors.TypedError = errors.ArgumentTypeError = errors.PositionalArgsError = void 0;
    class PositionalArgsError extends Error {
      constructor() {
        super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
      }
    }
    errors.PositionalArgsError = PositionalArgsError;
    class ArgumentTypeError extends Error {
      constructor(argName, argType, argValue) {
        super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
      }
    }
    errors.ArgumentTypeError = ArgumentTypeError;
    class TypedError extends Error {
      constructor(message, type2, context) {
        super(message);
        this.type = type2 || "UntypedError";
        this.context = context;
      }
    }
    errors.TypedError = TypedError;
    class ErrorContext {
      constructor(transactionHash) {
        this.transactionHash = transactionHash;
      }
    }
    errors.ErrorContext = ErrorContext;
    function logWarning(...args) {
      if (!process.env["NEAR_NO_LOGS"]) {
        console.warn(...args);
      }
    }
    errors.logWarning = logWarning;
    var hasRequiredWeb;
    function requireWeb() {
      if (hasRequiredWeb)
        return web;
      hasRequiredWeb = 1;
      var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(web, "__esModule", { value: true });
      web.fetchJson = void 0;
      const http_errors_1 = __importDefault2(httpErrorsExports);
      const exponential_backoff_1 = __importDefault2(exponentialBackoff$1);
      const providers_1 = requireProviders();
      const errors_1 = errors;
      const START_WAIT_TIME_MS = 1e3;
      const BACKOFF_MULTIPLIER = 1.5;
      const RETRY_NUMBER = 10;
      function fetchJson(connectionInfoOrUrl, json) {
        return __awaiter2(this, void 0, void 0, function* () {
          let connectionInfo = { url: null };
          if (typeof connectionInfoOrUrl === "string") {
            connectionInfo.url = connectionInfoOrUrl;
          } else {
            connectionInfo = connectionInfoOrUrl;
          }
          const response = yield (0, exponential_backoff_1.default)(START_WAIT_TIME_MS, RETRY_NUMBER, BACKOFF_MULTIPLIER, () => __awaiter2(this, void 0, void 0, function* () {
            try {
              const response2 = yield fetch(connectionInfo.url, {
                method: json ? "POST" : "GET",
                body: json ? json : void 0,
                headers: Object.assign(Object.assign({}, connectionInfo.headers), { "Content-Type": "application/json" })
              });
              if (!response2.ok) {
                if (response2.status === 503) {
                  (0, errors_1.logWarning)(`Retrying HTTP request for ${connectionInfo.url} as it's not available now`);
                  return null;
                }
                throw (0, http_errors_1.default)(response2.status, yield response2.text());
              }
              return response2;
            } catch (error) {
              if (error.toString().includes("FetchError") || error.toString().includes("Failed to fetch")) {
                (0, errors_1.logWarning)(`Retrying HTTP request for ${connectionInfo.url} because of error: ${error}`);
                return null;
              }
              throw error;
            }
          }));
          if (!response) {
            throw new providers_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${connectionInfo.url}.`, "RetriesExceeded");
          }
          return yield response.json();
        });
      }
      web.fetchJson = fetchJson;
      return web;
    }
    var rpc_errors = {};
    var mustacheExports = {};
    var mustache = {
      get exports() {
        return mustacheExports;
      },
      set exports(v2) {
        mustacheExports = v2;
      }
    };
    (function(module2, exports2) {
      (function(global2, factory) {
        module2.exports = factory();
      })(commonjsGlobal, function() {
        /*!
         * mustache.js - Logic-less {{mustache}} templates with JavaScript
         * http://github.com/janl/mustache.js
         */
        var objectToString2 = Object.prototype.toString;
        var isArray2 = Array.isArray || function isArrayPolyfill(object2) {
          return objectToString2.call(object2) === "[object Array]";
        };
        function isFunction2(object2) {
          return typeof object2 === "function";
        }
        function typeStr(obj) {
          return isArray2(obj) ? "array" : typeof obj;
        }
        function escapeRegExp(string2) {
          return string2.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        }
        function hasProperty(obj, propName) {
          return obj != null && typeof obj === "object" && propName in obj;
        }
        function primitiveHasOwnProperty(primitive, propName) {
          return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
        }
        var regExpTest = RegExp.prototype.test;
        function testRegExp(re2, string2) {
          return regExpTest.call(re2, string2);
        }
        var nonSpaceRe = /\S/;
        function isWhitespace(string2) {
          return !testRegExp(nonSpaceRe, string2);
        }
        var entityMap = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
          "/": "&#x2F;",
          "`": "&#x60;",
          "=": "&#x3D;"
        };
        function escapeHtml(string2) {
          return String(string2).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
            return entityMap[s];
          });
        }
        var whiteRe = /\s*/;
        var spaceRe = /\s+/;
        var equalsRe = /\s*=/;
        var curlyRe = /\s*\}/;
        var tagRe = /#|\^|\/|>|\{|&|=|!/;
        function parseTemplate(template, tags) {
          if (!template)
            return [];
          var lineHasNonSpace = false;
          var sections = [];
          var tokens = [];
          var spaces = [];
          var hasTag = false;
          var nonSpace = false;
          var indentation = "";
          var tagIndex = 0;
          function stripSpace() {
            if (hasTag && !nonSpace) {
              while (spaces.length)
                delete tokens[spaces.pop()];
            } else {
              spaces = [];
            }
            hasTag = false;
            nonSpace = false;
          }
          var openingTagRe, closingTagRe, closingCurlyRe;
          function compileTags(tagsToCompile) {
            if (typeof tagsToCompile === "string")
              tagsToCompile = tagsToCompile.split(spaceRe, 2);
            if (!isArray2(tagsToCompile) || tagsToCompile.length !== 2)
              throw new Error("Invalid tags: " + tagsToCompile);
            openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
            closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
            closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
          }
          compileTags(tags || mustache2.tags);
          var scanner = new Scanner(template);
          var start, type2, value, chr, token2, openSection;
          while (!scanner.eos()) {
            start = scanner.pos;
            value = scanner.scanUntil(openingTagRe);
            if (value) {
              for (var i2 = 0, valueLength = value.length; i2 < valueLength; ++i2) {
                chr = value.charAt(i2);
                if (isWhitespace(chr)) {
                  spaces.push(tokens.length);
                  indentation += chr;
                } else {
                  nonSpace = true;
                  lineHasNonSpace = true;
                  indentation += " ";
                }
                tokens.push(["text", chr, start, start + 1]);
                start += 1;
                if (chr === "\n") {
                  stripSpace();
                  indentation = "";
                  tagIndex = 0;
                  lineHasNonSpace = false;
                }
              }
            }
            if (!scanner.scan(openingTagRe))
              break;
            hasTag = true;
            type2 = scanner.scan(tagRe) || "name";
            scanner.scan(whiteRe);
            if (type2 === "=") {
              value = scanner.scanUntil(equalsRe);
              scanner.scan(equalsRe);
              scanner.scanUntil(closingTagRe);
            } else if (type2 === "{") {
              value = scanner.scanUntil(closingCurlyRe);
              scanner.scan(curlyRe);
              scanner.scanUntil(closingTagRe);
              type2 = "&";
            } else {
              value = scanner.scanUntil(closingTagRe);
            }
            if (!scanner.scan(closingTagRe))
              throw new Error("Unclosed tag at " + scanner.pos);
            if (type2 == ">") {
              token2 = [type2, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
            } else {
              token2 = [type2, value, start, scanner.pos];
            }
            tagIndex++;
            tokens.push(token2);
            if (type2 === "#" || type2 === "^") {
              sections.push(token2);
            } else if (type2 === "/") {
              openSection = sections.pop();
              if (!openSection)
                throw new Error('Unopened section "' + value + '" at ' + start);
              if (openSection[1] !== value)
                throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
            } else if (type2 === "name" || type2 === "{" || type2 === "&") {
              nonSpace = true;
            } else if (type2 === "=") {
              compileTags(value);
            }
          }
          stripSpace();
          openSection = sections.pop();
          if (openSection)
            throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
          return nestTokens(squashTokens(tokens));
        }
        function squashTokens(tokens) {
          var squashedTokens = [];
          var token2, lastToken;
          for (var i2 = 0, numTokens = tokens.length; i2 < numTokens; ++i2) {
            token2 = tokens[i2];
            if (token2) {
              if (token2[0] === "text" && lastToken && lastToken[0] === "text") {
                lastToken[1] += token2[1];
                lastToken[3] = token2[3];
              } else {
                squashedTokens.push(token2);
                lastToken = token2;
              }
            }
          }
          return squashedTokens;
        }
        function nestTokens(tokens) {
          var nestedTokens = [];
          var collector = nestedTokens;
          var sections = [];
          var token2, section;
          for (var i2 = 0, numTokens = tokens.length; i2 < numTokens; ++i2) {
            token2 = tokens[i2];
            switch (token2[0]) {
              case "#":
              case "^":
                collector.push(token2);
                sections.push(token2);
                collector = token2[4] = [];
                break;
              case "/":
                section = sections.pop();
                section[5] = token2[2];
                collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
                break;
              default:
                collector.push(token2);
            }
          }
          return nestedTokens;
        }
        function Scanner(string2) {
          this.string = string2;
          this.tail = string2;
          this.pos = 0;
        }
        Scanner.prototype.eos = function eos() {
          return this.tail === "";
        };
        Scanner.prototype.scan = function scan(re2) {
          var match = this.tail.match(re2);
          if (!match || match.index !== 0)
            return "";
          var string2 = match[0];
          this.tail = this.tail.substring(string2.length);
          this.pos += string2.length;
          return string2;
        };
        Scanner.prototype.scanUntil = function scanUntil(re2) {
          var index2 = this.tail.search(re2), match;
          switch (index2) {
            case -1:
              match = this.tail;
              this.tail = "";
              break;
            case 0:
              match = "";
              break;
            default:
              match = this.tail.substring(0, index2);
              this.tail = this.tail.substring(index2);
          }
          this.pos += match.length;
          return match;
        };
        function Context2(view, parentContext) {
          this.view = view;
          this.cache = { ".": this.view };
          this.parent = parentContext;
        }
        Context2.prototype.push = function push(view) {
          return new Context2(view, this);
        };
        Context2.prototype.lookup = function lookup2(name) {
          var cache = this.cache;
          var value;
          if (cache.hasOwnProperty(name)) {
            value = cache[name];
          } else {
            var context = this, intermediateValue, names2, index2, lookupHit = false;
            while (context) {
              if (name.indexOf(".") > 0) {
                intermediateValue = context.view;
                names2 = name.split(".");
                index2 = 0;
                while (intermediateValue != null && index2 < names2.length) {
                  if (index2 === names2.length - 1)
                    lookupHit = hasProperty(intermediateValue, names2[index2]) || primitiveHasOwnProperty(intermediateValue, names2[index2]);
                  intermediateValue = intermediateValue[names2[index2++]];
                }
              } else {
                intermediateValue = context.view[name];
                lookupHit = hasProperty(context.view, name);
              }
              if (lookupHit) {
                value = intermediateValue;
                break;
              }
              context = context.parent;
            }
            cache[name] = value;
          }
          if (isFunction2(value))
            value = value.call(this.view);
          return value;
        };
        function Writer() {
          this.templateCache = {
            _cache: {},
            set: function set2(key, value) {
              this._cache[key] = value;
            },
            get: function get2(key) {
              return this._cache[key];
            },
            clear: function clear() {
              this._cache = {};
            }
          };
        }
        Writer.prototype.clearCache = function clearCache() {
          if (typeof this.templateCache !== "undefined") {
            this.templateCache.clear();
          }
        };
        Writer.prototype.parse = function parse2(template, tags) {
          var cache = this.templateCache;
          var cacheKey = template + ":" + (tags || mustache2.tags).join(":");
          var isCacheEnabled = typeof cache !== "undefined";
          var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
          if (tokens == void 0) {
            tokens = parseTemplate(template, tags);
            isCacheEnabled && cache.set(cacheKey, tokens);
          }
          return tokens;
        };
        Writer.prototype.render = function render2(template, view, partials, config) {
          var tags = this.getConfigTags(config);
          var tokens = this.parse(template, tags);
          var context = view instanceof Context2 ? view : new Context2(view, void 0);
          return this.renderTokens(tokens, context, partials, template, config);
        };
        Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
          var buffer2 = "";
          var token2, symbol, value;
          for (var i2 = 0, numTokens = tokens.length; i2 < numTokens; ++i2) {
            value = void 0;
            token2 = tokens[i2];
            symbol = token2[0];
            if (symbol === "#")
              value = this.renderSection(token2, context, partials, originalTemplate, config);
            else if (symbol === "^")
              value = this.renderInverted(token2, context, partials, originalTemplate, config);
            else if (symbol === ">")
              value = this.renderPartial(token2, context, partials, config);
            else if (symbol === "&")
              value = this.unescapedValue(token2, context);
            else if (symbol === "name")
              value = this.escapedValue(token2, context, config);
            else if (symbol === "text")
              value = this.rawValue(token2);
            if (value !== void 0)
              buffer2 += value;
          }
          return buffer2;
        };
        Writer.prototype.renderSection = function renderSection(token2, context, partials, originalTemplate, config) {
          var self2 = this;
          var buffer2 = "";
          var value = context.lookup(token2[1]);
          function subRender(template) {
            return self2.render(template, context, partials, config);
          }
          if (!value)
            return;
          if (isArray2(value)) {
            for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
              buffer2 += this.renderTokens(token2[4], context.push(value[j]), partials, originalTemplate, config);
            }
          } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
            buffer2 += this.renderTokens(token2[4], context.push(value), partials, originalTemplate, config);
          } else if (isFunction2(value)) {
            if (typeof originalTemplate !== "string")
              throw new Error("Cannot use higher-order sections without the original template");
            value = value.call(context.view, originalTemplate.slice(token2[3], token2[5]), subRender);
            if (value != null)
              buffer2 += value;
          } else {
            buffer2 += this.renderTokens(token2[4], context, partials, originalTemplate, config);
          }
          return buffer2;
        };
        Writer.prototype.renderInverted = function renderInverted(token2, context, partials, originalTemplate, config) {
          var value = context.lookup(token2[1]);
          if (!value || isArray2(value) && value.length === 0)
            return this.renderTokens(token2[4], context, partials, originalTemplate, config);
        };
        Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
          var filteredIndentation = indentation.replace(/[^ \t]/g, "");
          var partialByNl = partial.split("\n");
          for (var i2 = 0; i2 < partialByNl.length; i2++) {
            if (partialByNl[i2].length && (i2 > 0 || !lineHasNonSpace)) {
              partialByNl[i2] = filteredIndentation + partialByNl[i2];
            }
          }
          return partialByNl.join("\n");
        };
        Writer.prototype.renderPartial = function renderPartial(token2, context, partials, config) {
          if (!partials)
            return;
          var tags = this.getConfigTags(config);
          var value = isFunction2(partials) ? partials(token2[1]) : partials[token2[1]];
          if (value != null) {
            var lineHasNonSpace = token2[6];
            var tagIndex = token2[5];
            var indentation = token2[4];
            var indentedValue = value;
            if (tagIndex == 0 && indentation) {
              indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
            }
            var tokens = this.parse(indentedValue, tags);
            return this.renderTokens(tokens, context, partials, indentedValue, config);
          }
        };
        Writer.prototype.unescapedValue = function unescapedValue(token2, context) {
          var value = context.lookup(token2[1]);
          if (value != null)
            return value;
        };
        Writer.prototype.escapedValue = function escapedValue(token2, context, config) {
          var escape2 = this.getConfigEscape(config) || mustache2.escape;
          var value = context.lookup(token2[1]);
          if (value != null)
            return typeof value === "number" && escape2 === mustache2.escape ? String(value) : escape2(value);
        };
        Writer.prototype.rawValue = function rawValue(token2) {
          return token2[1];
        };
        Writer.prototype.getConfigTags = function getConfigTags(config) {
          if (isArray2(config)) {
            return config;
          } else if (config && typeof config === "object") {
            return config.tags;
          } else {
            return void 0;
          }
        };
        Writer.prototype.getConfigEscape = function getConfigEscape(config) {
          if (config && typeof config === "object" && !isArray2(config)) {
            return config.escape;
          } else {
            return void 0;
          }
        };
        var mustache2 = {
          name: "mustache.js",
          version: "4.2.0",
          tags: ["{{", "}}"],
          clearCache: void 0,
          escape: void 0,
          parse: void 0,
          render: void 0,
          Scanner: void 0,
          Context: void 0,
          Writer: void 0,
          /**
           * Allows a user to override the default caching strategy, by providing an
           * object with set, get and clear methods. This can also be used to disable
           * the cache by setting it to the literal `undefined`.
           */
          set templateCache(cache) {
            defaultWriter.templateCache = cache;
          },
          /**
           * Gets the default or overridden caching object from the default writer.
           */
          get templateCache() {
            return defaultWriter.templateCache;
          }
        };
        var defaultWriter = new Writer();
        mustache2.clearCache = function clearCache() {
          return defaultWriter.clearCache();
        };
        mustache2.parse = function parse2(template, tags) {
          return defaultWriter.parse(template, tags);
        };
        mustache2.render = function render2(template, view, partials, config) {
          if (typeof template !== "string") {
            throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
          }
          return defaultWriter.render(template, view, partials, config);
        };
        mustache2.escape = escapeHtml;
        mustache2.Scanner = Scanner;
        mustache2.Context = Context2;
        mustache2.Writer = Writer;
        return mustache2;
      });
    })(mustache);
    const schema = {
      BadUTF16: {
        name: "BadUTF16",
        subtypes: [],
        props: {}
      },
      BadUTF8: {
        name: "BadUTF8",
        subtypes: [],
        props: {}
      },
      BalanceExceeded: {
        name: "BalanceExceeded",
        subtypes: [],
        props: {}
      },
      BreakpointTrap: {
        name: "BreakpointTrap",
        subtypes: [],
        props: {}
      },
      CacheError: {
        name: "CacheError",
        subtypes: [
          "ReadError",
          "WriteError",
          "DeserializationError",
          "SerializationError"
        ],
        props: {}
      },
      CallIndirectOOB: {
        name: "CallIndirectOOB",
        subtypes: [],
        props: {}
      },
      CannotAppendActionToJointPromise: {
        name: "CannotAppendActionToJointPromise",
        subtypes: [],
        props: {}
      },
      CannotReturnJointPromise: {
        name: "CannotReturnJointPromise",
        subtypes: [],
        props: {}
      },
      CodeDoesNotExist: {
        name: "CodeDoesNotExist",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      CompilationError: {
        name: "CompilationError",
        subtypes: [
          "CodeDoesNotExist",
          "PrepareError",
          "WasmerCompileError"
        ],
        props: {}
      },
      ContractSizeExceeded: {
        name: "ContractSizeExceeded",
        subtypes: [],
        props: {
          limit: "",
          size: ""
        }
      },
      Deprecated: {
        name: "Deprecated",
        subtypes: [],
        props: {
          method_name: ""
        }
      },
      Deserialization: {
        name: "Deserialization",
        subtypes: [],
        props: {}
      },
      DeserializationError: {
        name: "DeserializationError",
        subtypes: [],
        props: {}
      },
      EmptyMethodName: {
        name: "EmptyMethodName",
        subtypes: [],
        props: {}
      },
      FunctionCallError: {
        name: "FunctionCallError",
        subtypes: [
          "CompilationError",
          "LinkError",
          "MethodResolveError",
          "WasmTrap",
          "WasmUnknownError",
          "HostError",
          "EvmError"
        ],
        props: {}
      },
      GasExceeded: {
        name: "GasExceeded",
        subtypes: [],
        props: {}
      },
      GasInstrumentation: {
        name: "GasInstrumentation",
        subtypes: [],
        props: {}
      },
      GasLimitExceeded: {
        name: "GasLimitExceeded",
        subtypes: [],
        props: {}
      },
      GenericTrap: {
        name: "GenericTrap",
        subtypes: [],
        props: {}
      },
      GuestPanic: {
        name: "GuestPanic",
        subtypes: [],
        props: {
          panic_msg: ""
        }
      },
      HostError: {
        name: "HostError",
        subtypes: [
          "BadUTF16",
          "BadUTF8",
          "GasExceeded",
          "GasLimitExceeded",
          "BalanceExceeded",
          "EmptyMethodName",
          "GuestPanic",
          "IntegerOverflow",
          "InvalidPromiseIndex",
          "CannotAppendActionToJointPromise",
          "CannotReturnJointPromise",
          "InvalidPromiseResultIndex",
          "InvalidRegisterId",
          "IteratorWasInvalidated",
          "MemoryAccessViolation",
          "InvalidReceiptIndex",
          "InvalidIteratorIndex",
          "InvalidAccountId",
          "InvalidMethodName",
          "InvalidPublicKey",
          "ProhibitedInView",
          "NumberOfLogsExceeded",
          "KeyLengthExceeded",
          "ValueLengthExceeded",
          "TotalLogLengthExceeded",
          "NumberPromisesExceeded",
          "NumberInputDataDependenciesExceeded",
          "ReturnedValueLengthExceeded",
          "ContractSizeExceeded",
          "Deprecated"
        ],
        props: {}
      },
      IllegalArithmetic: {
        name: "IllegalArithmetic",
        subtypes: [],
        props: {}
      },
      IncorrectCallIndirectSignature: {
        name: "IncorrectCallIndirectSignature",
        subtypes: [],
        props: {}
      },
      Instantiate: {
        name: "Instantiate",
        subtypes: [],
        props: {}
      },
      IntegerOverflow: {
        name: "IntegerOverflow",
        subtypes: [],
        props: {}
      },
      InternalMemoryDeclared: {
        name: "InternalMemoryDeclared",
        subtypes: [],
        props: {}
      },
      InvalidAccountId: {
        name: "InvalidAccountId",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      InvalidIteratorIndex: {
        name: "InvalidIteratorIndex",
        subtypes: [],
        props: {
          iterator_index: ""
        }
      },
      InvalidMethodName: {
        name: "InvalidMethodName",
        subtypes: [],
        props: {}
      },
      InvalidPromiseIndex: {
        name: "InvalidPromiseIndex",
        subtypes: [],
        props: {
          promise_idx: ""
        }
      },
      InvalidPromiseResultIndex: {
        name: "InvalidPromiseResultIndex",
        subtypes: [],
        props: {
          result_idx: ""
        }
      },
      InvalidPublicKey: {
        name: "InvalidPublicKey",
        subtypes: [],
        props: {}
      },
      InvalidReceiptIndex: {
        name: "InvalidReceiptIndex",
        subtypes: [],
        props: {
          receipt_index: ""
        }
      },
      InvalidRegisterId: {
        name: "InvalidRegisterId",
        subtypes: [],
        props: {
          register_id: ""
        }
      },
      IteratorWasInvalidated: {
        name: "IteratorWasInvalidated",
        subtypes: [],
        props: {
          iterator_index: ""
        }
      },
      KeyLengthExceeded: {
        name: "KeyLengthExceeded",
        subtypes: [],
        props: {
          length: "",
          limit: ""
        }
      },
      LinkError: {
        name: "LinkError",
        subtypes: [],
        props: {
          msg: ""
        }
      },
      Memory: {
        name: "Memory",
        subtypes: [],
        props: {}
      },
      MemoryAccessViolation: {
        name: "MemoryAccessViolation",
        subtypes: [],
        props: {}
      },
      MemoryOutOfBounds: {
        name: "MemoryOutOfBounds",
        subtypes: [],
        props: {}
      },
      MethodEmptyName: {
        name: "MethodEmptyName",
        subtypes: [],
        props: {}
      },
      MethodInvalidSignature: {
        name: "MethodInvalidSignature",
        subtypes: [],
        props: {}
      },
      MethodNotFound: {
        name: "MethodNotFound",
        subtypes: [],
        props: {}
      },
      MethodResolveError: {
        name: "MethodResolveError",
        subtypes: [
          "MethodEmptyName",
          "MethodUTF8Error",
          "MethodNotFound",
          "MethodInvalidSignature"
        ],
        props: {}
      },
      MethodUTF8Error: {
        name: "MethodUTF8Error",
        subtypes: [],
        props: {}
      },
      MisalignedAtomicAccess: {
        name: "MisalignedAtomicAccess",
        subtypes: [],
        props: {}
      },
      NumberInputDataDependenciesExceeded: {
        name: "NumberInputDataDependenciesExceeded",
        subtypes: [],
        props: {
          limit: "",
          number_of_input_data_dependencies: ""
        }
      },
      NumberOfLogsExceeded: {
        name: "NumberOfLogsExceeded",
        subtypes: [],
        props: {
          limit: ""
        }
      },
      NumberPromisesExceeded: {
        name: "NumberPromisesExceeded",
        subtypes: [],
        props: {
          limit: "",
          number_of_promises: ""
        }
      },
      PrepareError: {
        name: "PrepareError",
        subtypes: [
          "Serialization",
          "Deserialization",
          "InternalMemoryDeclared",
          "GasInstrumentation",
          "StackHeightInstrumentation",
          "Instantiate",
          "Memory"
        ],
        props: {}
      },
      ProhibitedInView: {
        name: "ProhibitedInView",
        subtypes: [],
        props: {
          method_name: ""
        }
      },
      ReadError: {
        name: "ReadError",
        subtypes: [],
        props: {}
      },
      ReturnedValueLengthExceeded: {
        name: "ReturnedValueLengthExceeded",
        subtypes: [],
        props: {
          length: "",
          limit: ""
        }
      },
      Serialization: {
        name: "Serialization",
        subtypes: [],
        props: {}
      },
      SerializationError: {
        name: "SerializationError",
        subtypes: [],
        props: {
          hash: ""
        }
      },
      StackHeightInstrumentation: {
        name: "StackHeightInstrumentation",
        subtypes: [],
        props: {}
      },
      StackOverflow: {
        name: "StackOverflow",
        subtypes: [],
        props: {}
      },
      TotalLogLengthExceeded: {
        name: "TotalLogLengthExceeded",
        subtypes: [],
        props: {
          length: "",
          limit: ""
        }
      },
      Unreachable: {
        name: "Unreachable",
        subtypes: [],
        props: {}
      },
      ValueLengthExceeded: {
        name: "ValueLengthExceeded",
        subtypes: [],
        props: {
          length: "",
          limit: ""
        }
      },
      WasmTrap: {
        name: "WasmTrap",
        subtypes: [
          "Unreachable",
          "IncorrectCallIndirectSignature",
          "MemoryOutOfBounds",
          "CallIndirectOOB",
          "IllegalArithmetic",
          "MisalignedAtomicAccess",
          "BreakpointTrap",
          "StackOverflow",
          "GenericTrap"
        ],
        props: {}
      },
      WasmUnknownError: {
        name: "WasmUnknownError",
        subtypes: [],
        props: {}
      },
      WasmerCompileError: {
        name: "WasmerCompileError",
        subtypes: [],
        props: {
          msg: ""
        }
      },
      WriteError: {
        name: "WriteError",
        subtypes: [],
        props: {}
      },
      AccessKeyNotFound: {
        name: "AccessKeyNotFound",
        subtypes: [],
        props: {
          account_id: "",
          public_key: ""
        }
      },
      AccountAlreadyExists: {
        name: "AccountAlreadyExists",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      AccountDoesNotExist: {
        name: "AccountDoesNotExist",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      ActionError: {
        name: "ActionError",
        subtypes: [
          "AccountAlreadyExists",
          "AccountDoesNotExist",
          "CreateAccountOnlyByRegistrar",
          "CreateAccountNotAllowed",
          "ActorNoPermission",
          "DeleteKeyDoesNotExist",
          "AddKeyAlreadyExists",
          "DeleteAccountStaking",
          "LackBalanceForState",
          "TriesToUnstake",
          "TriesToStake",
          "InsufficientStake",
          "FunctionCallError",
          "NewReceiptValidationError",
          "OnlyImplicitAccountCreationAllowed"
        ],
        props: {
          index: ""
        }
      },
      ActionsValidationError: {
        name: "ActionsValidationError",
        subtypes: [
          "DeleteActionMustBeFinal",
          "TotalPrepaidGasExceeded",
          "TotalNumberOfActionsExceeded",
          "AddKeyMethodNamesNumberOfBytesExceeded",
          "AddKeyMethodNameLengthExceeded",
          "IntegerOverflow",
          "InvalidAccountId",
          "ContractSizeExceeded",
          "FunctionCallMethodNameLengthExceeded",
          "FunctionCallArgumentsLengthExceeded",
          "UnsuitableStakingKey",
          "FunctionCallZeroAttachedGas"
        ],
        props: {}
      },
      ActorNoPermission: {
        name: "ActorNoPermission",
        subtypes: [],
        props: {
          account_id: "",
          actor_id: ""
        }
      },
      AddKeyAlreadyExists: {
        name: "AddKeyAlreadyExists",
        subtypes: [],
        props: {
          account_id: "",
          public_key: ""
        }
      },
      AddKeyMethodNameLengthExceeded: {
        name: "AddKeyMethodNameLengthExceeded",
        subtypes: [],
        props: {
          length: "",
          limit: ""
        }
      },
      AddKeyMethodNamesNumberOfBytesExceeded: {
        name: "AddKeyMethodNamesNumberOfBytesExceeded",
        subtypes: [],
        props: {
          limit: "",
          total_number_of_bytes: ""
        }
      },
      BalanceMismatchError: {
        name: "BalanceMismatchError",
        subtypes: [],
        props: {
          final_accounts_balance: "",
          final_postponed_receipts_balance: "",
          incoming_receipts_balance: "",
          incoming_validator_rewards: "",
          initial_accounts_balance: "",
          initial_postponed_receipts_balance: "",
          new_delayed_receipts_balance: "",
          other_burnt_amount: "",
          outgoing_receipts_balance: "",
          processed_delayed_receipts_balance: "",
          slashed_burnt_amount: "",
          tx_burnt_amount: ""
        }
      },
      CostOverflow: {
        name: "CostOverflow",
        subtypes: [],
        props: {}
      },
      CreateAccountNotAllowed: {
        name: "CreateAccountNotAllowed",
        subtypes: [],
        props: {
          account_id: "",
          predecessor_id: ""
        }
      },
      CreateAccountOnlyByRegistrar: {
        name: "CreateAccountOnlyByRegistrar",
        subtypes: [],
        props: {
          account_id: "",
          predecessor_id: "",
          registrar_account_id: ""
        }
      },
      DeleteAccountStaking: {
        name: "DeleteAccountStaking",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      DeleteActionMustBeFinal: {
        name: "DeleteActionMustBeFinal",
        subtypes: [],
        props: {}
      },
      DeleteKeyDoesNotExist: {
        name: "DeleteKeyDoesNotExist",
        subtypes: [],
        props: {
          account_id: "",
          public_key: ""
        }
      },
      DepositWithFunctionCall: {
        name: "DepositWithFunctionCall",
        subtypes: [],
        props: {}
      },
      Expired: {
        name: "Expired",
        subtypes: [],
        props: {}
      },
      FunctionCallArgumentsLengthExceeded: {
        name: "FunctionCallArgumentsLengthExceeded",
        subtypes: [],
        props: {
          length: "",
          limit: ""
        }
      },
      FunctionCallMethodNameLengthExceeded: {
        name: "FunctionCallMethodNameLengthExceeded",
        subtypes: [],
        props: {
          length: "",
          limit: ""
        }
      },
      FunctionCallZeroAttachedGas: {
        name: "FunctionCallZeroAttachedGas",
        subtypes: [],
        props: {}
      },
      InsufficientStake: {
        name: "InsufficientStake",
        subtypes: [],
        props: {
          account_id: "",
          minimum_stake: "",
          stake: ""
        }
      },
      InvalidAccessKeyError: {
        name: "InvalidAccessKeyError",
        subtypes: [
          "AccessKeyNotFound",
          "ReceiverMismatch",
          "MethodNameMismatch",
          "RequiresFullAccess",
          "NotEnoughAllowance",
          "DepositWithFunctionCall"
        ],
        props: {}
      },
      InvalidChain: {
        name: "InvalidChain",
        subtypes: [],
        props: {}
      },
      InvalidDataReceiverId: {
        name: "InvalidDataReceiverId",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      InvalidNonce: {
        name: "InvalidNonce",
        subtypes: [],
        props: {
          ak_nonce: "",
          tx_nonce: ""
        }
      },
      InvalidPredecessorId: {
        name: "InvalidPredecessorId",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      InvalidReceiverId: {
        name: "InvalidReceiverId",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      InvalidSignature: {
        name: "InvalidSignature",
        subtypes: [],
        props: {}
      },
      InvalidSignerId: {
        name: "InvalidSignerId",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      InvalidTxError: {
        name: "InvalidTxError",
        subtypes: [
          "InvalidAccessKeyError",
          "InvalidSignerId",
          "SignerDoesNotExist",
          "InvalidNonce",
          "InvalidReceiverId",
          "InvalidSignature",
          "NotEnoughBalance",
          "LackBalanceForState",
          "CostOverflow",
          "InvalidChain",
          "Expired",
          "ActionsValidation"
        ],
        props: {}
      },
      LackBalanceForState: {
        name: "LackBalanceForState",
        subtypes: [],
        props: {
          account_id: "",
          amount: ""
        }
      },
      MethodNameMismatch: {
        name: "MethodNameMismatch",
        subtypes: [],
        props: {
          method_name: ""
        }
      },
      NotEnoughAllowance: {
        name: "NotEnoughAllowance",
        subtypes: [],
        props: {
          account_id: "",
          allowance: "",
          cost: "",
          public_key: ""
        }
      },
      NotEnoughBalance: {
        name: "NotEnoughBalance",
        subtypes: [],
        props: {
          balance: "",
          cost: "",
          signer_id: ""
        }
      },
      OnlyImplicitAccountCreationAllowed: {
        name: "OnlyImplicitAccountCreationAllowed",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      ReceiptValidationError: {
        name: "ReceiptValidationError",
        subtypes: [
          "InvalidPredecessorId",
          "InvalidReceiverId",
          "InvalidSignerId",
          "InvalidDataReceiverId",
          "ReturnedValueLengthExceeded",
          "NumberInputDataDependenciesExceeded",
          "ActionsValidation"
        ],
        props: {}
      },
      ReceiverMismatch: {
        name: "ReceiverMismatch",
        subtypes: [],
        props: {
          ak_receiver: "",
          tx_receiver: ""
        }
      },
      RequiresFullAccess: {
        name: "RequiresFullAccess",
        subtypes: [],
        props: {}
      },
      SignerDoesNotExist: {
        name: "SignerDoesNotExist",
        subtypes: [],
        props: {
          signer_id: ""
        }
      },
      TotalNumberOfActionsExceeded: {
        name: "TotalNumberOfActionsExceeded",
        subtypes: [],
        props: {
          limit: "",
          total_number_of_actions: ""
        }
      },
      TotalPrepaidGasExceeded: {
        name: "TotalPrepaidGasExceeded",
        subtypes: [],
        props: {
          limit: "",
          total_prepaid_gas: ""
        }
      },
      TriesToStake: {
        name: "TriesToStake",
        subtypes: [],
        props: {
          account_id: "",
          balance: "",
          locked: "",
          stake: ""
        }
      },
      TriesToUnstake: {
        name: "TriesToUnstake",
        subtypes: [],
        props: {
          account_id: ""
        }
      },
      TxExecutionError: {
        name: "TxExecutionError",
        subtypes: [
          "ActionError",
          "InvalidTxError"
        ],
        props: {}
      },
      UnsuitableStakingKey: {
        name: "UnsuitableStakingKey",
        subtypes: [],
        props: {
          public_key: ""
        }
      },
      Closed: {
        name: "Closed",
        subtypes: [],
        props: {}
      },
      "InternalError": {
        name: "InternalError",
        subtypes: [],
        props: {}
      },
      ServerError: {
        name: "ServerError",
        subtypes: [
          "TxExecutionError",
          "Timeout",
          "Closed",
          "InternalError"
        ],
        props: {}
      },
      Timeout: {
        name: "Timeout",
        subtypes: [],
        props: {}
      }
    };
    const require$$1 = {
      schema
    };
    const GasLimitExceeded = "Exceeded the maximum amount of gas allowed to burn per contract";
    const MethodEmptyName = "Method name is empty";
    const WasmerCompileError = "Wasmer compilation error: {{msg}}";
    const GuestPanic = "Smart contract panicked: {{panic_msg}}";
    const Memory = "Error creating Wasm memory";
    const GasExceeded = "Exceeded the prepaid gas";
    const MethodUTF8Error = "Method name is not valid UTF8 string";
    const BadUTF16 = "String encoding is bad UTF-16 sequence";
    const WasmTrap = "WebAssembly trap: {{msg}}";
    const GasInstrumentation = "Gas instrumentation failed or contract has denied instructions.";
    const InvalidPromiseIndex = "{{promise_idx}} does not correspond to existing promises";
    const InvalidPromiseResultIndex = "Accessed invalid promise result index: {{result_idx}}";
    const Deserialization = "Error happened while deserializing the module";
    const MethodNotFound = "Contract method is not found";
    const InvalidRegisterId = "Accessed invalid register id: {{register_id}}";
    const InvalidReceiptIndex = "VM Logic returned an invalid receipt index: {{receipt_index}}";
    const EmptyMethodName = "Method name is empty in contract call";
    const CannotReturnJointPromise = "Returning joint promise is currently prohibited";
    const StackHeightInstrumentation = "Stack instrumentation failed";
    const CodeDoesNotExist = "Cannot find contract code for account {{account_id}}";
    const MethodInvalidSignature = "Invalid method signature";
    const IntegerOverflow = "Integer overflow happened during contract execution";
    const MemoryAccessViolation = "MemoryAccessViolation";
    const InvalidIteratorIndex = "Iterator index {{iterator_index}} does not exist";
    const IteratorWasInvalidated = "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie";
    const InvalidAccountId = "VM Logic returned an invalid account id";
    const Serialization = "Error happened while serializing the module";
    const CannotAppendActionToJointPromise = "Actions can only be appended to non-joint promise.";
    const InternalMemoryDeclared = "Internal memory declaration has been found in the module";
    const Instantiate = "Error happened during instantiation";
    const ProhibitedInView = "{{method_name}} is not allowed in view calls";
    const InvalidMethodName = "VM Logic returned an invalid method name";
    const BadUTF8 = "String encoding is bad UTF-8 sequence";
    const BalanceExceeded = "Exceeded the account balance";
    const LinkError = "Wasm contract link error: {{msg}}";
    const InvalidPublicKey = "VM Logic provided an invalid public key";
    const ActorNoPermission = "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action";
    const LackBalanceForState = "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more";
    const ReceiverMismatch = "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.";
    const CostOverflow = "Transaction gas or balance cost is too high";
    const InvalidSignature = "Transaction is not signed with the given public key";
    const AccessKeyNotFound = `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`;
    const NotEnoughBalance = "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}";
    const NotEnoughAllowance = "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}";
    const Expired = "Transaction has expired";
    const DeleteAccountStaking = "Account {{account_id}} is staking and can not be deleted";
    const SignerDoesNotExist = "Signer {{signer_id}} does not exist";
    const TriesToStake = "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}";
    const AddKeyAlreadyExists = "The public key {{public_key}} is already used for an existing access key";
    const InvalidSigner = "Invalid signer account ID {{signer_id}} according to requirements";
    const CreateAccountNotAllowed = "The new account_id {{account_id}} can't be created by {{predecessor_id}}";
    const RequiresFullAccess = "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key";
    const TriesToUnstake = "Account {{account_id}} is not yet staked, but tried to unstake";
    const InvalidNonce = "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}";
    const AccountAlreadyExists = "Can't create a new account {{account_id}}, because it already exists";
    const InvalidChain = "Transaction parent block hash doesn't belong to the current chain";
    const AccountDoesNotExist = "Can't complete the action because account {{account_id}} doesn't exist";
    const MethodNameMismatch = "Transaction method name {{method_name}} isn't allowed by the access key";
    const DeleteAccountHasRent = "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent";
    const DeleteAccountHasEnoughBalance = "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage";
    const InvalidReceiver = "Invalid receiver account ID {{receiver_id}} according to requirements";
    const DeleteKeyDoesNotExist = "Account {{account_id}} tries to remove an access key that doesn't exist";
    const Timeout = "Timeout exceeded";
    const Closed = "Connection closed";
    const require$$2 = {
      GasLimitExceeded,
      MethodEmptyName,
      WasmerCompileError,
      GuestPanic,
      Memory,
      GasExceeded,
      MethodUTF8Error,
      BadUTF16,
      WasmTrap,
      GasInstrumentation,
      InvalidPromiseIndex,
      InvalidPromiseResultIndex,
      Deserialization,
      MethodNotFound,
      InvalidRegisterId,
      InvalidReceiptIndex,
      EmptyMethodName,
      CannotReturnJointPromise,
      StackHeightInstrumentation,
      CodeDoesNotExist,
      MethodInvalidSignature,
      IntegerOverflow,
      MemoryAccessViolation,
      InvalidIteratorIndex,
      IteratorWasInvalidated,
      InvalidAccountId,
      Serialization,
      CannotAppendActionToJointPromise,
      InternalMemoryDeclared,
      Instantiate,
      ProhibitedInView,
      InvalidMethodName,
      BadUTF8,
      BalanceExceeded,
      LinkError,
      InvalidPublicKey,
      ActorNoPermission,
      LackBalanceForState,
      ReceiverMismatch,
      CostOverflow,
      InvalidSignature,
      AccessKeyNotFound,
      NotEnoughBalance,
      NotEnoughAllowance,
      Expired,
      DeleteAccountStaking,
      SignerDoesNotExist,
      TriesToStake,
      AddKeyAlreadyExists,
      InvalidSigner,
      CreateAccountNotAllowed,
      RequiresFullAccess,
      TriesToUnstake,
      InvalidNonce,
      AccountAlreadyExists,
      InvalidChain,
      AccountDoesNotExist,
      MethodNameMismatch,
      DeleteAccountHasRent,
      DeleteAccountHasEnoughBalance,
      InvalidReceiver,
      DeleteKeyDoesNotExist,
      Timeout,
      Closed
    };
    var hasRequiredRpc_errors;
    function requireRpc_errors() {
      if (hasRequiredRpc_errors)
        return rpc_errors;
      hasRequiredRpc_errors = 1;
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(rpc_errors, "__esModule", { value: true });
      rpc_errors.formatError = rpc_errors.parseResultError = rpc_errors.parseRpcError = rpc_errors.ServerError = void 0;
      const mustache_1 = __importDefault2(mustacheExports);
      const rpc_error_schema_json_1 = __importDefault2(require$$1);
      const error_messages_json_1 = __importDefault2(require$$2);
      const common_index_1 = requireCommonIndex();
      const errors_1 = errors;
      const mustacheHelpers = {
        formatNear: () => (n2, render2) => common_index_1.utils.format.formatNearAmount(render2(n2))
      };
      class ServerError extends errors_1.TypedError {
      }
      rpc_errors.ServerError = ServerError;
      class ServerTransactionError extends ServerError {
      }
      function parseRpcError(errorObj) {
        const result = {};
        const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error = new ServerError(formatError(errorClassName, result), errorClassName);
        Object.assign(error, result);
        return error;
      }
      rpc_errors.parseRpcError = parseRpcError;
      function parseResultError(result) {
        const server_error = parseRpcError(result.status.Failure);
        const server_tx_error = new ServerTransactionError();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      rpc_errors.parseResultError = parseResultError;
      function formatError(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers));
        }
        return JSON.stringify(errorData);
      }
      rpc_errors.formatError = formatError;
      function walkSubtype(errorObj, schema2, result, typeName) {
        let error;
        let type2;
        let errorTypeName;
        for (const errorName in schema2) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject2(errorObj[errorName])) {
            error = errorObj[errorName];
            type2 = schema2[errorName];
            errorTypeName = errorName;
          } else if (isObject2(errorObj.kind) && isObject2(errorObj.kind[errorName])) {
            error = errorObj.kind[errorName];
            type2 = schema2[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error && type2) {
          for (const prop of Object.keys(type2.props)) {
            result[prop] = error[prop];
          }
          return walkSubtype(error, schema2, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function isObject2(n2) {
        return Object.prototype.toString.call(n2) === "[object Object]";
      }
      function isString2(n2) {
        return Object.prototype.toString.call(n2) === "[object String]";
      }
      return rpc_errors;
    }
    var hasRequiredJsonRpcProvider;
    function requireJsonRpcProvider() {
      if (hasRequiredJsonRpcProvider)
        return jsonRpcProvider;
      hasRequiredJsonRpcProvider = 1;
      (function(exports2) {
        var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __rest2 = commonjsGlobal && commonjsGlobal.__rest || function(s, e2) {
          var t2 = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
              t2[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
              if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
                t2[p2[i2]] = s[p2[i2]];
            }
          return t2;
        };
        var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.JsonRpcProvider = exports2.ErrorContext = exports2.TypedError = void 0;
        const provider_1 = provider;
        const web_1 = requireWeb();
        const errors_1 = errors;
        Object.defineProperty(exports2, "TypedError", { enumerable: true, get: function() {
          return errors_1.TypedError;
        } });
        Object.defineProperty(exports2, "ErrorContext", { enumerable: true, get: function() {
          return errors_1.ErrorContext;
        } });
        const borsh_1 = lib$5;
        const exponential_backoff_1 = __importDefault2(exponentialBackoff$1);
        const rpc_errors_1 = requireRpc_errors();
        const REQUEST_RETRY_NUMBER = 12;
        const REQUEST_RETRY_WAIT = 500;
        const REQUEST_RETRY_WAIT_BACKOFF = 1.5;
        let _nextId = 123;
        class JsonRpcProvider extends provider_1.Provider {
          /**
           * @param connectionInfo Connection info
           */
          constructor(connectionInfo) {
            super();
            this.connection = connectionInfo || { url: "" };
          }
          /**
           * Gets the RPC's status
           * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
           */
          status() {
            return __awaiter2(this, void 0, void 0, function* () {
              return this.sendJsonRpc("status", []);
            });
          }
          /**
           * Sends a signed transaction to the RPC and waits until transaction is fully complete
           * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
           *
           * @param signedTransaction The signed transaction being sent
           */
          sendTransaction(signedTransaction) {
            return __awaiter2(this, void 0, void 0, function* () {
              const bytes = signedTransaction.encode();
              return this.sendJsonRpc("broadcast_tx_commit", [Buffer.from(bytes).toString("base64")]);
            });
          }
          /**
           * Sends a signed transaction to the RPC and immediately returns transaction hash
           * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
           * @param signedTransaction The signed transaction being sent
           * @returns {Promise<FinalExecutionOutcome>}
           */
          sendTransactionAsync(signedTransaction) {
            return __awaiter2(this, void 0, void 0, function* () {
              const bytes = signedTransaction.encode();
              return this.sendJsonRpc("broadcast_tx_async", [Buffer.from(bytes).toString("base64")]);
            });
          }
          /**
           * Gets a transaction's status from the RPC
           * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
           *
           * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
           * @param accountId The NEAR account that signed the transaction
           */
          txStatus(txHash, accountId) {
            return __awaiter2(this, void 0, void 0, function* () {
              if (typeof txHash === "string") {
                return this.txStatusString(txHash, accountId);
              } else {
                return this.txStatusUint8Array(txHash, accountId);
              }
            });
          }
          txStatusUint8Array(txHash, accountId) {
            return __awaiter2(this, void 0, void 0, function* () {
              return this.sendJsonRpc("tx", [(0, borsh_1.baseEncode)(txHash), accountId]);
            });
          }
          txStatusString(txHash, accountId) {
            return __awaiter2(this, void 0, void 0, function* () {
              return this.sendJsonRpc("tx", [txHash, accountId]);
            });
          }
          /**
           * Gets a transaction's status from the RPC with receipts
           * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
           * @param txHash The hash of the transaction
           * @param accountId The NEAR account that signed the transaction
           * @returns {Promise<FinalExecutionOutcome>}
           */
          txStatusReceipts(txHash, accountId) {
            return __awaiter2(this, void 0, void 0, function* () {
              if (typeof txHash === "string") {
                return this.sendJsonRpc("EXPERIMENTAL_tx_status", [txHash, accountId]);
              } else {
                return this.sendJsonRpc("EXPERIMENTAL_tx_status", [(0, borsh_1.baseEncode)(txHash), accountId]);
              }
            });
          }
          /**
           * Query the RPC by passing an {@link providers/provider!RpcQueryRequest}
           * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
           *
           * @typeParam T the shape of the returned query response
           */
          query(...args) {
            return __awaiter2(this, void 0, void 0, function* () {
              let result;
              if (args.length === 1) {
                const _a = args[0], { block_id, blockId } = _a, otherParams = __rest2(_a, ["block_id", "blockId"]);
                result = yield this.sendJsonRpc("query", Object.assign(Object.assign({}, otherParams), { block_id: block_id || blockId }));
              } else {
                const [path, data] = args;
                result = yield this.sendJsonRpc("query", [path, data]);
              }
              if (result && result.error) {
                throw new errors_1.TypedError(`Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`, result.error.name);
              }
              return result;
            });
          }
          /**
           * Query for block info from the RPC
           * pass block_id OR finality as blockQuery, not both
           * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
           *
           * @param blockQuery {@link providers/provider!BlockReference} (passing a {@link providers/provider!BlockId} is deprecated)
           */
          block(blockQuery) {
            return __awaiter2(this, void 0, void 0, function* () {
              const { finality } = blockQuery;
              const { blockId } = blockQuery;
              return this.sendJsonRpc("block", { block_id: blockId, finality });
            });
          }
          /**
           * Query changes in block from the RPC
           * pass block_id OR finality as blockQuery, not both
           * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
           */
          blockChanges(blockQuery) {
            return __awaiter2(this, void 0, void 0, function* () {
              const { finality } = blockQuery;
              const { blockId } = blockQuery;
              return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: blockId, finality });
            });
          }
          /**
           * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
           * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
           *
           * @param chunkId Hash of a chunk ID or shard ID
           */
          chunk(chunkId) {
            return __awaiter2(this, void 0, void 0, function* () {
              return this.sendJsonRpc("chunk", [chunkId]);
            });
          }
          /**
           * Query validators of the epoch defined by the given block id.
           * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
           *
           * @param blockId Block hash or height, or null for latest.
           */
          validators(blockId) {
            return __awaiter2(this, void 0, void 0, function* () {
              return this.sendJsonRpc("validators", [blockId]);
            });
          }
          /**
           * Gets the protocol config at a block from RPC
           *
           * @param blockReference specifies the block to get the protocol config for
           */
          experimental_protocolConfig(blockReference) {
            return __awaiter2(this, void 0, void 0, function* () {
              const _a = blockReference, { blockId } = _a, otherParams = __rest2(_a, ["blockId"]);
              return yield this.sendJsonRpc("EXPERIMENTAL_protocol_config", Object.assign(Object.assign({}, otherParams), { block_id: blockId }));
            });
          }
          /**
           * Gets a light client execution proof for verifying execution outcomes
           * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
           */
          lightClientProof(request) {
            return __awaiter2(this, void 0, void 0, function* () {
              return yield this.sendJsonRpc("EXPERIMENTAL_light_client_proof", request);
            });
          }
          /**
           * Gets access key changes for a given array of accountIds
           * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
           * @returns {Promise<ChangeResult>}
           */
          accessKeyChanges(accountIdArray, blockQuery) {
            return __awaiter2(this, void 0, void 0, function* () {
              const { finality } = blockQuery;
              const { blockId } = blockQuery;
              return this.sendJsonRpc("EXPERIMENTAL_changes", {
                changes_type: "all_access_key_changes",
                account_ids: accountIdArray,
                block_id: blockId,
                finality
              });
            });
          }
          /**
           * Gets single access key changes for a given array of access keys
           * pass block_id OR finality as blockQuery, not both
           * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
           * @returns {Promise<ChangeResult>}
           */
          singleAccessKeyChanges(accessKeyArray, blockQuery) {
            return __awaiter2(this, void 0, void 0, function* () {
              const { finality } = blockQuery;
              const { blockId } = blockQuery;
              return this.sendJsonRpc("EXPERIMENTAL_changes", {
                changes_type: "single_access_key_changes",
                keys: accessKeyArray,
                block_id: blockId,
                finality
              });
            });
          }
          /**
           * Gets account changes for a given array of accountIds
           * pass block_id OR finality as blockQuery, not both
           * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
           * @returns {Promise<ChangeResult>}
           */
          accountChanges(accountIdArray, blockQuery) {
            return __awaiter2(this, void 0, void 0, function* () {
              const { finality } = blockQuery;
              const { blockId } = blockQuery;
              return this.sendJsonRpc("EXPERIMENTAL_changes", {
                changes_type: "account_changes",
                account_ids: accountIdArray,
                block_id: blockId,
                finality
              });
            });
          }
          /**
           * Gets contract state changes for a given array of accountIds
           * pass block_id OR finality as blockQuery, not both
           * Note: If you pass a keyPrefix it must be base64 encoded
           * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
           * @returns {Promise<ChangeResult>}
           */
          contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
            return __awaiter2(this, void 0, void 0, function* () {
              const { finality } = blockQuery;
              const { blockId } = blockQuery;
              return this.sendJsonRpc("EXPERIMENTAL_changes", {
                changes_type: "data_changes",
                account_ids: accountIdArray,
                key_prefix_base64: keyPrefix,
                block_id: blockId,
                finality
              });
            });
          }
          /**
           * Gets contract code changes for a given array of accountIds
           * pass block_id OR finality as blockQuery, not both
           * Note: Change is returned in a base64 encoded WASM file
           * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
           * @returns {Promise<ChangeResult>}
           */
          contractCodeChanges(accountIdArray, blockQuery) {
            return __awaiter2(this, void 0, void 0, function* () {
              const { finality } = blockQuery;
              const { blockId } = blockQuery;
              return this.sendJsonRpc("EXPERIMENTAL_changes", {
                changes_type: "contract_code_changes",
                account_ids: accountIdArray,
                block_id: blockId,
                finality
              });
            });
          }
          /**
           * Returns gas price for a specific block_height or block_hash.
           * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
           *
           * @param blockId Block hash or height, or null for latest.
           */
          gasPrice(blockId) {
            return __awaiter2(this, void 0, void 0, function* () {
              return yield this.sendJsonRpc("gas_price", [blockId]);
            });
          }
          /**
           * Directly call the RPC specifying the method and params
           *
           * @param method RPC method
           * @param params Parameters to the method
           */
          sendJsonRpc(method2, params) {
            return __awaiter2(this, void 0, void 0, function* () {
              const response = yield (0, exponential_backoff_1.default)(REQUEST_RETRY_WAIT, REQUEST_RETRY_NUMBER, REQUEST_RETRY_WAIT_BACKOFF, () => __awaiter2(this, void 0, void 0, function* () {
                try {
                  const request = {
                    method: method2,
                    params,
                    id: _nextId++,
                    jsonrpc: "2.0"
                  };
                  const response2 = yield (0, web_1.fetchJson)(this.connection, JSON.stringify(request));
                  if (response2.error) {
                    if (typeof response2.error.data === "object") {
                      if (typeof response2.error.data.error_message === "string" && typeof response2.error.data.error_type === "string") {
                        throw new errors_1.TypedError(response2.error.data.error_message, response2.error.data.error_type);
                      }
                      throw (0, rpc_errors_1.parseRpcError)(response2.error.data);
                    } else {
                      const errorMessage = `[${response2.error.code}] ${response2.error.message}: ${response2.error.data}`;
                      if (response2.error.data === "Timeout" || errorMessage.includes("Timeout error") || errorMessage.includes("query has timed out")) {
                        throw new errors_1.TypedError(errorMessage, "TimeoutError");
                      }
                      throw new errors_1.TypedError(errorMessage, response2.error.name);
                    }
                  }
                  return response2;
                } catch (error) {
                  if (error.type === "TimeoutError") {
                    if (!process.env["NEAR_NO_LOGS"]) {
                      console.warn(`Retrying request to ${method2} as it has timed out`, params);
                    }
                    return null;
                  }
                  throw error;
                }
              }));
              const { result } = response;
              if (typeof result === "undefined") {
                throw new errors_1.TypedError(`Exceeded ${REQUEST_RETRY_NUMBER} attempts for request to ${method2}.`, "RetriesExceeded");
              }
              return result;
            });
          }
        }
        exports2.JsonRpcProvider = JsonRpcProvider;
      })(jsonRpcProvider);
      return jsonRpcProvider;
    }
    var hasRequiredProviders;
    function requireProviders() {
      if (hasRequiredProviders)
        return providers;
      hasRequiredProviders = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.ErrorContext = exports2.TypedError = exports2.getTransactionLastResult = exports2.FinalExecutionStatusBasic = exports2.JsonRpcProvider = exports2.Provider = void 0;
        const provider_1 = provider;
        Object.defineProperty(exports2, "Provider", { enumerable: true, get: function() {
          return provider_1.Provider;
        } });
        Object.defineProperty(exports2, "getTransactionLastResult", { enumerable: true, get: function() {
          return provider_1.getTransactionLastResult;
        } });
        Object.defineProperty(exports2, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
          return provider_1.FinalExecutionStatusBasic;
        } });
        const json_rpc_provider_1 = requireJsonRpcProvider();
        Object.defineProperty(exports2, "JsonRpcProvider", { enumerable: true, get: function() {
          return json_rpc_provider_1.JsonRpcProvider;
        } });
        Object.defineProperty(exports2, "TypedError", { enumerable: true, get: function() {
          return json_rpc_provider_1.TypedError;
        } });
        Object.defineProperty(exports2, "ErrorContext", { enumerable: true, get: function() {
          return json_rpc_provider_1.ErrorContext;
        } });
      })(providers);
      return providers;
    }
    var utils = {};
    var format$2 = {};
    (function(exports2) {
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseNearAmount = exports2.formatNearAmount = exports2.NEAR_NOMINATION = exports2.NEAR_NOMINATION_EXP = void 0;
      const bn_js_12 = __importDefault2(bnExports);
      exports2.NEAR_NOMINATION_EXP = 24;
      exports2.NEAR_NOMINATION = new bn_js_12.default("10", 10).pow(new bn_js_12.default(exports2.NEAR_NOMINATION_EXP, 10));
      const ROUNDING_OFFSETS = [];
      const BN10 = new bn_js_12.default(10);
      for (let i2 = 0, offset = new bn_js_12.default(5); i2 < exports2.NEAR_NOMINATION_EXP; i2++, offset = offset.mul(BN10)) {
        ROUNDING_OFFSETS[i2] = offset;
      }
      function formatNearAmount(balance, fracDigits = exports2.NEAR_NOMINATION_EXP) {
        const balanceBN = new bn_js_12.default(balance, 10);
        if (fracDigits !== exports2.NEAR_NOMINATION_EXP) {
          const roundingExp = exports2.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN.iadd(ROUNDING_OFFSETS[roundingExp]);
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports2.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports2.NEAR_NOMINATION_EXP).padStart(exports2.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
      }
      exports2.formatNearAmount = formatNearAmount;
      function parseNearAmount(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount(amt);
        const split = amt.split(".");
        const wholePart = split[0];
        const fracPart = split[1] || "";
        if (split.length > 2 || fracPart.length > exports2.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes(wholePart + fracPart.padEnd(exports2.NEAR_NOMINATION_EXP, "0"));
      }
      exports2.parseNearAmount = parseNearAmount;
      function cleanupAmount(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas(value) {
        const pattern2 = /(-?\d+)(\d{3})/;
        while (pattern2.test(value)) {
          value = value.replace(pattern2, "$1,$2");
        }
        return value;
      }
    })(format$2);
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils)
        return utils;
      hasRequiredUtils = 1;
      (function(exports2) {
        var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
          if (k22 === void 0)
            k22 = k2;
          var desc = Object.getOwnPropertyDescriptor(m2, k2);
          if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m2[k2];
            } };
          }
          Object.defineProperty(o, k22, desc);
        } : function(o, m2, k2, k22) {
          if (k22 === void 0)
            k22 = k2;
          o[k22] = m2[k2];
        });
        var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
          Object.defineProperty(o, "default", { enumerable: true, value: v2 });
        } : function(o, v2) {
          o["default"] = v2;
        });
        var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k2 in mod)
              if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
                __createBinding2(result, mod, k2);
          }
          __setModuleDefault2(result, mod);
          return result;
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.logWarning = exports2.rpc_errors = exports2.KeyPairEd25519 = exports2.KeyPair = exports2.PublicKey = exports2.format = exports2.enums = exports2.web = exports2.serialize = exports2.key_pair = void 0;
        const key_pair$1 = __importStar2(key_pair);
        exports2.key_pair = key_pair$1;
        const serialize2 = __importStar2(serialize$2);
        exports2.serialize = serialize2;
        const web2 = __importStar2(requireWeb());
        exports2.web = web2;
        const enums$1 = __importStar2(enums);
        exports2.enums = enums$1;
        const format2 = __importStar2(format$2);
        exports2.format = format2;
        const rpc_errors2 = __importStar2(requireRpc_errors());
        exports2.rpc_errors = rpc_errors2;
        const key_pair_12 = key_pair;
        Object.defineProperty(exports2, "PublicKey", { enumerable: true, get: function() {
          return key_pair_12.PublicKey;
        } });
        Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
          return key_pair_12.KeyPair;
        } });
        Object.defineProperty(exports2, "KeyPairEd25519", { enumerable: true, get: function() {
          return key_pair_12.KeyPairEd25519;
        } });
        const errors_1 = errors;
        Object.defineProperty(exports2, "logWarning", { enumerable: true, get: function() {
          return errors_1.logWarning;
        } });
      })(utils);
      return utils;
    }
    var transaction = {};
    var sha256Exports = {};
    var sha256 = {
      get exports() {
        return sha256Exports;
      },
      set exports(v2) {
        sha256Exports = v2;
      }
    };
    /**
     * [js-sha256]{@link https://github.com/emn178/js-sha256}
     *
     * @version 0.9.0
     * @author Chen, Yi-Cyuan [emn178@gmail.com]
     * @copyright Chen, Yi-Cyuan 2014-2017
     * @license MIT
     */
    (function(module) {
      (function() {
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = commonjsGlobal;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && true && module.exports;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is2242) {
          return function(message) {
            return new Sha256(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is2242) {
          var method2 = createOutputMethod("hex", is2242);
          if (NODE_JS) {
            method2 = nodeWrap(method2, is2242);
          }
          method2.create = function() {
            return new Sha256(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
            var type2 = OUTPUT_TYPES[i2];
            method2[type2] = createOutputMethod(type2, is2242);
          }
          return method2;
        };
        var nodeWrap = function(method, is224) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var algorithm = is224 ? "sha224" : "sha256";
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha256(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is2242) {
          var method2 = createHmacOutputMethod("hex", is2242);
          method2.create = function(key) {
            return new HmacSha256(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
            var type2 = OUTPUT_TYPES[i2];
            method2[type2] = createHmacOutputMethod(type2, is2242);
          }
          return method2;
        };
        function Sha256(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type2 = typeof message;
          if (type2 !== "string") {
            if (type2 === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code2, index2 = 0, i2, length2 = message.length, blocks2 = this.blocks;
          while (index2 < length2) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i2 = this.start; index2 < length2 && i2 < 64; ++index2) {
                blocks2[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
              }
            } else {
              for (i2 = this.start; index2 < length2 && i2 < 64; ++index2) {
                code2 = message.charCodeAt(index2);
                if (code2 < 128) {
                  blocks2[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
                } else if (code2 < 2048) {
                  blocks2[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
                } else if (code2 < 55296 || code2 >= 57344) {
                  blocks2[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
                } else {
                  code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                  blocks2[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
                }
              }
            }
            this.lastByteIndex = i2;
            this.bytes += i2 - this.start;
            if (i2 >= 64) {
              this.block = blocks2[16];
              this.start = i2 - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i2;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i2 = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i2 >> 2] |= EXTRA[i2 & 3];
          this.block = blocks2[16];
          if (i2 >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b2 = this.h1, c2 = this.h2, d2 = this.h3, e2 = this.h4, f2 = this.h5, g2 = this.h6, h2 = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch2, ab2, da2, cd2, bc2;
          for (j = 16; j < 64; ++j) {
            t1 = blocks2[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
          }
          bc2 = b2 & c2;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab2 = 300032;
                t1 = blocks2[0] - 1413257819;
                h2 = t1 - 150054599 << 0;
                d2 = t1 + 24177077 << 0;
              } else {
                ab2 = 704751109;
                t1 = blocks2[0] - 210244248;
                h2 = t1 - 1521486534 << 0;
                d2 = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
              ab2 = a & b2;
              maj = ab2 ^ a & c2 ^ bc2;
              ch2 = e2 & f2 ^ ~e2 & g2;
              t1 = h2 + s1 + ch2 + K[j] + blocks2[j];
              t2 = s0 + maj;
              h2 = d2 + t1 << 0;
              d2 = t1 + t2 << 0;
            }
            s0 = (d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10);
            s1 = (h2 >>> 6 | h2 << 26) ^ (h2 >>> 11 | h2 << 21) ^ (h2 >>> 25 | h2 << 7);
            da2 = d2 & a;
            maj = da2 ^ d2 & b2 ^ ab2;
            ch2 = h2 & e2 ^ ~h2 & f2;
            t1 = g2 + s1 + ch2 + K[j + 1] + blocks2[j + 1];
            t2 = s0 + maj;
            g2 = c2 + t1 << 0;
            c2 = t1 + t2 << 0;
            s0 = (c2 >>> 2 | c2 << 30) ^ (c2 >>> 13 | c2 << 19) ^ (c2 >>> 22 | c2 << 10);
            s1 = (g2 >>> 6 | g2 << 26) ^ (g2 >>> 11 | g2 << 21) ^ (g2 >>> 25 | g2 << 7);
            cd2 = c2 & d2;
            maj = cd2 ^ c2 & a ^ da2;
            ch2 = g2 & h2 ^ ~g2 & e2;
            t1 = f2 + s1 + ch2 + K[j + 2] + blocks2[j + 2];
            t2 = s0 + maj;
            f2 = b2 + t1 << 0;
            b2 = t1 + t2 << 0;
            s0 = (b2 >>> 2 | b2 << 30) ^ (b2 >>> 13 | b2 << 19) ^ (b2 >>> 22 | b2 << 10);
            s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
            bc2 = b2 & c2;
            maj = bc2 ^ b2 & d2 ^ cd2;
            ch2 = f2 & g2 ^ ~f2 & h2;
            t1 = e2 + s1 + ch2 + K[j + 3] + blocks2[j + 3];
            t2 = s0 + maj;
            e2 = a + t1 << 0;
            a = t1 + t2 << 0;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b2 << 0;
          this.h2 = this.h2 + c2 << 0;
          this.h3 = this.h3 + d2 << 0;
          this.h4 = this.h4 + e2 << 0;
          this.h5 = this.h5 + f2 << 0;
          this.h6 = this.h6 + g2 << 0;
          this.h7 = this.h7 + h2 << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255,
            h5 >> 24 & 255,
            h5 >> 16 & 255,
            h5 >> 8 & 255,
            h5 & 255,
            h6 >> 24 & 255,
            h6 >> 16 & 255,
            h6 >> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer2 = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer2);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer2;
        };
        function HmacSha256(key, is2242, sharedMemory) {
          var i2, type2 = typeof key;
          if (type2 === "string") {
            var bytes = [], length2 = key.length, index2 = 0, code2;
            for (i2 = 0; i2 < length2; ++i2) {
              code2 = key.charCodeAt(i2);
              if (code2 < 128) {
                bytes[index2++] = code2;
              } else if (code2 < 2048) {
                bytes[index2++] = 192 | code2 >> 6;
                bytes[index2++] = 128 | code2 & 63;
              } else if (code2 < 55296 || code2 >= 57344) {
                bytes[index2++] = 224 | code2 >> 12;
                bytes[index2++] = 128 | code2 >> 6 & 63;
                bytes[index2++] = 128 | code2 & 63;
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i2) & 1023);
                bytes[index2++] = 240 | code2 >> 18;
                bytes[index2++] = 128 | code2 >> 12 & 63;
                bytes[index2++] = 128 | code2 >> 6 & 63;
                bytes[index2++] = 128 | code2 & 63;
              }
            }
            key = bytes;
          } else {
            if (type2 === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i2 = 0; i2 < 64; ++i2) {
            var b2 = key[i2] || 0;
            oKeyPad[i2] = 92 ^ b2;
            iKeyPad[i2] = 54 ^ b2;
          }
          Sha256.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(true);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.sha256 = exports.sha256;
          root.sha224 = exports.sha224;
        }
      })();
    })(sha256);
    (function(exports2) {
      var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.signTransaction = exports2.createTransaction = exports2.SCHEMA = exports2.Action = exports2.SignedTransaction = exports2.Transaction = exports2.Signature = exports2.deleteAccount = exports2.deleteKey = exports2.addKey = exports2.stake = exports2.transfer = exports2.functionCall = exports2.stringifyJsonOrBytes = exports2.deployContract = exports2.createAccount = exports2.DeleteAccount = exports2.DeleteKey = exports2.AddKey = exports2.Stake = exports2.Transfer = exports2.FunctionCall = exports2.DeployContract = exports2.CreateAccount = exports2.IAction = exports2.functionCallAccessKey = exports2.fullAccessKey = exports2.AccessKey = exports2.AccessKeyPermission = exports2.FullAccessPermission = exports2.FunctionCallPermission = void 0;
      const js_sha256_12 = __importDefault2(sha256Exports);
      const enums_1 = enums;
      const borsh_1 = lib$5;
      const key_pair_12 = key_pair;
      class FunctionCallPermission extends enums_1.Assignable {
      }
      exports2.FunctionCallPermission = FunctionCallPermission;
      class FullAccessPermission extends enums_1.Assignable {
      }
      exports2.FullAccessPermission = FullAccessPermission;
      class AccessKeyPermission extends enums_1.Enum {
      }
      exports2.AccessKeyPermission = AccessKeyPermission;
      class AccessKey extends enums_1.Assignable {
      }
      exports2.AccessKey = AccessKey;
      function fullAccessKey() {
        return new AccessKey({ permission: new AccessKeyPermission({ fullAccess: new FullAccessPermission({}) }) });
      }
      exports2.fullAccessKey = fullAccessKey;
      function functionCallAccessKey(receiverId, methodNames, allowance) {
        return new AccessKey({ permission: new AccessKeyPermission({ functionCall: new FunctionCallPermission({ receiverId, allowance, methodNames }) }) });
      }
      exports2.functionCallAccessKey = functionCallAccessKey;
      class IAction extends enums_1.Assignable {
      }
      exports2.IAction = IAction;
      class CreateAccount extends IAction {
      }
      exports2.CreateAccount = CreateAccount;
      class DeployContract extends IAction {
      }
      exports2.DeployContract = DeployContract;
      class FunctionCall extends IAction {
      }
      exports2.FunctionCall = FunctionCall;
      class Transfer extends IAction {
      }
      exports2.Transfer = Transfer;
      class Stake extends IAction {
      }
      exports2.Stake = Stake;
      class AddKey extends IAction {
      }
      exports2.AddKey = AddKey;
      class DeleteKey extends IAction {
      }
      exports2.DeleteKey = DeleteKey;
      class DeleteAccount extends IAction {
      }
      exports2.DeleteAccount = DeleteAccount;
      function createAccount() {
        return new Action({ createAccount: new CreateAccount({}) });
      }
      exports2.createAccount = createAccount;
      function deployContract(code2) {
        return new Action({ deployContract: new DeployContract({ code: code2 }) });
      }
      exports2.deployContract = deployContract;
      function stringifyJsonOrBytes(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        const serializedArgs = isUint8Array ? args : Buffer.from(JSON.stringify(args));
        return serializedArgs;
      }
      exports2.stringifyJsonOrBytes = stringifyJsonOrBytes;
      function functionCall(methodName, args, gas, deposit, stringify2 = stringifyJsonOrBytes, jsContract = false) {
        if (jsContract) {
          return new Action({ functionCall: new FunctionCall({ methodName, args, gas, deposit }) });
        }
        return new Action({ functionCall: new FunctionCall({ methodName, args: stringify2(args), gas, deposit }) });
      }
      exports2.functionCall = functionCall;
      function transfer(deposit) {
        return new Action({ transfer: new Transfer({ deposit }) });
      }
      exports2.transfer = transfer;
      function stake(stake2, publicKey) {
        return new Action({ stake: new Stake({ stake: stake2, publicKey }) });
      }
      exports2.stake = stake;
      function addKey(publicKey, accessKey) {
        return new Action({ addKey: new AddKey({ publicKey, accessKey }) });
      }
      exports2.addKey = addKey;
      function deleteKey(publicKey) {
        return new Action({ deleteKey: new DeleteKey({ publicKey }) });
      }
      exports2.deleteKey = deleteKey;
      function deleteAccount(beneficiaryId) {
        return new Action({ deleteAccount: new DeleteAccount({ beneficiaryId }) });
      }
      exports2.deleteAccount = deleteAccount;
      class Signature extends enums_1.Assignable {
      }
      exports2.Signature = Signature;
      class Transaction extends enums_1.Assignable {
        encode() {
          return (0, borsh_1.serialize)(exports2.SCHEMA, this);
        }
        static decode(bytes) {
          return (0, borsh_1.deserialize)(exports2.SCHEMA, Transaction, bytes);
        }
      }
      exports2.Transaction = Transaction;
      class SignedTransaction extends enums_1.Assignable {
        encode() {
          return (0, borsh_1.serialize)(exports2.SCHEMA, this);
        }
        static decode(bytes) {
          return (0, borsh_1.deserialize)(exports2.SCHEMA, SignedTransaction, bytes);
        }
      }
      exports2.SignedTransaction = SignedTransaction;
      class Action extends enums_1.Enum {
      }
      exports2.Action = Action;
      exports2.SCHEMA = /* @__PURE__ */ new Map([
        [Signature, { kind: "struct", fields: [
          ["keyType", "u8"],
          ["data", [64]]
        ] }],
        [SignedTransaction, { kind: "struct", fields: [
          ["transaction", Transaction],
          ["signature", Signature]
        ] }],
        [Transaction, { kind: "struct", fields: [
          ["signerId", "string"],
          ["publicKey", key_pair_12.PublicKey],
          ["nonce", "u64"],
          ["receiverId", "string"],
          ["blockHash", [32]],
          ["actions", [Action]]
        ] }],
        [key_pair_12.PublicKey, { kind: "struct", fields: [
          ["keyType", "u8"],
          ["data", [32]]
        ] }],
        [AccessKey, { kind: "struct", fields: [
          ["nonce", "u64"],
          ["permission", AccessKeyPermission]
        ] }],
        [AccessKeyPermission, { kind: "enum", field: "enum", values: [
          ["functionCall", FunctionCallPermission],
          ["fullAccess", FullAccessPermission]
        ] }],
        [FunctionCallPermission, { kind: "struct", fields: [
          ["allowance", { kind: "option", type: "u128" }],
          ["receiverId", "string"],
          ["methodNames", ["string"]]
        ] }],
        [FullAccessPermission, { kind: "struct", fields: [] }],
        [Action, { kind: "enum", field: "enum", values: [
          ["createAccount", CreateAccount],
          ["deployContract", DeployContract],
          ["functionCall", FunctionCall],
          ["transfer", Transfer],
          ["stake", Stake],
          ["addKey", AddKey],
          ["deleteKey", DeleteKey],
          ["deleteAccount", DeleteAccount]
        ] }],
        [CreateAccount, { kind: "struct", fields: [] }],
        [DeployContract, { kind: "struct", fields: [
          ["code", ["u8"]]
        ] }],
        [FunctionCall, { kind: "struct", fields: [
          ["methodName", "string"],
          ["args", ["u8"]],
          ["gas", "u64"],
          ["deposit", "u128"]
        ] }],
        [Transfer, { kind: "struct", fields: [
          ["deposit", "u128"]
        ] }],
        [Stake, { kind: "struct", fields: [
          ["stake", "u128"],
          ["publicKey", key_pair_12.PublicKey]
        ] }],
        [AddKey, { kind: "struct", fields: [
          ["publicKey", key_pair_12.PublicKey],
          ["accessKey", AccessKey]
        ] }],
        [DeleteKey, { kind: "struct", fields: [
          ["publicKey", key_pair_12.PublicKey]
        ] }],
        [DeleteAccount, { kind: "struct", fields: [
          ["beneficiaryId", "string"]
        ] }]
      ]);
      function createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {
        return new Transaction({ signerId, publicKey, nonce, receiverId, actions, blockHash });
      }
      exports2.createTransaction = createTransaction;
      function signTransactionObject(transaction2, signer2, accountId, networkId) {
        return __awaiter2(this, void 0, void 0, function* () {
          const message = (0, borsh_1.serialize)(exports2.SCHEMA, transaction2);
          const hash = new Uint8Array(js_sha256_12.default.sha256.array(message));
          const signature = yield signer2.signMessage(message, accountId, networkId);
          const signedTx = new SignedTransaction({
            transaction: transaction2,
            signature: new Signature({ keyType: transaction2.publicKey.keyType, data: signature.signature })
          });
          return [hash, signedTx];
        });
      }
      function signTransaction(...args) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (args[0].constructor === Transaction) {
            const [transaction2, signer2, accountId, networkId] = args;
            return signTransactionObject(transaction2, signer2, accountId, networkId);
          } else {
            const [receiverId, nonce, actions, blockHash, signer2, accountId, networkId] = args;
            const publicKey = yield signer2.getPublicKey(accountId, networkId);
            const transaction2 = createTransaction(accountId, publicKey, receiverId, nonce, actions, blockHash);
            return signTransactionObject(transaction2, signer2, accountId, networkId);
          }
        });
      }
      exports2.signTransaction = signTransaction;
    })(transaction);
    var validators$1 = {};
    /*!
     * depd
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    var browser = depd;
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate(message) {
      }
      deprecate._file = void 0;
      deprecate._ignored = true;
      deprecate._namespace = namespace;
      deprecate._traced = false;
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
    var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(validators$1, "__esModule", { value: true });
    validators$1.diffEpochValidators = validators$1.findSeatPrice = void 0;
    const bn_js_1$1 = __importDefault$2(bnExports);
    const depd_1 = __importDefault$2(browser);
    function findSeatPrice(validators2, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
      if (protocolVersion && protocolVersion < 49) {
        return findSeatPriceForProtocolBefore49(validators2, maxNumberOfSeats);
      }
      if (!minimumStakeRatio) {
        const deprecate = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
        deprecate("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
        minimumStakeRatio = [1, 6250];
      }
      return findSeatPriceForProtocolAfter49(validators2, maxNumberOfSeats, minimumStakeRatio);
    }
    validators$1.findSeatPrice = findSeatPrice;
    function findSeatPriceForProtocolBefore49(validators2, numSeats) {
      const stakes = validators2.map((v2) => new bn_js_1$1.default(v2.stake, 10)).sort((a, b2) => a.cmp(b2));
      const num = new bn_js_1$1.default(numSeats);
      const stakesSum = stakes.reduce((a, b2) => a.add(b2));
      if (stakesSum.lt(num)) {
        throw new Error("Stakes are below seats");
      }
      let left = new bn_js_1$1.default(1), right = stakesSum.add(new bn_js_1$1.default(1));
      while (!left.eq(right.sub(new bn_js_1$1.default(1)))) {
        const mid = left.add(right).div(new bn_js_1$1.default(2));
        let found = false;
        let currentSum = new bn_js_1$1.default(0);
        for (let i2 = 0; i2 < stakes.length; ++i2) {
          currentSum = currentSum.add(stakes[i2].div(mid));
          if (currentSum.gte(num)) {
            left = mid;
            found = true;
            break;
          }
        }
        if (!found) {
          right = mid;
        }
      }
      return left;
    }
    function findSeatPriceForProtocolAfter49(validators2, maxNumberOfSeats, minimumStakeRatio) {
      if (minimumStakeRatio.length != 2) {
        throw Error("minimumStakeRatio should have 2 elements");
      }
      const stakes = validators2.map((v2) => new bn_js_1$1.default(v2.stake, 10)).sort((a, b2) => a.cmp(b2));
      const stakesSum = stakes.reduce((a, b2) => a.add(b2));
      if (validators2.length < maxNumberOfSeats) {
        return stakesSum.mul(new bn_js_1$1.default(minimumStakeRatio[0])).div(new bn_js_1$1.default(minimumStakeRatio[1]));
      } else {
        return stakes[0].add(new bn_js_1$1.default(1));
      }
    }
    function diffEpochValidators(currentValidators, nextValidators) {
      const validatorsMap = /* @__PURE__ */ new Map();
      currentValidators.forEach((v2) => validatorsMap.set(v2.account_id, v2));
      const nextValidatorsSet = new Set(nextValidators.map((v2) => v2.account_id));
      return {
        newValidators: nextValidators.filter((v2) => !validatorsMap.has(v2.account_id)),
        removedValidators: currentValidators.filter((v2) => !nextValidatorsSet.has(v2.account_id)),
        changedValidators: nextValidators.filter((v2) => validatorsMap.has(v2.account_id) && validatorsMap.get(v2.account_id).stake != v2.stake).map((v2) => ({ current: validatorsMap.get(v2.account_id), next: v2 }))
      };
    }
    validators$1.diffEpochValidators = diffEpochValidators;
    var account = {};
    var constants = {};
    var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(constants, "__esModule", { value: true });
    constants.DEFAULT_FUNCTION_CALL_GAS = void 0;
    const bn_js_1 = __importDefault$1(bnExports);
    constants.DEFAULT_FUNCTION_CALL_GAS = new bn_js_1.default("30000000000000");
    var hasRequiredAccount;
    function requireAccount() {
      hasRequiredAccount = 1;
      var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(account, "__esModule", { value: true });
      account.Account = void 0;
      const bn_js_12 = __importDefault2(bnExports);
      const depd_12 = __importDefault2(browser);
      const transaction_1 = transaction;
      const providers_1 = requireProviders();
      const borsh_1 = lib$5;
      const key_pair_12 = key_pair;
      const errors_1 = errors;
      const rpc_errors_1 = requireRpc_errors();
      const constants_1 = constants;
      const exponential_backoff_1 = __importDefault2(exponentialBackoff$1);
      const TX_NONCE_RETRY_NUMBER = 12;
      const TX_NONCE_RETRY_WAIT = 500;
      const TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;
      function parseJsonFromRawResponse(response) {
        return JSON.parse(Buffer.from(response).toString());
      }
      function bytesJsonStringify(input) {
        return Buffer.from(JSON.stringify(input));
      }
      class Account {
        constructor(connection2, accountId) {
          this.accessKeyByPublicKeyCache = {};
          this.connection = connection2;
          this.accountId = accountId;
        }
        /**
         * Returns basic NEAR account information via the `view_account` RPC query method
         * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)
         */
        state() {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.connection.provider.query({
              request_type: "view_account",
              account_id: this.accountId,
              finality: "optimistic"
            });
          });
        }
        /** @hidden */
        printLogsAndFailures(contractId, results) {
          if (!process.env["NEAR_NO_LOGS"]) {
            for (const result of results) {
              console.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
              this.printLogs(contractId, result.logs, "	");
              if (result.failure) {
                console.warn(`	Failure [${contractId}]: ${result.failure}`);
              }
            }
          }
        }
        /** @hidden */
        printLogs(contractId, logs, prefix = "") {
          if (!process.env["NEAR_NO_LOGS"]) {
            for (const log of logs) {
              console.log(`${prefix}Log [${contractId}]: ${log}`);
            }
          }
        }
        /**
         * Create a signed transaction which can be broadcast to the network
         * @param receiverId NEAR account receiving the transaction
         * @param actions list of actions to perform as part of the transaction
         * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}
         */
        signTransaction(receiverId, actions) {
          return __awaiter2(this, void 0, void 0, function* () {
            const accessKeyInfo = yield this.findAccessKey(receiverId, actions);
            if (!accessKeyInfo) {
              throw new providers_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, "KeyNotFound");
            }
            const { accessKey } = accessKeyInfo;
            const block = yield this.connection.provider.block({ finality: "final" });
            const blockHash = block.header.hash;
            const nonce = accessKey.nonce.add(new bn_js_12.default(1));
            return yield (0, transaction_1.signTransaction)(receiverId, nonce, actions, (0, borsh_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);
          });
        }
        /**
         * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
         * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}
         */
        signAndSendTransaction({ receiverId, actions, returnError }) {
          return __awaiter2(this, void 0, void 0, function* () {
            let txHash, signedTx;
            const result = yield (0, exponential_backoff_1.default)(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, () => __awaiter2(this, void 0, void 0, function* () {
              [txHash, signedTx] = yield this.signTransaction(receiverId, actions);
              const publicKey = signedTx.transaction.publicKey;
              try {
                return yield this.connection.provider.sendTransaction(signedTx);
              } catch (error) {
                if (error.type === "InvalidNonce") {
                  (0, errors_1.logWarning)(`Retrying transaction ${receiverId}:${(0, borsh_1.baseEncode)(txHash)} with new nonce.`);
                  delete this.accessKeyByPublicKeyCache[publicKey.toString()];
                  return null;
                }
                if (error.type === "Expired") {
                  (0, errors_1.logWarning)(`Retrying transaction ${receiverId}:${(0, borsh_1.baseEncode)(txHash)} due to expired block hash`);
                  return null;
                }
                error.context = new providers_1.ErrorContext((0, borsh_1.baseEncode)(txHash));
                throw error;
              }
            }));
            if (!result) {
              throw new providers_1.TypedError("nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.", "RetriesExceeded");
            }
            const flatLogs = [result.transaction_outcome, ...result.receipts_outcome].reduce((acc, it) => {
              if (it.outcome.logs.length || typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object") {
                return acc.concat({
                  "receiptIds": it.outcome.receipt_ids,
                  "logs": it.outcome.logs,
                  "failure": typeof it.outcome.status.Failure != "undefined" ? (0, rpc_errors_1.parseRpcError)(it.outcome.status.Failure) : null
                });
              } else
                return acc;
            }, []);
            this.printLogsAndFailures(signedTx.transaction.receiverId, flatLogs);
            if (!returnError && typeof result.status === "object" && typeof result.status.Failure === "object" && result.status.Failure !== null) {
              if (result.status.Failure.error_message && result.status.Failure.error_type) {
                throw new providers_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);
              } else {
                throw (0, rpc_errors_1.parseResultError)(result);
              }
            }
            return result;
          });
        }
        /**
         * Finds the {@link providers/provider!AccessKeyView} associated with the accounts {@link utils/key_pair!PublicKey} stored in the {@link key_stores/keystore!KeyStore}.
         *
         * @todo Find matching access key based on transaction (i.e. receiverId and actions)
         *
         * @param receiverId currently unused (see todo)
         * @param actions currently unused (see todo)
         * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        findAccessKey(receiverId, actions) {
          return __awaiter2(this, void 0, void 0, function* () {
            const publicKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
            if (!publicKey) {
              throw new providers_1.TypedError(`no matching key pair found in ${this.connection.signer}`, "PublicKeyNotFound");
            }
            const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];
            if (cachedAccessKey !== void 0) {
              return { publicKey, accessKey: cachedAccessKey };
            }
            try {
              const rawAccessKey = yield this.connection.provider.query({
                request_type: "view_access_key",
                account_id: this.accountId,
                public_key: publicKey.toString(),
                finality: "optimistic"
              });
              const accessKey = Object.assign(Object.assign({}, rawAccessKey), { nonce: new bn_js_12.default(rawAccessKey.nonce) });
              if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {
                return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };
              }
              this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;
              return { publicKey, accessKey };
            } catch (e2) {
              if (e2.type == "AccessKeyDoesNotExist") {
                return null;
              }
              throw e2;
            }
          });
        }
        /**
         * Create a new account and deploy a contract to it
         *
         * @param contractId NEAR account where the contract is deployed
         * @param publicKey The public key to add to the created contract account
         * @param data The compiled contract code
         * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
         */
        createAndDeployContract(contractId, publicKey, data, amount) {
          return __awaiter2(this, void 0, void 0, function* () {
            const accessKey = (0, transaction_1.fullAccessKey)();
            yield this.signAndSendTransaction({
              receiverId: contractId,
              actions: [(0, transaction_1.createAccount)(), (0, transaction_1.transfer)(amount), (0, transaction_1.addKey)(key_pair_12.PublicKey.from(publicKey), accessKey), (0, transaction_1.deployContract)(data)]
            });
            const contractAccount = new Account(this.connection, contractId);
            return contractAccount;
          });
        }
        /**
         * @param receiverId NEAR account receiving 
         * @param amount Amount to send in yocto
         */
        sendMoney(receiverId, amount) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.signAndSendTransaction({
              receiverId,
              actions: [(0, transaction_1.transfer)(amount)]
            });
          });
        }
        /**
         * @param newAccountId NEAR account name to be created
         * @param publicKey A public key created from the masterAccount
         */
        createAccount(newAccountId, publicKey, amount) {
          return __awaiter2(this, void 0, void 0, function* () {
            const accessKey = (0, transaction_1.fullAccessKey)();
            return this.signAndSendTransaction({
              receiverId: newAccountId,
              actions: [(0, transaction_1.createAccount)(), (0, transaction_1.transfer)(amount), (0, transaction_1.addKey)(key_pair_12.PublicKey.from(publicKey), accessKey)]
            });
          });
        }
        /**
         * @param beneficiaryId The NEAR account that will receive the remaining  balance from the account being deleted
         */
        deleteAccount(beneficiaryId) {
          return __awaiter2(this, void 0, void 0, function* () {
            if (!process.env["NEAR_NO_LOGS"]) {
              console.log("Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.");
            }
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [(0, transaction_1.deleteAccount)(beneficiaryId)]
            });
          });
        }
        /**
         * @param data The compiled contract code
         */
        deployContract(data) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [(0, transaction_1.deployContract)(data)]
            });
          });
        }
        /** @hidden */
        encodeJSContractArgs(contractId, method2, args) {
          return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method2), Buffer.from([0]), Buffer.from(args)]);
        }
        /**
         * Execute function call
         * @returns {Promise<FinalExecutionOutcome>}
         */
        functionCall({ contractId, methodName, args = {}, gas = constants_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify: stringify2, jsContract }) {
          return __awaiter2(this, void 0, void 0, function* () {
            this.validateArgs(args);
            let functionCallArgs;
            if (jsContract) {
              const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));
              functionCallArgs = ["call_js_contract", encodedArgs, gas, attachedDeposit, null, true];
            } else {
              const stringifyArg = stringify2 === void 0 ? transaction_1.stringifyJsonOrBytes : stringify2;
              functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];
            }
            return this.signAndSendTransaction({
              receiverId: jsContract ? this.connection.jsvmAccountId : contractId,
              // eslint-disable-next-line prefer-spread
              actions: [transaction_1.functionCall.apply(void 0, functionCallArgs)],
              walletMeta,
              walletCallbackUrl
            });
          });
        }
        /**
         * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)
         * @todo expand this API to support more options.
         * @param publicKey A public key to be associated with the contract
         * @param contractId NEAR account where the contract is deployed
         * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
         * @param amount Payment in yocto that is sent to the contract during this function call
         */
        addKey(publicKey, contractId, methodNames, amount) {
          return __awaiter2(this, void 0, void 0, function* () {
            if (!methodNames) {
              methodNames = [];
            }
            if (!Array.isArray(methodNames)) {
              methodNames = [methodNames];
            }
            let accessKey;
            if (!contractId) {
              accessKey = (0, transaction_1.fullAccessKey)();
            } else {
              accessKey = (0, transaction_1.functionCallAccessKey)(contractId, methodNames, amount);
            }
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [(0, transaction_1.addKey)(key_pair_12.PublicKey.from(publicKey), accessKey)]
            });
          });
        }
        /**
         * @param publicKey The public key to be deleted
         * @returns {Promise<FinalExecutionOutcome>}
         */
        deleteKey(publicKey) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [(0, transaction_1.deleteKey)(key_pair_12.PublicKey.from(publicKey))]
            });
          });
        }
        /**
         * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)
         *
         * @param publicKey The public key for the account that's staking
         * @param amount The account to stake in yocto
         */
        stake(publicKey, amount) {
          return __awaiter2(this, void 0, void 0, function* () {
            return this.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [(0, transaction_1.stake)(amount, key_pair_12.PublicKey.from(publicKey))]
            });
          });
        }
        /** @hidden */
        validateArgs(args) {
          const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
          if (isUint8Array) {
            return;
          }
          if (Array.isArray(args) || typeof args !== "object") {
            throw new errors_1.PositionalArgsError();
          }
        }
        /**
         * Invoke a contract view function using the RPC API.
         * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)
         *
         * @param contractId NEAR account where the contract is deployed
         * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
         * @param args Any arguments to the view contract method, wrapped in JSON
         * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
         * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
         * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.
         * @param options.blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
         * @returns {Promise<any>}
         */
        viewFunction(...restArgs) {
          return __awaiter2(this, void 0, void 0, function* () {
            if (typeof restArgs[0] === "string") {
              const contractId = restArgs[0];
              const methodName = restArgs[1];
              const args = restArgs[2];
              const options = restArgs[3];
              return yield this.viewFunctionV1(contractId, methodName, args, options);
            } else {
              return yield this.viewFunctionV2(restArgs[0]);
            }
          });
        }
        viewFunctionV1(contractId, methodName, args = {}, { parse: parse2 = parseJsonFromRawResponse, stringify: stringify2 = bytesJsonStringify, jsContract = false, blockQuery = { finality: "optimistic" } } = {}) {
          return __awaiter2(this, void 0, void 0, function* () {
            const deprecate = (0, depd_12.default)("Account.viewFunction(contractId, methodName, args, options)");
            deprecate("use `Account.viewFunction(ViewFunctionCallOptions)` instead");
            return this.viewFunctionV2({ contractId, methodName, args, parse: parse2, stringify: stringify2, jsContract, blockQuery });
          });
        }
        viewFunctionV2({ contractId, methodName, args, parse: parse2 = parseJsonFromRawResponse, stringify: stringify2 = bytesJsonStringify, jsContract = false, blockQuery = { finality: "optimistic" } }) {
          return __awaiter2(this, void 0, void 0, function* () {
            let encodedArgs;
            this.validateArgs(args);
            if (jsContract) {
              encodedArgs = this.encodeJSContractArgs(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : "");
            } else {
              encodedArgs = stringify2(args);
            }
            const result = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: "call_function" }, blockQuery), { account_id: jsContract ? this.connection.jsvmAccountId : contractId, method_name: jsContract ? "view_js_contract" : methodName, args_base64: encodedArgs.toString("base64") }));
            if (result.logs) {
              this.printLogs(contractId, result.logs);
            }
            return result.result && result.result.length > 0 && parse2(Buffer.from(result.result));
          });
        }
        /**
         * Returns the state (key value pairs) of this account's contract based on the key prefix.
         * Pass an empty string for prefix if you would like to return the entire state.
         * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)
         *
         * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
         * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
         */
        viewState(prefix, blockQuery = { finality: "optimistic" }) {
          return __awaiter2(this, void 0, void 0, function* () {
            const { values } = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: "view_state" }, blockQuery), { account_id: this.accountId, prefix_base64: Buffer.from(prefix).toString("base64") }));
            return values.map(({ key, value }) => ({
              key: Buffer.from(key, "base64"),
              value: Buffer.from(value, "base64")
            }));
          });
        }
        /**
         * Get all access keys for the account
         * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)
         */
        getAccessKeys() {
          var _a;
          return __awaiter2(this, void 0, void 0, function* () {
            const response = yield this.connection.provider.query({
              request_type: "view_access_key_list",
              account_id: this.accountId,
              finality: "optimistic"
            });
            return (_a = response === null || response === void 0 ? void 0 : response.keys) === null || _a === void 0 ? void 0 : _a.map((key) => Object.assign(Object.assign({}, key), { access_key: Object.assign(Object.assign({}, key.access_key), { nonce: new bn_js_12.default(key.access_key.nonce) }) }));
          });
        }
        /**
         * Returns a list of authorized apps
         * @todo update the response value to return all the different keys, not just app keys.
         */
        getAccountDetails() {
          return __awaiter2(this, void 0, void 0, function* () {
            const accessKeys = yield this.getAccessKeys();
            const authorizedApps = accessKeys.filter((item) => item.access_key.permission !== "FullAccess").map((item) => {
              const perm = item.access_key.permission;
              return {
                contractId: perm.FunctionCall.receiver_id,
                amount: perm.FunctionCall.allowance,
                publicKey: item.public_key
              };
            });
            return { authorizedApps };
          });
        }
        /**
         * Returns calculated account balance
         */
        getAccountBalance() {
          return __awaiter2(this, void 0, void 0, function* () {
            const protocolConfig = yield this.connection.provider.experimental_protocolConfig({ finality: "final" });
            const state = yield this.state();
            const costPerByte = new bn_js_12.default(protocolConfig.runtime_config.storage_amount_per_byte);
            const stateStaked = new bn_js_12.default(state.storage_usage).mul(costPerByte);
            const staked = new bn_js_12.default(state.locked);
            const totalBalance = new bn_js_12.default(state.amount).add(staked);
            const availableBalance = totalBalance.sub(bn_js_12.default.max(staked, stateStaked));
            return {
              total: totalBalance.toString(),
              stateStaked: stateStaked.toString(),
              staked: staked.toString(),
              available: availableBalance.toString()
            };
          });
        }
        /**
         * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.
         *
         * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.
         * @returns {Promise<ActiveDelegatedStakeBalance>}
         */
        getActiveDelegatedStakeBalance() {
          return __awaiter2(this, void 0, void 0, function* () {
            const block = yield this.connection.provider.block({ finality: "final" });
            const blockHash = block.header.hash;
            const epochId = block.header.epoch_id;
            const { current_validators, next_validators, current_proposals } = yield this.connection.provider.validators(epochId);
            const pools = /* @__PURE__ */ new Set();
            [...current_validators, ...next_validators, ...current_proposals].forEach((validator) => pools.add(validator.account_id));
            const uniquePools = [...pools];
            const promises = uniquePools.map((validator) => this.viewFunction({
              contractId: validator,
              methodName: "get_account_total_balance",
              args: { account_id: this.accountId },
              blockQuery: { blockId: blockHash }
            }));
            const results = yield Promise.allSettled(promises);
            const hasTimeoutError = results.some((result) => {
              if (result.status === "rejected" && result.reason.type === "TimeoutError") {
                return true;
              }
              return false;
            });
            if (hasTimeoutError) {
              throw new Error("Failed to get delegated stake balance");
            }
            const summary = results.reduce((result, state, index2) => {
              const validatorId = uniquePools[index2];
              if (state.status === "fulfilled") {
                const currentBN = new bn_js_12.default(state.value);
                if (!currentBN.isZero()) {
                  return Object.assign(Object.assign({}, result), { stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }], total: result.total.add(currentBN) });
                }
              }
              if (state.status === "rejected") {
                return Object.assign(Object.assign({}, result), { failedValidators: [...result.failedValidators, { validatorId, error: state.reason }] });
              }
              return result;
            }, { stakedValidators: [], failedValidators: [], total: new bn_js_12.default(0) });
            return Object.assign(Object.assign({}, summary), { total: summary.total.toString() });
          });
        }
      }
      account.Account = Account;
      return account;
    }
    var account_multisig = {};
    var hasRequiredAccount_multisig;
    function requireAccount_multisig() {
      if (hasRequiredAccount_multisig)
        return account_multisig;
      hasRequiredAccount_multisig = 1;
      (function(exports2) {
        var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Account2FA = exports2.AccountMultisig = exports2.MultisigStateStatus = exports2.MultisigDeleteRequestRejectionError = exports2.MULTISIG_CONFIRM_METHODS = exports2.MULTISIG_CHANGE_METHODS = exports2.MULTISIG_DEPOSIT = exports2.MULTISIG_GAS = exports2.MULTISIG_ALLOWANCE = exports2.MULTISIG_STORAGE_KEY = void 0;
        const bn_js_12 = __importDefault2(bnExports);
        const account_1 = requireAccount();
        const format_1 = format$2;
        const key_pair_12 = key_pair;
        const transaction_1 = transaction;
        const providers_1 = requireProviders();
        const web_1 = requireWeb();
        exports2.MULTISIG_STORAGE_KEY = "__multisigRequest";
        exports2.MULTISIG_ALLOWANCE = new bn_js_12.default((0, format_1.parseNearAmount)("1"));
        exports2.MULTISIG_GAS = new bn_js_12.default("100000000000000");
        exports2.MULTISIG_DEPOSIT = new bn_js_12.default("0");
        exports2.MULTISIG_CHANGE_METHODS = ["add_request", "add_request_and_confirm", "delete_request", "confirm"];
        exports2.MULTISIG_CONFIRM_METHODS = ["confirm"];
        var MultisigDeleteRequestRejectionError;
        (function(MultisigDeleteRequestRejectionError2) {
          MultisigDeleteRequestRejectionError2["CANNOT_DESERIALIZE_STATE"] = "Cannot deserialize the contract state";
          MultisigDeleteRequestRejectionError2["MULTISIG_NOT_INITIALIZED"] = "Smart contract panicked: Multisig contract should be initialized before usage";
          MultisigDeleteRequestRejectionError2["NO_SUCH_REQUEST"] = "Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'";
          MultisigDeleteRequestRejectionError2["REQUEST_COOLDOWN_ERROR"] = "Request cannot be deleted immediately after creation.";
          MultisigDeleteRequestRejectionError2["METHOD_NOT_FOUND"] = "Contract method is not found";
        })(MultisigDeleteRequestRejectionError = exports2.MultisigDeleteRequestRejectionError || (exports2.MultisigDeleteRequestRejectionError = {}));
        var MultisigStateStatus;
        (function(MultisigStateStatus2) {
          MultisigStateStatus2[MultisigStateStatus2["INVALID_STATE"] = 0] = "INVALID_STATE";
          MultisigStateStatus2[MultisigStateStatus2["STATE_NOT_INITIALIZED"] = 1] = "STATE_NOT_INITIALIZED";
          MultisigStateStatus2[MultisigStateStatus2["VALID_STATE"] = 2] = "VALID_STATE";
          MultisigStateStatus2[MultisigStateStatus2["UNKNOWN_STATE"] = 3] = "UNKNOWN_STATE";
        })(MultisigStateStatus = exports2.MultisigStateStatus || (exports2.MultisigStateStatus = {}));
        var MultisigCodeStatus;
        (function(MultisigCodeStatus2) {
          MultisigCodeStatus2[MultisigCodeStatus2["INVALID_CODE"] = 0] = "INVALID_CODE";
          MultisigCodeStatus2[MultisigCodeStatus2["VALID_CODE"] = 1] = "VALID_CODE";
          MultisigCodeStatus2[MultisigCodeStatus2["UNKNOWN_CODE"] = 2] = "UNKNOWN_CODE";
        })(MultisigCodeStatus || (MultisigCodeStatus = {}));
        const storageFallback = {
          [exports2.MULTISIG_STORAGE_KEY]: null
        };
        class AccountMultisig extends account_1.Account {
          constructor(connection2, accountId, options) {
            super(connection2, accountId);
            this.storage = options.storage;
            this.onAddRequestResult = options.onAddRequestResult;
          }
          signAndSendTransactionWithAccount(receiverId, actions) {
            const _super = Object.create(null, {
              signAndSendTransaction: { get: () => super.signAndSendTransaction }
            });
            return __awaiter2(this, void 0, void 0, function* () {
              return _super.signAndSendTransaction.call(this, { receiverId, actions });
            });
          }
          signAndSendTransaction({ receiverId, actions }) {
            const _super = Object.create(null, {
              signAndSendTransaction: { get: () => super.signAndSendTransaction }
            });
            return __awaiter2(this, void 0, void 0, function* () {
              const { accountId } = this;
              const args = Buffer.from(JSON.stringify({
                request: {
                  receiver_id: receiverId,
                  actions: convertActions(actions, accountId, receiverId)
                }
              }));
              let result;
              try {
                result = yield _super.signAndSendTransaction.call(this, {
                  receiverId: accountId,
                  actions: [
                    (0, transaction_1.functionCall)("add_request_and_confirm", args, exports2.MULTISIG_GAS, exports2.MULTISIG_DEPOSIT)
                  ]
                });
              } catch (e2) {
                if (e2.toString().includes("Account has too many active requests. Confirm or delete some")) {
                  yield this.deleteUnconfirmedRequests();
                  return yield this.signAndSendTransaction({ receiverId, actions });
                }
                throw e2;
              }
              if (!result.status) {
                throw new Error("Request failed");
              }
              const status2 = Object.assign({}, result.status);
              if (!status2.SuccessValue || typeof status2.SuccessValue !== "string") {
                throw new Error("Request failed");
              }
              this.setRequest({
                accountId,
                actions,
                requestId: parseInt(Buffer.from(status2.SuccessValue, "base64").toString("ascii"), 10)
              });
              if (this.onAddRequestResult) {
                yield this.onAddRequestResult(result);
              }
              this.deleteUnconfirmedRequests();
              return result;
            });
          }
          /*
           * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state
           * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.
           * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.
           */
          checkMultisigCodeAndStateStatus(contractBytes) {
            const _super = Object.create(null, {
              signAndSendTransaction: { get: () => super.signAndSendTransaction }
            });
            return __awaiter2(this, void 0, void 0, function* () {
              const u32_max = 4294967295;
              const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;
              try {
                if (contractBytes) {
                  yield _super.signAndSendTransaction.call(this, {
                    receiverId: this.accountId,
                    actions: [
                      (0, transaction_1.deployContract)(contractBytes),
                      (0, transaction_1.functionCall)("delete_request", { request_id: u32_max }, exports2.MULTISIG_GAS, exports2.MULTISIG_DEPOSIT)
                    ]
                  });
                } else {
                  yield this.deleteRequest(u32_max);
                }
                return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: MultisigStateStatus.VALID_STATE };
              } catch (e2) {
                if (new RegExp(MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e2 && e2.kind && e2.kind.ExecutionError)) {
                  return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.INVALID_STATE };
                } else if (new RegExp(MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e2 && e2.kind && e2.kind.ExecutionError)) {
                  return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.STATE_NOT_INITIALIZED };
                } else if (new RegExp(MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e2 && e2.kind && e2.kind.ExecutionError)) {
                  return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.VALID_STATE };
                } else if (new RegExp(MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e2 && e2.message)) {
                  return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: MultisigStateStatus.UNKNOWN_STATE };
                }
                throw e2;
              }
            });
          }
          deleteRequest(request_id) {
            return super.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [(0, transaction_1.functionCall)("delete_request", { request_id }, exports2.MULTISIG_GAS, exports2.MULTISIG_DEPOSIT)]
            });
          }
          deleteAllRequests() {
            return __awaiter2(this, void 0, void 0, function* () {
              const request_ids = yield this.getRequestIds();
              if (request_ids.length) {
                yield Promise.all(request_ids.map((id2) => this.deleteRequest(id2)));
              }
            });
          }
          deleteUnconfirmedRequests() {
            const _super = Object.create(null, {
              signAndSendTransaction: { get: () => super.signAndSendTransaction }
            });
            return __awaiter2(this, void 0, void 0, function* () {
              const request_ids = yield this.getRequestIds();
              const { requestId } = this.getRequest();
              for (const requestIdToDelete of request_ids) {
                if (requestIdToDelete == requestId) {
                  continue;
                }
                try {
                  yield _super.signAndSendTransaction.call(this, {
                    receiverId: this.accountId,
                    actions: [(0, transaction_1.functionCall)("delete_request", { request_id: requestIdToDelete }, exports2.MULTISIG_GAS, exports2.MULTISIG_DEPOSIT)]
                  });
                } catch (e2) {
                  console.warn("Attempt to delete an earlier request before 15 minutes failed. Will try again.");
                }
              }
            });
          }
          // helpers
          getRequestIds() {
            return __awaiter2(this, void 0, void 0, function* () {
              return this.viewFunction(this.accountId, "list_request_ids");
            });
          }
          getRequest() {
            if (this.storage) {
              return JSON.parse(this.storage.getItem(exports2.MULTISIG_STORAGE_KEY) || "{}");
            }
            return storageFallback[exports2.MULTISIG_STORAGE_KEY];
          }
          setRequest(data) {
            if (this.storage) {
              return this.storage.setItem(exports2.MULTISIG_STORAGE_KEY, JSON.stringify(data));
            }
            storageFallback[exports2.MULTISIG_STORAGE_KEY] = data;
          }
        }
        exports2.AccountMultisig = AccountMultisig;
        class Account2FA extends AccountMultisig {
          constructor(connection2, accountId, options) {
            super(connection2, accountId, options);
            this.helperUrl = "https://helper.testnet.near.org";
            this.helperUrl = options.helperUrl || this.helperUrl;
            this.storage = options.storage;
            this.sendCode = options.sendCode || this.sendCodeDefault;
            this.getCode = options.getCode || this.getCodeDefault;
            this.verifyCode = options.verifyCode || this.verifyCodeDefault;
            this.onConfirmResult = options.onConfirmResult;
          }
          /**
           * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
           * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}
           */
          signAndSendTransaction({ receiverId, actions }) {
            const _super = Object.create(null, {
              signAndSendTransaction: { get: () => super.signAndSendTransaction }
            });
            return __awaiter2(this, void 0, void 0, function* () {
              yield _super.signAndSendTransaction.call(this, { receiverId, actions });
              yield this.sendCode();
              const result = yield this.promptAndVerify();
              if (this.onConfirmResult) {
                yield this.onConfirmResult(result);
              }
              return result;
            });
          }
          // default helpers for CH deployments of multisig
          deployMultisig(contractBytes) {
            const _super = Object.create(null, {
              signAndSendTransactionWithAccount: { get: () => super.signAndSendTransactionWithAccount }
            });
            return __awaiter2(this, void 0, void 0, function* () {
              const { accountId } = this;
              const seedOrLedgerKey = (yield this.getRecoveryMethods()).data.filter(({ kind, publicKey }) => (kind === "phrase" || kind === "ledger") && publicKey !== null).map((rm) => rm.publicKey);
              const fak2lak = (yield this.getAccessKeys()).filter(({ public_key, access_key: { permission } }) => permission === "FullAccess" && !seedOrLedgerKey.includes(public_key)).map((ak2) => ak2.public_key).map(toPK);
              const confirmOnlyKey = toPK((yield this.postSignedJson("/2fa/getAccessKey", { accountId })).publicKey);
              const newArgs = Buffer.from(JSON.stringify({ "num_confirmations": 2 }));
              const actions = [
                ...fak2lak.map((pk2) => (0, transaction_1.deleteKey)(pk2)),
                ...fak2lak.map((pk2) => (0, transaction_1.addKey)(pk2, (0, transaction_1.functionCallAccessKey)(accountId, exports2.MULTISIG_CHANGE_METHODS, null))),
                (0, transaction_1.addKey)(confirmOnlyKey, (0, transaction_1.functionCallAccessKey)(accountId, exports2.MULTISIG_CONFIRM_METHODS, null)),
                (0, transaction_1.deployContract)(contractBytes)
              ];
              const newFunctionCallActionBatch = actions.concat((0, transaction_1.functionCall)("new", newArgs, exports2.MULTISIG_GAS, exports2.MULTISIG_DEPOSIT));
              console.log("deploying multisig contract for", accountId);
              const { stateStatus: multisigStateStatus } = yield this.checkMultisigCodeAndStateStatus(contractBytes);
              switch (multisigStateStatus) {
                case MultisigStateStatus.STATE_NOT_INITIALIZED:
                  return yield _super.signAndSendTransactionWithAccount.call(this, accountId, newFunctionCallActionBatch);
                case MultisigStateStatus.VALID_STATE:
                  return yield _super.signAndSendTransactionWithAccount.call(this, accountId, actions);
                case MultisigStateStatus.INVALID_STATE:
                  throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState");
                default:
                  throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
              }
            });
          }
          disableWithFAK({ contractBytes, cleanupContractBytes }) {
            return __awaiter2(this, void 0, void 0, function* () {
              let cleanupActions = [];
              if (cleanupContractBytes) {
                yield this.deleteAllRequests().catch((e2) => e2);
                cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes);
              }
              const keyConversionActions = yield this.get2faDisableKeyConversionActions();
              const actions = [
                ...cleanupActions,
                ...keyConversionActions,
                (0, transaction_1.deployContract)(contractBytes)
              ];
              const accessKeyInfo = yield this.findAccessKey(this.accountId, actions);
              if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== "FullAccess") {
                throw new providers_1.TypedError("No full access key found in keystore. Unable to bypass multisig", "NoFAKFound");
              }
              return this.signAndSendTransactionWithAccount(this.accountId, actions);
            });
          }
          get2faDisableCleanupActions(cleanupContractBytes) {
            return __awaiter2(this, void 0, void 0, function* () {
              const currentAccountState = yield this.viewState("").catch((error) => {
                const cause = error.cause && error.cause.name;
                if (cause == "NO_CONTRACT_CODE") {
                  return [];
                }
                throw cause == "TOO_LARGE_CONTRACT_STATE" ? new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState") : error;
              });
              const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString("base64"));
              return currentAccountState.length ? [
                (0, transaction_1.deployContract)(cleanupContractBytes),
                (0, transaction_1.functionCall)("clean", { keys: currentAccountStateKeys }, exports2.MULTISIG_GAS, new bn_js_12.default("0"))
              ] : [];
            });
          }
          get2faDisableKeyConversionActions() {
            return __awaiter2(this, void 0, void 0, function* () {
              const { accountId } = this;
              const accessKeys = yield this.getAccessKeys();
              const lak2fak = accessKeys.filter(({ access_key }) => access_key.permission !== "FullAccess").filter(({ access_key }) => {
                const perm = access_key.permission.FunctionCall;
                return perm.receiver_id === accountId && perm.method_names.length === 4 && perm.method_names.includes("add_request_and_confirm");
              });
              const confirmOnlyKey = key_pair_12.PublicKey.from((yield this.postSignedJson("/2fa/getAccessKey", { accountId })).publicKey);
              return [
                (0, transaction_1.deleteKey)(confirmOnlyKey),
                ...lak2fak.map(({ public_key }) => (0, transaction_1.deleteKey)(key_pair_12.PublicKey.from(public_key))),
                ...lak2fak.map(({ public_key }) => (0, transaction_1.addKey)(key_pair_12.PublicKey.from(public_key), (0, transaction_1.fullAccessKey)()))
              ];
            });
          }
          /**
           * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)
           * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}
           * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-cleanup/res/state_cleanup.wasm?raw=true}
           */
          disable(contractBytes, cleanupContractBytes) {
            return __awaiter2(this, void 0, void 0, function* () {
              const { stateStatus } = yield this.checkMultisigCodeAndStateStatus();
              if (stateStatus !== MultisigStateStatus.VALID_STATE && stateStatus !== MultisigStateStatus.STATE_NOT_INITIALIZED) {
                throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
              }
              let deleteAllRequestsError;
              yield this.deleteAllRequests().catch((e2) => deleteAllRequestsError = e2);
              const cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes).catch((e2) => {
                if (e2.type === "ContractHasExistingState") {
                  throw deleteAllRequestsError || e2;
                }
                throw e2;
              });
              const actions = [
                ...cleanupActions,
                ...yield this.get2faDisableKeyConversionActions(),
                (0, transaction_1.deployContract)(contractBytes)
              ];
              console.log("disabling 2fa for", this.accountId);
              return yield this.signAndSendTransaction({
                receiverId: this.accountId,
                actions
              });
            });
          }
          sendCodeDefault() {
            return __awaiter2(this, void 0, void 0, function* () {
              const { accountId } = this;
              const { requestId } = this.getRequest();
              const method2 = yield this.get2faMethod();
              yield this.postSignedJson("/2fa/send", {
                accountId,
                method: method2,
                requestId
              });
              return requestId;
            });
          }
          getCodeDefault() {
            return __awaiter2(this, void 0, void 0, function* () {
              throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".');
            });
          }
          promptAndVerify() {
            return __awaiter2(this, void 0, void 0, function* () {
              const method2 = yield this.get2faMethod();
              const securityCode = yield this.getCode(method2);
              try {
                const result = yield this.verifyCode(securityCode);
                return result;
              } catch (e2) {
                console.warn("Error validating security code:", e2);
                if (e2.toString().includes("invalid 2fa code provided") || e2.toString().includes("2fa code not valid")) {
                  return yield this.promptAndVerify();
                }
                throw e2;
              }
            });
          }
          verifyCodeDefault(securityCode) {
            return __awaiter2(this, void 0, void 0, function* () {
              const { accountId } = this;
              const request = this.getRequest();
              if (!request) {
                throw new Error("no request pending");
              }
              const { requestId } = request;
              return yield this.postSignedJson("/2fa/verify", {
                accountId,
                securityCode,
                requestId
              });
            });
          }
          getRecoveryMethods() {
            return __awaiter2(this, void 0, void 0, function* () {
              const { accountId } = this;
              return {
                accountId,
                data: yield this.postSignedJson("/account/recoveryMethods", { accountId })
              };
            });
          }
          get2faMethod() {
            return __awaiter2(this, void 0, void 0, function* () {
              let { data } = yield this.getRecoveryMethods();
              if (data && data.length) {
                data = data.find((m2) => m2.kind.indexOf("2fa-") === 0);
              }
              if (!data)
                return null;
              const { kind, detail } = data;
              return { kind, detail };
            });
          }
          signatureFor() {
            return __awaiter2(this, void 0, void 0, function* () {
              const { accountId } = this;
              const block = yield this.connection.provider.block({ finality: "final" });
              const blockNumber = block.header.height.toString();
              const signed = yield this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);
              const blockNumberSignature = Buffer.from(signed.signature).toString("base64");
              return { blockNumber, blockNumberSignature };
            });
          }
          postSignedJson(path, body) {
            return __awaiter2(this, void 0, void 0, function* () {
              return yield (0, web_1.fetchJson)(this.helperUrl + path, JSON.stringify(Object.assign(Object.assign({}, body), yield this.signatureFor())));
            });
          }
        }
        exports2.Account2FA = Account2FA;
        const toPK = (pk2) => key_pair_12.PublicKey.from(pk2);
        const convertPKForContract = (pk2) => pk2.toString().replace("ed25519:", "");
        const convertActions = (actions, accountId, receiverId) => actions.map((a) => {
          const type2 = a.enum;
          const { gas, publicKey, methodName, args, deposit, accessKey, code: code2 } = a[type2];
          const action = {
            type: type2[0].toUpperCase() + type2.substr(1),
            gas: gas && gas.toString() || void 0,
            public_key: publicKey && convertPKForContract(publicKey) || void 0,
            method_name: methodName,
            args: args && Buffer.from(args).toString("base64") || void 0,
            code: code2 && Buffer.from(code2).toString("base64") || void 0,
            amount: deposit && deposit.toString() || void 0,
            deposit: deposit && deposit.toString() || "0",
            permission: void 0
          };
          if (accessKey) {
            if (receiverId === accountId && accessKey.permission.enum !== "fullAccess") {
              action.permission = {
                receiver_id: accountId,
                allowance: exports2.MULTISIG_ALLOWANCE.toString(),
                method_names: exports2.MULTISIG_CHANGE_METHODS
              };
            }
            if (accessKey.permission.enum === "functionCall") {
              const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;
              action.permission = {
                receiver_id,
                allowance: allowance && allowance.toString() || void 0,
                method_names
              };
            }
          }
          return action;
        });
      })(account_multisig);
      return account_multisig;
    }
    var account_creator = {};
    var hasRequiredAccount_creator;
    function requireAccount_creator() {
      if (hasRequiredAccount_creator)
        return account_creator;
      hasRequiredAccount_creator = 1;
      var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(account_creator, "__esModule", { value: true });
      account_creator.UrlAccountCreator = account_creator.LocalAccountCreator = account_creator.AccountCreator = void 0;
      const web_1 = requireWeb();
      class AccountCreator {
      }
      account_creator.AccountCreator = AccountCreator;
      class LocalAccountCreator extends AccountCreator {
        constructor(masterAccount, initialBalance) {
          super();
          this.masterAccount = masterAccount;
          this.initialBalance = initialBalance;
        }
        /**
         * Creates an account using a masterAccount, meaning the new account is created from an existing account
         * @param newAccountId The name of the NEAR account to be created
         * @param publicKey The public key from the masterAccount used to create this account
         * @returns {Promise<void>}
         */
        createAccount(newAccountId, publicKey) {
          return __awaiter2(this, void 0, void 0, function* () {
            yield this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);
          });
        }
      }
      account_creator.LocalAccountCreator = LocalAccountCreator;
      class UrlAccountCreator extends AccountCreator {
        constructor(connection2, helperUrl) {
          super();
          this.connection = connection2;
          this.helperUrl = helperUrl;
        }
        /**
         * Creates an account using a helperUrl
         * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
         * @param newAccountId The name of the NEAR account to be created
         * @param publicKey The public key from the masterAccount used to create this account
         * @returns {Promise<void>}
         */
        createAccount(newAccountId, publicKey) {
          return __awaiter2(this, void 0, void 0, function* () {
            yield (0, web_1.fetchJson)(`${this.helperUrl}/account`, JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }));
          });
        }
      }
      account_creator.UrlAccountCreator = UrlAccountCreator;
      return account_creator;
    }
    var connection = {};
    var signer = {};
    var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(signer, "__esModule", { value: true });
    signer.InMemorySigner = signer.Signer = void 0;
    const js_sha256_1 = __importDefault(sha256Exports);
    const key_pair_1 = key_pair;
    const in_memory_key_store_1 = in_memory_key_store;
    class Signer {
    }
    signer.Signer = Signer;
    class InMemorySigner extends Signer {
      constructor(keyStore) {
        super();
        this.keyStore = keyStore;
      }
      /**
       * Creates a single account Signer instance with account, network and keyPair provided.
       *
       * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
       *
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @param accountId The NEAR account to assign the key pair to
       * @param keyPair The keyPair to use for signing
       */
      static fromKeyPair(networkId, accountId, keyPair) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const keyStore = new in_memory_key_store_1.InMemoryKeyStore();
          yield keyStore.setKey(networkId, accountId, keyPair);
          return new InMemorySigner(keyStore);
        });
      }
      /**
       * Creates a public key for the account given
       * @param accountId The NEAR account to assign a public key to
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @returns {Promise<PublicKey>}
       */
      createKey(accountId, networkId) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const keyPair = key_pair_1.KeyPair.fromRandom("ed25519");
          yield this.keyStore.setKey(networkId, accountId, keyPair);
          return keyPair.getPublicKey();
        });
      }
      /**
       * Gets the existing public key for a given account
       * @param accountId The NEAR account to assign a public key to
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @returns {Promise<PublicKey>} Returns the public key or null if not found
       */
      getPublicKey(accountId, networkId) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const keyPair = yield this.keyStore.getKey(networkId, accountId);
          if (keyPair === null) {
            return null;
          }
          return keyPair.getPublicKey();
        });
      }
      /**
       * @param message A message to be signed, typically a serialized transaction
       * @param accountId the NEAR account signing the message
       * @param networkId The targeted network. (ex. default, betanet, etc)
       * @returns {Promise<Signature>}
       */
      signMessage(message, accountId, networkId) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const hash = new Uint8Array(js_sha256_1.default.sha256.array(message));
          if (!accountId) {
            throw new Error("InMemorySigner requires provided account id");
          }
          const keyPair = yield this.keyStore.getKey(networkId, accountId);
          if (keyPair === null) {
            throw new Error(`Key for ${accountId} not found in ${networkId}`);
          }
          return keyPair.sign(hash);
        });
      }
      toString() {
        return `InMemorySigner(${this.keyStore})`;
      }
    }
    signer.InMemorySigner = InMemorySigner;
    var hasRequiredConnection;
    function requireConnection() {
      if (hasRequiredConnection)
        return connection;
      hasRequiredConnection = 1;
      Object.defineProperty(connection, "__esModule", { value: true });
      connection.Connection = void 0;
      const providers_1 = requireProviders();
      const signer_1 = signer;
      function getProvider(config) {
        switch (config.type) {
          case void 0:
            return config;
          case "JsonRpcProvider":
            return new providers_1.JsonRpcProvider(Object.assign({}, config.args));
          default:
            throw new Error(`Unknown provider type ${config.type}`);
        }
      }
      function getSigner(config) {
        switch (config.type) {
          case void 0:
            return config;
          case "InMemorySigner": {
            return new signer_1.InMemorySigner(config.keyStore);
          }
          default:
            throw new Error(`Unknown signer type ${config.type}`);
        }
      }
      class Connection {
        constructor(networkId, provider2, signer2, jsvmAccountId) {
          this.networkId = networkId;
          this.provider = provider2;
          this.signer = signer2;
          this.jsvmAccountId = jsvmAccountId;
        }
        /**
         * @param config Contains connection info details
         */
        static fromConfig(config) {
          const provider2 = getProvider(config.provider);
          const signer2 = getSigner(config.signer);
          return new Connection(config.networkId, provider2, signer2, config.jsvmAccountId);
        }
      }
      connection.Connection = Connection;
      return connection;
    }
    var contract = {};
    var hasRequiredContract;
    function requireContract() {
      if (hasRequiredContract)
        return contract;
      hasRequiredContract = 1;
      var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(contract, "__esModule", { value: true });
      contract.Contract = void 0;
      const bn_js_12 = __importDefault2(bnExports);
      const depd_12 = __importDefault2(browser);
      const providers_1 = requireProviders();
      const errors_1 = errors;
      function nameFunction(name, body) {
        return {
          [name](...args) {
            return body(...args);
          }
        }[name];
      }
      const isUint8Array = (x2) => x2 && x2.byteLength !== void 0 && x2.byteLength === x2.length;
      const isObject2 = (x2) => Object.prototype.toString.call(x2) === "[object Object]";
      class Contract {
        /**
         * @param account NEAR account to sign change method transactions
         * @param contractId NEAR account id where the contract is deployed
         * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`
         */
        constructor(account2, contractId, options) {
          this.account = account2;
          this.contractId = contractId;
          const { viewMethods = [], changeMethods = [] } = options;
          viewMethods.forEach((methodName) => {
            Object.defineProperty(this, methodName, {
              writable: false,
              enumerable: true,
              value: nameFunction(methodName, (args = {}, options2 = {}, ...ignored) => __awaiter2(this, void 0, void 0, function* () {
                if (ignored.length || !(isObject2(args) || isUint8Array(args)) || !isObject2(options2)) {
                  throw new errors_1.PositionalArgsError();
                }
                return this.account.viewFunction(this.contractId, methodName, args, options2);
              }))
            });
          });
          changeMethods.forEach((methodName) => {
            Object.defineProperty(this, methodName, {
              writable: false,
              enumerable: true,
              value: nameFunction(methodName, (...args) => __awaiter2(this, void 0, void 0, function* () {
                if (args.length && (args.length > 3 || !(isObject2(args[0]) || isUint8Array(args[0])))) {
                  throw new errors_1.PositionalArgsError();
                }
                if (args.length > 1 || !(args[0] && args[0].args)) {
                  const deprecate = (0, depd_12.default)("contract.methodName(args, gas, amount)");
                  deprecate("use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead");
                  return this._changeMethod({
                    methodName,
                    args: args[0],
                    gas: args[1],
                    amount: args[2]
                  });
                }
                return this._changeMethod(Object.assign({ methodName }, args[0]));
              }))
            });
          });
        }
        _changeMethod({ args, methodName, gas, amount, meta, callbackUrl }) {
          return __awaiter2(this, void 0, void 0, function* () {
            validateBNLike({ gas, amount });
            const rawResult = yield this.account.functionCall({
              contractId: this.contractId,
              methodName,
              args,
              gas,
              attachedDeposit: amount,
              walletMeta: meta,
              walletCallbackUrl: callbackUrl
            });
            return (0, providers_1.getTransactionLastResult)(rawResult);
          });
        }
      }
      contract.Contract = Contract;
      function validateBNLike(argMap) {
        const bnLike = "number, decimal string or BN";
        for (const argName of Object.keys(argMap)) {
          const argValue = argMap[argName];
          if (argValue && !bn_js_12.default.isBN(argValue) && isNaN(argValue)) {
            throw new errors_1.ArgumentTypeError(argName, bnLike, argValue);
          }
        }
      }
      return contract;
    }
    var near = {};
    var hasRequiredNear;
    function requireNear() {
      if (hasRequiredNear)
        return near;
      hasRequiredNear = 1;
      var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(near, "__esModule", { value: true });
      near.Near = void 0;
      const bn_js_12 = __importDefault2(bnExports);
      const account_1 = requireAccount();
      const connection_1 = requireConnection();
      const account_creator_1 = requireAccount_creator();
      class Near {
        constructor(config) {
          this.config = config;
          this.connection = connection_1.Connection.fromConfig({
            networkId: config.networkId,
            provider: { type: "JsonRpcProvider", args: { url: config.nodeUrl, headers: config.headers } },
            signer: config.signer || { type: "InMemorySigner", keyStore: config.keyStore },
            jsvmAccountId: config.jsvmAccountId || `jsvm.${config.networkId}`
          });
          if (config.masterAccount) {
            const initialBalance = config.initialBalance ? new bn_js_12.default(config.initialBalance) : new bn_js_12.default("500000000000000000000000000");
            this.accountCreator = new account_creator_1.LocalAccountCreator(new account_1.Account(this.connection, config.masterAccount), initialBalance);
          } else if (config.helperUrl) {
            this.accountCreator = new account_creator_1.UrlAccountCreator(this.connection, config.helperUrl);
          } else {
            this.accountCreator = null;
          }
        }
        /**
         * @param accountId near accountId used to interact with the network.
         */
        account(accountId) {
          return __awaiter2(this, void 0, void 0, function* () {
            const account2 = new account_1.Account(this.connection, accountId);
            return account2;
          });
        }
        /**
         * Create an account using the {@link account_creator!AccountCreator}. Either:
         * * using a masterAccount with {@link account_creator!LocalAccountCreator}
         * * using the helperUrl with {@link account_creator!UrlAccountCreator}
         * @see {@link NearConfig.masterAccount} and {@link NearConfig.helperUrl}
         *
         * @param accountId
         * @param publicKey
         */
        createAccount(accountId, publicKey) {
          return __awaiter2(this, void 0, void 0, function* () {
            if (!this.accountCreator) {
              throw new Error("Must specify account creator, either via masterAccount or helperUrl configuration settings.");
            }
            yield this.accountCreator.createAccount(accountId, publicKey);
            return new account_1.Account(this.connection, accountId);
          });
        }
      }
      near.Near = Near;
      return near;
    }
    var walletAccount = {};
    var hasRequiredWalletAccount;
    function requireWalletAccount() {
      if (hasRequiredWalletAccount)
        return walletAccount;
      hasRequiredWalletAccount = 1;
      var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(walletAccount, "__esModule", { value: true });
      walletAccount.ConnectedWalletAccount = walletAccount.WalletConnection = void 0;
      const account_1 = requireAccount();
      const transaction_1 = transaction;
      const utils_1 = requireUtils();
      const borsh_1 = lib$5;
      const borsh_2 = lib$5;
      const bn_js_12 = __importDefault2(bnExports);
      const LOGIN_WALLET_URL_SUFFIX = "/login/";
      const MULTISIG_HAS_METHOD = "add_request_and_confirm";
      const LOCAL_STORAGE_KEY_SUFFIX = "_wallet_auth_key";
      const PENDING_ACCESS_KEY_PREFIX = "pending_key";
      class WalletConnection {
        constructor(near2, appKeyPrefix) {
          if (typeof window === "undefined") {
            return new Proxy(this, {
              get(target, property2) {
                if (property2 === "isSignedIn") {
                  return () => false;
                }
                if (property2 === "getAccountId") {
                  return () => "";
                }
                if (target[property2] && typeof target[property2] === "function") {
                  return () => {
                    throw new Error("No window found in context, please ensure you are using WalletConnection on the browser");
                  };
                }
                return target[property2];
              }
            });
          }
          this._near = near2;
          const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
          const authData = JSON.parse(window.localStorage.getItem(authDataKey));
          this._networkId = near2.config.networkId;
          this._walletBaseUrl = near2.config.walletUrl;
          appKeyPrefix = appKeyPrefix || near2.config.contractName || "default";
          this._keyStore = near2.connection.signer.keyStore;
          this._authData = authData || { allKeys: [] };
          this._authDataKey = authDataKey;
          if (!this.isSignedIn()) {
            this._completeSignInPromise = this._completeSignInWithAccessKey();
          }
        }
        /**
         * Returns true, if this WalletConnection is authorized with the wallet.
         * @example
         * ```js
         * const wallet = new WalletConnection(near, 'my-app');
         * wallet.isSignedIn();
         * ```
         */
        isSignedIn() {
          return !!this._authData.accountId;
        }
        /**
         * Returns promise of completing signing in after redirecting from wallet
         * @example
         * ```js
         * // on login callback page
         * const wallet = new WalletConnection(near, 'my-app');
         * wallet.isSignedIn(); // false
         * await wallet.isSignedInAsync(); // true
         * ```
         */
        isSignedInAsync() {
          return __awaiter2(this, void 0, void 0, function* () {
            if (!this._completeSignInPromise) {
              return this.isSignedIn();
            }
            yield this._completeSignInPromise;
            return this.isSignedIn();
          });
        }
        /**
         * Returns authorized Account ID.
         * @example
         * ```js
         * const wallet = new WalletConnection(near, 'my-app');
         * wallet.getAccountId();
         * ```
         */
        getAccountId() {
          return this._authData.accountId || "";
        }
        /**
         * Redirects current page to the wallet authentication page.
         * @param options An optional options object
         * @param options.contractId The NEAR account where the contract is deployed
         * @param options.successUrl URL to redirect upon success. Default: current url
         * @param options.failureUrl URL to redirect upon failure. Default: current url
         *
         * @example
         * ```js
         * const wallet = new WalletConnection(near, 'my-app');
         * // redirects to the NEAR Wallet
         * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });
         * ```
         */
        requestSignIn({ contractId, methodNames, successUrl, failureUrl }) {
          return __awaiter2(this, void 0, void 0, function* () {
            const currentUrl = new URL(window.location.href);
            const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);
            newUrl.searchParams.set("success_url", successUrl || currentUrl.href);
            newUrl.searchParams.set("failure_url", failureUrl || currentUrl.href);
            if (contractId) {
              const contractAccount = yield this._near.account(contractId);
              yield contractAccount.state();
              newUrl.searchParams.set("contract_id", contractId);
              const accessKey = utils_1.KeyPair.fromRandom("ed25519");
              newUrl.searchParams.set("public_key", accessKey.getPublicKey().toString());
              yield this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);
            }
            if (methodNames) {
              methodNames.forEach((methodName) => {
                newUrl.searchParams.append("methodNames", methodName);
              });
            }
            window.location.assign(newUrl.toString());
          });
        }
        /**
         * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
         */
        requestSignTransactions({ transactions, meta, callbackUrl }) {
          return __awaiter2(this, void 0, void 0, function* () {
            const currentUrl = new URL(window.location.href);
            const newUrl = new URL("sign", this._walletBaseUrl);
            newUrl.searchParams.set("transactions", transactions.map((transaction2) => (0, borsh_2.serialize)(transaction_1.SCHEMA, transaction2)).map((serialized) => Buffer.from(serialized).toString("base64")).join(","));
            newUrl.searchParams.set("callbackUrl", callbackUrl || currentUrl.href);
            if (meta)
              newUrl.searchParams.set("meta", meta);
            window.location.assign(newUrl.toString());
          });
        }
        /**
         * @hidden
         * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.
         */
        _completeSignInWithAccessKey() {
          return __awaiter2(this, void 0, void 0, function* () {
            const currentUrl = new URL(window.location.href);
            const publicKey = currentUrl.searchParams.get("public_key") || "";
            const allKeys = (currentUrl.searchParams.get("all_keys") || "").split(",");
            const accountId = currentUrl.searchParams.get("account_id") || "";
            if (accountId) {
              const authData = {
                accountId,
                allKeys
              };
              window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));
              if (publicKey) {
                yield this._moveKeyFromTempToPermanent(accountId, publicKey);
              }
              this._authData = authData;
            }
            currentUrl.searchParams.delete("public_key");
            currentUrl.searchParams.delete("all_keys");
            currentUrl.searchParams.delete("account_id");
            currentUrl.searchParams.delete("meta");
            currentUrl.searchParams.delete("transactionHashes");
            window.history.replaceState({}, document.title, currentUrl.toString());
          });
        }
        /**
         * @hidden
         * @param accountId The NEAR account owning the given public key
         * @param publicKey The public key being set to the key store
         */
        _moveKeyFromTempToPermanent(accountId, publicKey) {
          return __awaiter2(this, void 0, void 0, function* () {
            const keyPair = yield this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
            yield this._keyStore.setKey(this._networkId, accountId, keyPair);
            yield this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
          });
        }
        /**
         * Sign out from the current account
         * @example
         * walletConnection.signOut();
         */
        signOut() {
          this._authData = {};
          window.localStorage.removeItem(this._authDataKey);
        }
        /**
         * Returns the current connected wallet account
         */
        account() {
          if (!this._connectedAccount) {
            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);
          }
          return this._connectedAccount;
        }
      }
      walletAccount.WalletConnection = WalletConnection;
      class ConnectedWalletAccount extends account_1.Account {
        constructor(walletConnection, connection2, accountId) {
          super(connection2, accountId);
          this.walletConnection = walletConnection;
        }
        // Overriding Account methods
        /**
         * Sign a transaction by redirecting to the NEAR Wallet
         * @see {@link WalletConnection.requestSignTransactions}
         */
        signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {
          const _super = Object.create(null, {
            signAndSendTransaction: { get: () => super.signAndSendTransaction }
          });
          return __awaiter2(this, void 0, void 0, function* () {
            const localKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
            let accessKey = yield this.accessKeyForTransaction(receiverId, actions, localKey);
            if (!accessKey) {
              throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
            }
            if (localKey && localKey.toString() === accessKey.public_key) {
              try {
                return yield _super.signAndSendTransaction.call(this, { receiverId, actions });
              } catch (e2) {
                if (e2.type === "NotEnoughAllowance") {
                  accessKey = yield this.accessKeyForTransaction(receiverId, actions);
                } else {
                  throw e2;
                }
              }
            }
            const block = yield this.connection.provider.block({ finality: "final" });
            const blockHash = (0, borsh_1.baseDecode)(block.header.hash);
            const publicKey = utils_1.PublicKey.from(accessKey.public_key);
            const nonce = accessKey.access_key.nonce.add(new bn_js_12.default(1));
            const transaction2 = (0, transaction_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);
            yield this.walletConnection.requestSignTransactions({
              transactions: [transaction2],
              meta: walletMeta,
              callbackUrl: walletCallbackUrl
            });
            return new Promise((resolve, reject) => {
              setTimeout(() => {
                reject(new Error("Failed to redirect to sign transaction"));
              }, 1e3);
            });
          });
        }
        /**
         * Check if given access key allows the function call or method attempted in transaction
         * @param accessKey Array of \{access_key: AccessKey, public_key: PublicKey\} items
         * @param receiverId The NEAR account attempting to have access
         * @param actions The action(s) needed to be checked for access
         */
        accessKeyMatchesTransaction(accessKey, receiverId, actions) {
          return __awaiter2(this, void 0, void 0, function* () {
            const { access_key: { permission } } = accessKey;
            if (permission === "FullAccess") {
              return true;
            }
            if (permission.FunctionCall) {
              const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
              if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
                return true;
              }
              if (allowedReceiverId === receiverId) {
                if (actions.length !== 1) {
                  return false;
                }
                const [{ functionCall }] = actions;
                return functionCall && (!functionCall.deposit || functionCall.deposit.toString() === "0") && // TODO: Should support charging amount smaller than allowance?
                (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));
              }
            }
            return false;
          });
        }
        /**
         * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
         * @param receiverId The NEAR account seeking the access key for a transaction
         * @param actions The action(s) sought to gain access to
         * @param localKey A local public key provided to check for access
         */
        accessKeyForTransaction(receiverId, actions, localKey) {
          return __awaiter2(this, void 0, void 0, function* () {
            const accessKeys = yield this.getAccessKeys();
            if (localKey) {
              const accessKey = accessKeys.find((key) => key.public_key.toString() === localKey.toString());
              if (accessKey && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {
                return accessKey;
              }
            }
            const walletKeys = this.walletConnection._authData.allKeys;
            for (const accessKey of accessKeys) {
              if (walletKeys.indexOf(accessKey.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {
                return accessKey;
              }
            }
            return null;
          });
        }
      }
      walletAccount.ConnectedWalletAccount = ConnectedWalletAccount;
      return walletAccount;
    }
    var hasRequiredCommonIndex;
    function requireCommonIndex() {
      if (hasRequiredCommonIndex)
        return commonIndex;
      hasRequiredCommonIndex = 1;
      (function(exports2) {
        var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
          if (k22 === void 0)
            k22 = k2;
          var desc = Object.getOwnPropertyDescriptor(m2, k2);
          if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m2[k2];
            } };
          }
          Object.defineProperty(o, k22, desc);
        } : function(o, m2, k2, k22) {
          if (k22 === void 0)
            k22 = k2;
          o[k22] = m2[k2];
        });
        var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
          Object.defineProperty(o, "default", { enumerable: true, value: v2 });
        } : function(o, v2) {
          o["default"] = v2;
        });
        var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k2 in mod)
              if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
                __createBinding2(result, mod, k2);
          }
          __setModuleDefault2(result, mod);
          return result;
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.WalletConnection = exports2.ConnectedWalletAccount = exports2.Near = exports2.KeyPair = exports2.Signer = exports2.InMemorySigner = exports2.Contract = exports2.Connection = exports2.Account = exports2.multisig = exports2.validators = exports2.transactions = exports2.utils = exports2.providers = exports2.accountCreator = void 0;
        const providers2 = __importStar2(requireProviders());
        exports2.providers = providers2;
        const utils2 = __importStar2(requireUtils());
        exports2.utils = utils2;
        const transactions = __importStar2(transaction);
        exports2.transactions = transactions;
        const validators2 = __importStar2(validators$1);
        exports2.validators = validators2;
        const account_1 = requireAccount();
        Object.defineProperty(exports2, "Account", { enumerable: true, get: function() {
          return account_1.Account;
        } });
        const multisig = __importStar2(requireAccount_multisig());
        exports2.multisig = multisig;
        const accountCreator = __importStar2(requireAccount_creator());
        exports2.accountCreator = accountCreator;
        const connection_1 = requireConnection();
        Object.defineProperty(exports2, "Connection", { enumerable: true, get: function() {
          return connection_1.Connection;
        } });
        const signer_1 = signer;
        Object.defineProperty(exports2, "Signer", { enumerable: true, get: function() {
          return signer_1.Signer;
        } });
        Object.defineProperty(exports2, "InMemorySigner", { enumerable: true, get: function() {
          return signer_1.InMemorySigner;
        } });
        const contract_1 = requireContract();
        Object.defineProperty(exports2, "Contract", { enumerable: true, get: function() {
          return contract_1.Contract;
        } });
        const key_pair_12 = key_pair;
        Object.defineProperty(exports2, "KeyPair", { enumerable: true, get: function() {
          return key_pair_12.KeyPair;
        } });
        const near_12 = requireNear();
        Object.defineProperty(exports2, "Near", { enumerable: true, get: function() {
          return near_12.Near;
        } });
        const wallet_account_1 = requireWalletAccount();
        Object.defineProperty(exports2, "ConnectedWalletAccount", { enumerable: true, get: function() {
          return wallet_account_1.ConnectedWalletAccount;
        } });
        Object.defineProperty(exports2, "WalletConnection", { enumerable: true, get: function() {
          return wallet_account_1.WalletConnection;
        } });
      })(commonIndex);
      return commonIndex;
    }
    var browserConnect = {};
    var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(browserConnect, "__esModule", { value: true });
    browserConnect.connect = void 0;
    const near_1 = requireNear();
    function connect(config) {
      return __awaiter(this, void 0, void 0, function* () {
        return new near_1.Near(config);
      });
    }
    browserConnect.connect = connect;
    var errorPolyfillExports = {};
    var errorPolyfill = {
      get exports() {
        return errorPolyfillExports;
      },
      set exports(v2) {
        errorPolyfillExports = v2;
      }
    };
    var capabilityExports = {};
    var capability$3 = {
      get exports() {
        return capabilityExports;
      },
      set exports(v2) {
        capabilityExports = v2;
      }
    };
    var CapabilityDetector$1 = function() {
      this.tests = {};
      this.cache = {};
    };
    CapabilityDetector$1.prototype = {
      constructor: CapabilityDetector$1,
      define: function(name, test2) {
        if (typeof name != "string" || !(test2 instanceof Function))
          throw new Error("Invalid capability definition.");
        if (this.tests[name])
          throw new Error('Duplicated capability definition by "' + name + '".');
        this.tests[name] = test2;
      },
      check: function(name) {
        if (!this.test(name))
          throw new Error('The current environment does not support "' + name + '", therefore we cannot continue.');
      },
      test: function(name) {
        if (this.cache[name] !== void 0)
          return this.cache[name];
        if (!this.tests[name])
          throw new Error('Unknown capability with name "' + name + '".');
        var test2 = this.tests[name];
        this.cache[name] = !!test2();
        return this.cache[name];
      }
    };
    var CapabilityDetector_1 = CapabilityDetector$1;
    var CapabilityDetector = CapabilityDetector_1;
    var detector = new CapabilityDetector();
    var capability$2 = function(name) {
      return detector.test(name);
    };
    capability$2.define = function(name, test2) {
      detector.define(name, test2);
    };
    capability$2.check = function(name) {
      detector.check(name);
    };
    capability$2.test = capability$2;
    var lib$4 = capability$2;
    var capability$1 = lib$4, define = capability$1.define, test = capability$1.test;
    define("strict mode", function() {
      return this === void 0;
    });
    define("arguments.callee.caller", function() {
      try {
        return function() {
          return arguments.callee.caller;
        }() === arguments.callee;
      } catch (strictModeIsEnforced) {
        return false;
      }
    });
    define("es5", function() {
      return test("Array.prototype.forEach") && test("Array.prototype.map") && test("Function.prototype.bind") && test("Object.create") && test("Object.defineProperties") && test("Object.defineProperty") && test("Object.prototype.hasOwnProperty");
    });
    define("Array.prototype.forEach", function() {
      return Array.prototype.forEach;
    });
    define("Array.prototype.map", function() {
      return Array.prototype.map;
    });
    define("Function.prototype.bind", function() {
      return Function.prototype.bind;
    });
    define("Object.create", function() {
      return Object.create;
    });
    define("Object.defineProperties", function() {
      return Object.defineProperties;
    });
    define("Object.defineProperty", function() {
      return Object.defineProperty;
    });
    define("Object.prototype.hasOwnProperty", function() {
      return Object.prototype.hasOwnProperty;
    });
    define("Error.captureStackTrace", function() {
      return Error.captureStackTrace;
    });
    define("Error.prototype.stack", function() {
      try {
        throw new Error();
      } catch (e2) {
        return e2.stack || e2.stacktrace;
      }
    });
    (function(module2) {
      module2.exports = lib$4;
    })(capability$3);
    capabilityExports.check("es5");
    var prepareStackTrace_1;
    var hasRequiredPrepareStackTrace;
    function requirePrepareStackTrace() {
      if (hasRequiredPrepareStackTrace)
        return prepareStackTrace_1;
      hasRequiredPrepareStackTrace = 1;
      var prepareStackTrace = function(throwable, frames, warnings) {
        var string2 = "";
        string2 += throwable.name || "Error";
        string2 += ": " + (throwable.message || "");
        if (warnings instanceof Array)
          for (var warningIndex in warnings) {
            var warning2 = warnings[warningIndex];
            string2 += "\n   # " + warning2;
          }
        for (var frameIndex in frames) {
          var frame = frames[frameIndex];
          string2 += "\n   at " + frame.toString();
        }
        return string2;
      };
      prepareStackTrace_1 = prepareStackTrace;
      return prepareStackTrace_1;
    }
    var v8;
    var hasRequiredV8;
    function requireV8() {
      if (hasRequiredV8)
        return v8;
      hasRequiredV8 = 1;
      var prepareStackTrace = requirePrepareStackTrace();
      v8 = function() {
        Error.getStackTrace = function(throwable) {
          return throwable.stack;
        };
        return {
          prepareStackTrace
        };
      };
      return v8;
    }
    var o3Exports = {};
    var o3 = {
      get exports() {
        return o3Exports;
      },
      set exports(v2) {
        o3Exports = v2;
      }
    };
    var Class_1;
    var hasRequiredClass;
    function requireClass() {
      if (hasRequiredClass)
        return Class_1;
      hasRequiredClass = 1;
      var Class = function() {
        var options = /* @__PURE__ */ Object.create({
          Source: Object,
          config: {},
          buildArgs: []
        });
        function checkOption(option) {
          var key = "config";
          if (option instanceof Function)
            key = "Source";
          else if (option instanceof Array)
            key = "buildArgs";
          else if (option instanceof Object)
            key = "config";
          else
            throw new Error("Invalid configuration option.");
          if (options.hasOwnProperty(key))
            throw new Error("Duplicated configuration option: " + key + ".");
          options[key] = option;
        }
        for (var index2 = 0, length2 = arguments.length; index2 < length2; ++index2)
          checkOption(arguments[index2]);
        var Source = options.Source, config = options.config, buildArgs = options.buildArgs;
        return (Source.extend || Class.extend).call(Source, config, buildArgs);
      };
      Class.factory = function() {
        return function() {
          var instance = this;
          if (instance.build instanceof Function)
            instance.build.apply(instance, arguments);
          if (instance.init instanceof Function)
            instance.init.apply(instance, arguments);
        };
      };
      Class.extend = function(config, buildArgs) {
        var Source = this;
        if (!config)
          config = {};
        var Subject;
        if (config.prototype instanceof Object && config.prototype.constructor !== Object)
          Subject = config.prototype.constructor;
        else if (config.factory instanceof Function)
          Subject = config.factory.call(Source);
        Subject = (Source.clone || Class.clone).call(Source, Subject, buildArgs);
        (Subject.merge || Class.merge).call(Subject, config);
        return Subject;
      };
      Class.prototype.extend = function(config, buildArgs) {
        var subject = this;
        var instance = (subject.clone || Class.prototype.clone).apply(subject, buildArgs);
        (instance.merge || Class.prototype.merge).call(instance, config);
        return instance;
      };
      Class.clone = function(Subject, buildArgs) {
        var Source = this;
        if (!(Subject instanceof Function))
          Subject = (Source.factory || Class.factory).call(Source);
        Subject.prototype = (Source.prototype.clone || Class.prototype.clone).apply(Source.prototype, buildArgs || []);
        Subject.prototype.constructor = Subject;
        for (var staticProperty in Source)
          if (staticProperty !== "prototype")
            Subject[staticProperty] = Source[staticProperty];
        return Subject;
      };
      Class.prototype.clone = function() {
        var subject = this;
        var instance = Object.create(subject);
        if (instance.build instanceof Function)
          instance.build.apply(instance, arguments);
        return instance;
      };
      Class.merge = function(config) {
        var Subject = this;
        for (var staticProperty in config)
          if (staticProperty !== "prototype")
            Subject[staticProperty] = config[staticProperty];
        if (config.prototype instanceof Object)
          (Subject.prototype.merge || Class.prototype.merge).call(Subject.prototype, config.prototype);
        return Subject;
      };
      Class.prototype.merge = function(config) {
        var subject = this;
        for (var property2 in config)
          if (property2 !== "constructor")
            subject[property2] = config[property2];
        return subject;
      };
      Class.absorb = function(config) {
        var Subject = this;
        for (var staticProperty in config)
          if (staticProperty !== "prototype" && (Subject[staticProperty] === void 0 || Subject[staticProperty] === Function.prototype[staticProperty]))
            Subject[staticProperty] = config[staticProperty];
        if (config.prototype instanceof Object)
          (Subject.prototype.absorb || Class.prototype.absorb).call(Subject.prototype, config.prototype);
        return Subject;
      };
      Class.prototype.absorb = function(config) {
        var subject = this;
        for (var property2 in config)
          if (property2 !== "constructor" && (subject[property2] === void 0 || subject[property2] === Object.prototype[property2]))
            subject[property2] = config[property2];
        return subject;
      };
      Class.getAncestor = function() {
        var Source = this;
        if (Source !== Source.prototype.constructor)
          return Source.prototype.constructor;
      };
      Class.newInstance = function() {
        var Subject = this;
        var instance = Object.create(this.prototype);
        Subject.apply(instance, arguments);
        return instance;
      };
      Class_1 = Class;
      return Class_1;
    }
    var abstractMethod;
    var hasRequiredAbstractMethod;
    function requireAbstractMethod() {
      if (hasRequiredAbstractMethod)
        return abstractMethod;
      hasRequiredAbstractMethod = 1;
      abstractMethod = function() {
        throw new Error("Not implemented.");
      };
      return abstractMethod;
    }
    var lib$3;
    var hasRequiredLib$1;
    function requireLib$1() {
      if (hasRequiredLib$1)
        return lib$3;
      hasRequiredLib$1 = 1;
      lib$3 = {
        Class: requireClass(),
        abstractMethod: requireAbstractMethod()
      };
      return lib$3;
    }
    var hasRequiredO3;
    function requireO3() {
      if (hasRequiredO3)
        return o3Exports;
      hasRequiredO3 = 1;
      (function(module2) {
        module2.exports = requireLib$1();
      })(o3);
      return o3Exports;
    }
    var u3Exports = {};
    var u3 = {
      get exports() {
        return u3Exports;
      },
      set exports(v2) {
        u3Exports = v2;
      }
    };
    var cache_1;
    var hasRequiredCache;
    function requireCache() {
      if (hasRequiredCache)
        return cache_1;
      hasRequiredCache = 1;
      var cache = function(fn) {
        var called = false, store;
        if (!(fn instanceof Function)) {
          called = true;
          store = fn;
          fn = null;
        }
        return function() {
          if (!called) {
            called = true;
            store = fn.apply(this, arguments);
            fn = null;
          }
          return store;
        };
      };
      cache_1 = cache;
      return cache_1;
    }
    var eachCombination;
    var hasRequiredEachCombination;
    function requireEachCombination() {
      if (hasRequiredEachCombination)
        return eachCombination;
      hasRequiredEachCombination = 1;
      eachCombination = function eachCombination2(alternativesByDimension, callback, combination) {
        if (!combination)
          combination = [];
        if (combination.length < alternativesByDimension.length) {
          var alternatives = alternativesByDimension[combination.length];
          for (var index2 in alternatives) {
            combination[combination.length] = alternatives[index2];
            eachCombination2(alternativesByDimension, callback, combination);
            --combination.length;
          }
        } else
          callback.apply(null, combination);
      };
      return eachCombination;
    }
    var lib$2;
    var hasRequiredLib;
    function requireLib() {
      if (hasRequiredLib)
        return lib$2;
      hasRequiredLib = 1;
      lib$2 = {
        cache: requireCache(),
        eachCombination: requireEachCombination()
      };
      return lib$2;
    }
    var hasRequiredU3;
    function requireU3() {
      if (hasRequiredU3)
        return u3Exports;
      hasRequiredU3 = 1;
      (function(module2) {
        module2.exports = requireLib();
      })(u3);
      return u3Exports;
    }
    var FrameStringSource;
    var hasRequiredFrameStringSource;
    function requireFrameStringSource() {
      if (hasRequiredFrameStringSource)
        return FrameStringSource;
      hasRequiredFrameStringSource = 1;
      var Class = requireO3().Class, abstractMethod2 = requireO3().abstractMethod, eachCombination2 = requireU3().eachCombination, cache = requireU3().cache, capability2 = capabilityExports;
      var AbstractFrameStringSource = Class(Object, {
        prototype: {
          captureFrameStrings: function(frameShifts) {
            var error = this.createError();
            frameShifts.unshift(this.captureFrameStrings);
            frameShifts.unshift(this.createError);
            var capturedFrameStrings = this.getFrameStrings(error);
            var frameStrings = capturedFrameStrings.slice(frameShifts.length), functionValues = [];
            if (capability2("arguments.callee.caller")) {
              var capturedFunctionValues = [
                this.createError,
                this.captureFrameStrings
              ];
              try {
                var aCaller = arguments.callee;
                while (aCaller = aCaller.caller)
                  capturedFunctionValues.push(aCaller);
              } catch (useStrictError) {
              }
              functionValues = capturedFunctionValues.slice(frameShifts.length);
            }
            return {
              frameStrings,
              functionValues
            };
          },
          getFrameStrings: function(error) {
            var message = error.message || "";
            var name = error.name || "";
            var stackString = this.getStackString(error);
            if (stackString === void 0)
              return;
            var stackStringChunks = stackString.split("\n");
            var fromPosition = 0;
            var toPosition = stackStringChunks.length;
            if (this.hasHeader)
              fromPosition += name.split("\n").length + message.split("\n").length - 1;
            if (this.hasFooter)
              toPosition -= 1;
            return stackStringChunks.slice(fromPosition, toPosition);
          },
          createError: abstractMethod2,
          getStackString: abstractMethod2,
          hasHeader: void 0,
          hasFooter: void 0
        }
      });
      var FrameStringSourceCalibrator = Class(Object, {
        prototype: {
          calibrateClass: function(FrameStringSource2) {
            return this.calibrateMethods(FrameStringSource2) && this.calibrateEnvelope(FrameStringSource2);
          },
          calibrateMethods: function(FrameStringSource2) {
            try {
              eachCombination2([[
                function(message) {
                  return new Error(message);
                },
                function(message) {
                  try {
                    throw new Error(message);
                  } catch (error) {
                    return error;
                  }
                }
              ], [
                function(error) {
                  return error.stack;
                },
                function(error) {
                  return error.stacktrace;
                }
              ]], function(createError, getStackString) {
                if (getStackString(createError()))
                  throw {
                    getStackString,
                    createError
                  };
              });
            } catch (workingImplementation) {
              Class.merge.call(FrameStringSource2, {
                prototype: workingImplementation
              });
              return true;
            }
            return false;
          },
          calibrateEnvelope: function(FrameStringSource2) {
            var getStackString = FrameStringSource2.prototype.getStackString;
            var createError = FrameStringSource2.prototype.createError;
            var calibratorStackString = getStackString(createError("marker"));
            var calibratorFrameStrings = calibratorStackString.split("\n");
            Class.merge.call(FrameStringSource2, {
              prototype: {
                hasHeader: /marker/.test(calibratorFrameStrings[0]),
                hasFooter: calibratorFrameStrings[calibratorFrameStrings.length - 1] === ""
              }
            });
            return true;
          }
        }
      });
      FrameStringSource = {
        getClass: cache(function() {
          var FrameStringSource2;
          if (FrameStringSource2)
            return FrameStringSource2;
          FrameStringSource2 = Class(AbstractFrameStringSource, {});
          var calibrator = new FrameStringSourceCalibrator();
          if (!calibrator.calibrateClass(FrameStringSource2))
            throw new Error("Cannot read Error.prototype.stack in this environment.");
          return FrameStringSource2;
        }),
        getInstance: cache(function() {
          var FrameStringSource2 = this.getClass();
          var instance = new FrameStringSource2();
          return instance;
        })
      };
      return FrameStringSource;
    }
    var Frame_1;
    var hasRequiredFrame;
    function requireFrame() {
      if (hasRequiredFrame)
        return Frame_1;
      hasRequiredFrame = 1;
      var Class = requireO3().Class, abstractMethod2 = requireO3().abstractMethod;
      var Frame = Class(Object, {
        prototype: {
          init: Class.prototype.merge,
          frameString: void 0,
          toString: function() {
            return this.frameString;
          },
          functionValue: void 0,
          getThis: abstractMethod2,
          getTypeName: abstractMethod2,
          getFunction: function() {
            return this.functionValue;
          },
          getFunctionName: abstractMethod2,
          getMethodName: abstractMethod2,
          getFileName: abstractMethod2,
          getLineNumber: abstractMethod2,
          getColumnNumber: abstractMethod2,
          getEvalOrigin: abstractMethod2,
          isTopLevel: abstractMethod2,
          isEval: abstractMethod2,
          isNative: abstractMethod2,
          isConstructor: abstractMethod2
        }
      });
      Frame_1 = Frame;
      return Frame_1;
    }
    var FrameStringParser_1;
    var hasRequiredFrameStringParser;
    function requireFrameStringParser() {
      if (hasRequiredFrameStringParser)
        return FrameStringParser_1;
      hasRequiredFrameStringParser = 1;
      var Class = requireO3().Class, Frame = requireFrame(), cache = requireU3().cache;
      var FrameStringParser = Class(Object, {
        prototype: {
          stackParser: null,
          frameParser: null,
          locationParsers: null,
          constructor: function(options) {
            Class.prototype.merge.call(this, options);
          },
          getFrames: function(frameStrings, functionValues) {
            var frames = [];
            for (var index2 = 0, length2 = frameStrings.length; index2 < length2; ++index2)
              frames[index2] = this.getFrame(frameStrings[index2], functionValues[index2]);
            return frames;
          },
          getFrame: function(frameString, functionValue) {
            var config = {
              frameString,
              functionValue
            };
            return new Frame(config);
          }
        }
      });
      FrameStringParser_1 = {
        getClass: cache(function() {
          return FrameStringParser;
        }),
        getInstance: cache(function() {
          var FrameStringParser2 = this.getClass();
          var instance = new FrameStringParser2();
          return instance;
        })
      };
      return FrameStringParser_1;
    }
    var nonV8;
    var hasRequiredNonV8;
    function requireNonV8() {
      if (hasRequiredNonV8)
        return nonV8;
      hasRequiredNonV8 = 1;
      var FrameStringSource2 = requireFrameStringSource(), FrameStringParser = requireFrameStringParser(), cache = requireU3().cache, prepareStackTrace = requirePrepareStackTrace();
      nonV8 = function() {
        Error.captureStackTrace = function captureStackTrace(throwable, terminator) {
          var warnings;
          var frameShifts = [
            captureStackTrace
          ];
          if (terminator) {
            frameShifts.push(terminator);
          }
          var captured = FrameStringSource2.getInstance().captureFrameStrings(frameShifts);
          Object.defineProperties(throwable, {
            stack: {
              configurable: true,
              get: cache(function() {
                var frames = FrameStringParser.getInstance().getFrames(captured.frameStrings, captured.functionValues);
                return (Error.prepareStackTrace || prepareStackTrace)(throwable, frames, warnings);
              })
            },
            cachedStack: {
              configurable: true,
              writable: true,
              enumerable: false,
              value: true
            }
          });
        };
        Error.getStackTrace = function(throwable) {
          if (throwable.cachedStack)
            return throwable.stack;
          var frameStrings = FrameStringSource2.getInstance().getFrameStrings(throwable), frames = [], warnings;
          if (frameStrings)
            frames = FrameStringParser.getInstance().getFrames(frameStrings, []);
          else
            warnings = [
              "The stack is not readable by unthrown errors in this environment."
            ];
          var stack = (Error.prepareStackTrace || prepareStackTrace)(throwable, frames, warnings);
          if (frameStrings)
            try {
              Object.defineProperties(throwable, {
                stack: {
                  configurable: true,
                  writable: true,
                  enumerable: false,
                  value: stack
                },
                cachedStack: {
                  configurable: true,
                  writable: true,
                  enumerable: false,
                  value: true
                }
              });
            } catch (nonConfigurableError) {
            }
          return stack;
        };
        return {
          prepareStackTrace
        };
      };
      return nonV8;
    }
    var unsupported;
    var hasRequiredUnsupported;
    function requireUnsupported() {
      if (hasRequiredUnsupported)
        return unsupported;
      hasRequiredUnsupported = 1;
      var cache = requireU3().cache, prepareStackTrace = requirePrepareStackTrace();
      unsupported = function() {
        Error.captureStackTrace = function(throwable, terminator) {
          Object.defineProperties(throwable, {
            stack: {
              configurable: true,
              get: cache(function() {
                return (Error.prepareStackTrace || prepareStackTrace)(throwable, []);
              })
            },
            cachedStack: {
              configurable: true,
              writable: true,
              enumerable: false,
              value: true
            }
          });
        };
        Error.getStackTrace = function(throwable) {
          if (throwable.cachedStack)
            return throwable.stack;
          var stack = (Error.prepareStackTrace || prepareStackTrace)(throwable, []);
          try {
            Object.defineProperties(throwable, {
              stack: {
                configurable: true,
                writable: true,
                enumerable: false,
                value: stack
              },
              cachedStack: {
                configurable: true,
                writable: true,
                enumerable: false,
                value: true
              }
            });
          } catch (nonConfigurableError) {
          }
          return stack;
        };
        return {
          prepareStackTrace
        };
      };
      return unsupported;
    }
    var capability = capabilityExports;
    var polyfill;
    if (capability("Error.captureStackTrace"))
      polyfill = requireV8();
    else if (capability("Error.prototype.stack"))
      polyfill = requireNonV8();
    else
      polyfill = requireUnsupported();
    var lib$1 = polyfill();
    (function(module2) {
      module2.exports = lib$1;
    })(errorPolyfill);
    (function(exports2) {
      var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m2[k2];
      });
      var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
        Object.defineProperty(o, "default", { enumerable: true, value: v2 });
      } : function(o, v2) {
        o["default"] = v2;
      });
      var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding2(result, mod, k2);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
      var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding2(exports3, m2, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.keyStores = void 0;
      exports2.keyStores = __importStar2(browserIndex);
      __exportStar(requireCommonIndex(), exports2);
      __exportStar(browserConnect, exports2);
    })(browserIndex$1);
    const myKeyStore = new browserIndex$1.keyStores.BrowserLocalStorageKeyStore();
    const NearContext = reactExports.createContext({
      isInitializedContext: false,
      signUp: async () => ({
        accountID: "",
        accountBalance: {
          total: "",
          stateStaked: "",
          staked: "",
          available: ""
        },
        color: [0, 0, 0]
      }),
      signIn: async () => {
      },
      signOut: () => {
      },
      setNearColor: async (rgb) => [0, 0, 0]
    });
    const CONTRACT_ADDRESS = "frontend-test-1.badconfig.testnet";
    const NearContextProvider = ({ children }) => {
      const [walletConnection, setWalletConnection] = reactExports.useState();
      const [account2, setAccount] = reactExports.useState();
      const signUp = reactExports.useCallback(async () => {
        const connectionConfig = {
          networkId: "testnet",
          keyStore: myKeyStore,
          // first create a key store
          nodeUrl: "https://rpc.testnet.near.org",
          walletUrl: "https://wallet.testnet.near.org",
          helperUrl: "https://helper.testnet.near.org",
          explorerUrl: "https://explorer.testnet.near.org"
        };
        const nearConnection = await browserIndex$1.connect(connectionConfig);
        const walletConnection2 = new browserIndex$1.WalletConnection(nearConnection, null);
        setWalletConnection(walletConnection2);
        const accountID = walletConnection2.getAccountId();
        const account22 = await nearConnection.account(accountID);
        setAccount(account22);
        const accountBalance = await account22.getAccountBalance();
        const color = await account22.viewFunction(CONTRACT_ADDRESS, "get");
        return {
          accountID,
          accountBalance,
          color
        };
      }, []);
      const signIn = reactExports.useCallback(async () => {
        await (walletConnection == null ? void 0 : walletConnection.requestSignIn({
          contractId: CONTRACT_ADDRESS,
          successUrl: location.href + "#hack"
        }));
      }, [walletConnection]);
      const signOut = reactExports.useCallback(() => {
        walletConnection == null ? void 0 : walletConnection.signOut();
      }, [walletConnection]);
      const setNearColor = reactExports.useCallback(async ([r2, g2, b2]) => {
        if (!account2)
          return;
        const contract2 = new browserIndex$1.Contract(
          account2,
          CONTRACT_ADDRESS,
          {
            viewMethods: [],
            changeMethods: ["set"]
          }
        );
        await contract2.set(
          {
            r: r2,
            g: g2,
            b: b2
          }
        );
        return await account2.viewFunction(CONTRACT_ADDRESS, "get");
      }, [account2]);
      const value = reactExports.useMemo(() => ({
        isInitializedContext: true,
        signUp,
        signIn,
        signOut,
        setNearColor
      }), [signUp, signIn, signOut]);
      return /* @__PURE__ */ jsx(NearContext.Provider, { value, children });
    };
    const useNear = () => reactExports.useContext(NearContext);
    function _classCallCheck$a(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _typeof$1(obj) {
      "@babel/helpers - typeof";
      return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$1(obj);
    }
    function _toPrimitive(input, hint) {
      if (_typeof$1(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof$1(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof$1(key) === "symbol" ? key : String(key);
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass$8(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _setPrototypeOf$1(o, p2) {
      _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      return _setPrototypeOf$1(o, p2);
    }
    function _inherits$a(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        _setPrototypeOf$1(subClass, superClass);
    }
    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf$1(o);
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn$a(self2, call2) {
      if (call2 && (_typeof$1(call2) === "object" || typeof call2 === "function")) {
        return call2;
      } else if (call2 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$1(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$1(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$a(this, result);
      };
    }
    var classnamesExports = {};
    var classnames = {
      get exports() {
        return classnamesExports;
      },
      set exports(v2) {
        classnamesExports = v2;
      }
    };
    /*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    */
    (function(module2) {
      (function() {
        var hasOwn = {}.hasOwnProperty;
        function classNames2() {
          var classes = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            if (!arg)
              continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames2.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            }
          }
          return classes.join(" ");
        }
        if (module2.exports) {
          classNames2.default = classNames2;
          module2.exports = classNames2;
        } else {
          window.classNames = classNames2;
        }
      })();
    })(classnames);
    const classNames = classnamesExports;
    function _extends$g() {
      _extends$g = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$g.apply(this, arguments);
    }
    var reactIsExports = {};
    var reactIs = {
      get exports() {
        return reactIsExports;
      },
      set exports(v2) {
        reactIsExports = v2;
      }
    };
    var reactIs_production_min = {};
    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
    function z(a) {
      if ("object" === typeof a && null !== a) {
        var u2 = a.$$typeof;
        switch (u2) {
          case c:
            switch (a = a.type, a) {
              case l:
              case m:
              case e:
              case g:
              case f:
              case p:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n:
                  case t:
                  case r:
                  case h:
                    return a;
                  default:
                    return u2;
                }
            }
          case d:
            return u2;
        }
      }
    }
    function A(a) {
      return z(a) === m;
    }
    reactIs_production_min.AsyncMode = l;
    reactIs_production_min.ConcurrentMode = m;
    reactIs_production_min.ContextConsumer = k;
    reactIs_production_min.ContextProvider = h;
    reactIs_production_min.Element = c;
    reactIs_production_min.ForwardRef = n;
    reactIs_production_min.Fragment = e;
    reactIs_production_min.Lazy = t;
    reactIs_production_min.Memo = r;
    reactIs_production_min.Portal = d;
    reactIs_production_min.Profiler = g;
    reactIs_production_min.StrictMode = f;
    reactIs_production_min.Suspense = p;
    reactIs_production_min.isAsyncMode = function(a) {
      return A(a) || z(a) === l;
    };
    reactIs_production_min.isConcurrentMode = A;
    reactIs_production_min.isContextConsumer = function(a) {
      return z(a) === k;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return z(a) === h;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return z(a) === n;
    };
    reactIs_production_min.isFragment = function(a) {
      return z(a) === e;
    };
    reactIs_production_min.isLazy = function(a) {
      return z(a) === t;
    };
    reactIs_production_min.isMemo = function(a) {
      return z(a) === r;
    };
    reactIs_production_min.isPortal = function(a) {
      return z(a) === d;
    };
    reactIs_production_min.isProfiler = function(a) {
      return z(a) === g;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return z(a) === f;
    };
    reactIs_production_min.isSuspense = function(a) {
      return z(a) === p;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
    };
    reactIs_production_min.typeOf = z;
    (function(module2) {
      {
        module2.exports = reactIs_production_min;
      }
    })(reactIs);
    function toArray$2(children) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var ret = [];
      React$1.Children.forEach(children, function(child) {
        if ((child === void 0 || child === null) && !option.keepEmpty) {
          return;
        }
        if (Array.isArray(child)) {
          ret = ret.concat(toArray$2(child));
        } else if (reactIsExports.isFragment(child) && child.props) {
          ret = ret.concat(toArray$2(child.props.children, option));
        } else {
          ret.push(child);
        }
      });
      return ret;
    }
    var warned = {};
    function warning$2(valid, message) {
    }
    function call(method2, valid, message) {
      if (!valid && !warned[message]) {
        method2(false, message);
        warned[message] = true;
      }
    }
    function warningOnce(valid, message) {
      call(warning$2, valid, message);
    }
    function _defineProperty$2(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ownKeys(object2, enumerableOnly) {
      var keys2 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty$2(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function useMemo(getValue2, condition, shouldUpdate) {
      var cacheRef = reactExports.useRef({});
      if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue2();
        cacheRef.current.condition = condition;
      }
      return cacheRef.current.value;
    }
    function fillRef(ref, node2) {
      if (typeof ref === "function") {
        ref(node2);
      } else if (_typeof$1(ref) === "object" && ref && "current" in ref) {
        ref.current = node2;
      }
    }
    function composeRef() {
      for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
        refs[_key] = arguments[_key];
      }
      var refList = refs.filter(function(ref) {
        return ref;
      });
      if (refList.length <= 1) {
        return refList[0];
      }
      return function(node2) {
        refs.forEach(function(ref) {
          fillRef(ref, node2);
        });
      };
    }
    function useComposeRef() {
      for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        refs[_key2] = arguments[_key2];
      }
      return useMemo(function() {
        return composeRef.apply(void 0, refs);
      }, refs, function(prev2, next2) {
        return prev2.length === next2.length && prev2.every(function(ref, i2) {
          return ref === next2[i2];
        });
      });
    }
    function supportRef(nodeOrComponent) {
      var _type$prototype, _nodeOrComponent$prot;
      var type2 = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
      if (typeof type2 === "function" && !((_type$prototype = type2.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
        return false;
      }
      if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
        return false;
      }
      return true;
    }
    function isDOM(node2) {
      return node2 instanceof HTMLElement || node2 instanceof SVGElement;
    }
    function findDOMNode(node2) {
      if (isDOM(node2)) {
        return node2;
      }
      if (node2 instanceof React$1.Component) {
        return ReactDOM.findDOMNode(node2);
      }
      return null;
    }
    var MapShim = function() {
      if (typeof Map !== "undefined") {
        return Map;
      }
      function getIndex(arr, key) {
        var result = -1;
        arr.some(function(entry, index2) {
          if (entry[0] === key) {
            result = index2;
            return true;
          }
          return false;
        });
        return result;
      }
      return (
        /** @class */
        function() {
          function class_1() {
            this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function() {
              return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
          });
          class_1.prototype.get = function(key) {
            var index2 = getIndex(this.__entries__, key);
            var entry = this.__entries__[index2];
            return entry && entry[1];
          };
          class_1.prototype.set = function(key, value) {
            var index2 = getIndex(this.__entries__, key);
            if (~index2) {
              this.__entries__[index2][1] = value;
            } else {
              this.__entries__.push([key, value]);
            }
          };
          class_1.prototype.delete = function(key) {
            var entries = this.__entries__;
            var index2 = getIndex(entries, key);
            if (~index2) {
              entries.splice(index2, 1);
            }
          };
          class_1.prototype.has = function(key) {
            return !!~getIndex(this.__entries__, key);
          };
          class_1.prototype.clear = function() {
            this.__entries__.splice(0);
          };
          class_1.prototype.forEach = function(callback, ctx) {
            if (ctx === void 0) {
              ctx = null;
            }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
              var entry = _a[_i];
              callback.call(ctx, entry[1], entry[0]);
            }
          };
          return class_1;
        }()
      );
    }();
    var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
    var global$1 = function() {
      if (typeof global !== "undefined" && global.Math === Math) {
        return global;
      }
      if (typeof self !== "undefined" && self.Math === Math) {
        return self;
      }
      if (typeof window !== "undefined" && window.Math === Math) {
        return window;
      }
      return Function("return this")();
    }();
    var requestAnimationFrame$1 = function() {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame.bind(global$1);
      }
      return function(callback) {
        return setTimeout(function() {
          return callback(Date.now());
        }, 1e3 / 60);
      };
    }();
    var trailingTimeout = 2;
    function throttle$1(callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      function resolvePending() {
        if (leadingCall) {
          leadingCall = false;
          callback();
        }
        if (trailingCall) {
          proxy();
        }
      }
      function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
      }
      function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
          if (timeStamp - lastCallTime < trailingTimeout) {
            return;
          }
          trailingCall = true;
        } else {
          leadingCall = true;
          trailingCall = false;
          setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
      }
      return proxy;
    }
    var REFRESH_DELAY = 20;
    var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
    var mutationObserverSupported = typeof MutationObserver !== "undefined";
    var ResizeObserverController = (
      /** @class */
      function() {
        function ResizeObserverController2() {
          this.connected_ = false;
          this.mutationEventsAdded_ = false;
          this.mutationsObserver_ = null;
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
        }
        ResizeObserverController2.prototype.addObserver = function(observer) {
          if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
          }
          if (!this.connected_) {
            this.connect_();
          }
        };
        ResizeObserverController2.prototype.removeObserver = function(observer) {
          var observers2 = this.observers_;
          var index2 = observers2.indexOf(observer);
          if (~index2) {
            observers2.splice(index2, 1);
          }
          if (!observers2.length && this.connected_) {
            this.disconnect_();
          }
        };
        ResizeObserverController2.prototype.refresh = function() {
          var changesDetected = this.updateObservers_();
          if (changesDetected) {
            this.refresh();
          }
        };
        ResizeObserverController2.prototype.updateObservers_ = function() {
          var activeObservers = this.observers_.filter(function(observer) {
            return observer.gatherActive(), observer.hasActive();
          });
          activeObservers.forEach(function(observer) {
            return observer.broadcastActive();
          });
          return activeObservers.length > 0;
        };
        ResizeObserverController2.prototype.connect_ = function() {
          if (!isBrowser || this.connected_) {
            return;
          }
          document.addEventListener("transitionend", this.onTransitionEnd_);
          window.addEventListener("resize", this.refresh);
          if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          } else {
            document.addEventListener("DOMSubtreeModified", this.refresh);
            this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
        };
        ResizeObserverController2.prototype.disconnect_ = function() {
          if (!isBrowser || !this.connected_) {
            return;
          }
          document.removeEventListener("transitionend", this.onTransitionEnd_);
          window.removeEventListener("resize", this.refresh);
          if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
            document.removeEventListener("DOMSubtreeModified", this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
        };
        ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
          var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
          var isReflowProperty = transitionKeys.some(function(key) {
            return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
            this.refresh();
          }
        };
        ResizeObserverController2.getInstance = function() {
          if (!this.instance_) {
            this.instance_ = new ResizeObserverController2();
          }
          return this.instance_;
        };
        ResizeObserverController2.instance_ = null;
        return ResizeObserverController2;
      }()
    );
    var defineConfigurable = function(target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
          value: props[key],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }
      return target;
    };
    var getWindowOf = function(target) {
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      return ownerGlobal || global$1;
    };
    var emptyRect = createRectInit(0, 0, 0, 0);
    function toFloat(value) {
      return parseFloat(value) || 0;
    }
    function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function(size, position2) {
        var value = styles["border-" + position2 + "-width"];
        return size + toFloat(value);
      }, 0);
    }
    function getPaddings(styles) {
      var positions = ["top", "right", "bottom", "left"];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position2 = positions_1[_i];
        var value = styles["padding-" + position2];
        paddings[position2] = toFloat(value);
      }
      return paddings;
    }
    function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
    }
    function getHTMLElementContentRect(target) {
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      if (!clientWidth && !clientHeight) {
        return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      var width = toFloat(styles.width), height = toFloat(styles.height);
      if (styles.boxSizing === "border-box") {
        if (Math.round(width + horizPad) !== clientWidth) {
          width -= getBordersSize(styles, "left", "right") + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
          height -= getBordersSize(styles, "top", "bottom") + vertPad;
        }
      }
      if (!isDocumentElement(target)) {
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        if (Math.abs(vertScrollbar) !== 1) {
          width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
          height -= horizScrollbar;
        }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
    }
    var isSVGGraphicsElement = function() {
      if (typeof SVGGraphicsElement !== "undefined") {
        return function(target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      }
      return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
      };
    }();
    function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
    }
    function getContentRect(target) {
      if (!isBrowser) {
        return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
    }
    function createReadOnlyRect(_a) {
      var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
      var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      defineConfigurable(rect, {
        x: x2,
        y: y2,
        width,
        height,
        top: y2,
        right: x2 + width,
        bottom: height + y2,
        left: x2
      });
      return rect;
    }
    function createRectInit(x2, y2, width, height) {
      return { x: x2, y: y2, width, height };
    }
    var ResizeObservation = (
      /** @class */
      function() {
        function ResizeObservation2(target) {
          this.broadcastWidth = 0;
          this.broadcastHeight = 0;
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
        }
        ResizeObservation2.prototype.isActive = function() {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
        };
        ResizeObservation2.prototype.broadcastRect = function() {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
        };
        return ResizeObservation2;
      }()
    );
    var ResizeObserverEntry = (
      /** @class */
      function() {
        function ResizeObserverEntry2(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          defineConfigurable(this, { target, contentRect });
        }
        return ResizeObserverEntry2;
      }()
    );
    var ResizeObserverSPI = (
      /** @class */
      function() {
        function ResizeObserverSPI2(callback, controller, callbackCtx) {
          this.activeObservations_ = [];
          this.observations_ = new MapShim();
          if (typeof callback !== "function") {
            throw new TypeError("The callback provided as parameter 1 is not a function.");
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
        }
        ResizeObserverSPI2.prototype.observe = function(target) {
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          if (typeof Element === "undefined" || !(Element instanceof Object)) {
            return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          if (observations.has(target)) {
            return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          this.controller_.refresh();
        };
        ResizeObserverSPI2.prototype.unobserve = function(target) {
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          if (typeof Element === "undefined" || !(Element instanceof Object)) {
            return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          if (!observations.has(target)) {
            return;
          }
          observations.delete(target);
          if (!observations.size) {
            this.controller_.removeObserver(this);
          }
        };
        ResizeObserverSPI2.prototype.disconnect = function() {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
        };
        ResizeObserverSPI2.prototype.gatherActive = function() {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function(observation) {
            if (observation.isActive()) {
              _this.activeObservations_.push(observation);
            }
          });
        };
        ResizeObserverSPI2.prototype.broadcastActive = function() {
          if (!this.hasActive()) {
            return;
          }
          var ctx = this.callbackCtx_;
          var entries = this.activeObservations_.map(function(observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
        };
        ResizeObserverSPI2.prototype.clearActive = function() {
          this.activeObservations_.splice(0);
        };
        ResizeObserverSPI2.prototype.hasActive = function() {
          return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI2;
      }()
    );
    var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
    var ResizeObserver$2 = (
      /** @class */
      function() {
        function ResizeObserver2(callback) {
          if (!(this instanceof ResizeObserver2)) {
            throw new TypeError("Cannot call a class as a function.");
          }
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
        }
        return ResizeObserver2;
      }()
    );
    [
      "observe",
      "unobserve",
      "disconnect"
    ].forEach(function(method2) {
      ResizeObserver$2.prototype[method2] = function() {
        var _a;
        return (_a = observers.get(this))[method2].apply(_a, arguments);
      };
    });
    var index = function() {
      if (typeof global$1.ResizeObserver !== "undefined") {
        return global$1.ResizeObserver;
      }
      return ResizeObserver$2;
    }();
    var elementListeners = /* @__PURE__ */ new Map();
    function onResize(entities) {
      entities.forEach(function(entity) {
        var _elementListeners$get;
        var target = entity.target;
        (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
          return listener(target);
        });
      });
    }
    var resizeObserver = new index(onResize);
    function observe(element, callback) {
      if (!elementListeners.has(element)) {
        elementListeners.set(element, /* @__PURE__ */ new Set());
        resizeObserver.observe(element);
      }
      elementListeners.get(element).add(callback);
    }
    function unobserve(element, callback) {
      if (elementListeners.has(element)) {
        elementListeners.get(element).delete(callback);
        if (!elementListeners.get(element).size) {
          resizeObserver.unobserve(element);
          elementListeners.delete(element);
        }
      }
    }
    var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
      _inherits$a(DomWrapper2, _React$Component);
      var _super = _createSuper(DomWrapper2);
      function DomWrapper2() {
        _classCallCheck$a(this, DomWrapper2);
        return _super.apply(this, arguments);
      }
      _createClass$8(DomWrapper2, [{
        key: "render",
        value: function render2() {
          return this.props.children;
        }
      }]);
      return DomWrapper2;
    }(reactExports.Component);
    var CollectionContext = /* @__PURE__ */ reactExports.createContext(null);
    function Collection(_ref) {
      var children = _ref.children, onBatchResize = _ref.onBatchResize;
      var resizeIdRef = reactExports.useRef(0);
      var resizeInfosRef = reactExports.useRef([]);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var onResize2 = reactExports.useCallback(function(size, element, data) {
        resizeIdRef.current += 1;
        var currentId = resizeIdRef.current;
        resizeInfosRef.current.push({
          size,
          element,
          data
        });
        Promise.resolve().then(function() {
          if (currentId === resizeIdRef.current) {
            onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
            resizeInfosRef.current = [];
          }
        });
        onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data);
      }, [onBatchResize, onCollectionResize]);
      return /* @__PURE__ */ reactExports.createElement(CollectionContext.Provider, {
        value: onResize2
      }, children);
    }
    function SingleObserver(props, ref) {
      var children = props.children, disabled = props.disabled;
      var elementRef = reactExports.useRef(null);
      var wrapperRef = reactExports.useRef(null);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var isRenderProps = typeof children === "function";
      var mergedChildren = isRenderProps ? children(elementRef) : children;
      var sizeRef = reactExports.useRef({
        width: -1,
        height: -1,
        offsetWidth: -1,
        offsetHeight: -1
      });
      var canRef = !isRenderProps && /* @__PURE__ */ reactExports.isValidElement(mergedChildren) && supportRef(mergedChildren);
      var originRef = canRef ? mergedChildren.ref : null;
      var mergedRef = reactExports.useMemo(function() {
        return composeRef(originRef, elementRef);
      }, [originRef, elementRef]);
      var getDom = function getDom2() {
        return findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
      };
      reactExports.useImperativeHandle(ref, function() {
        return getDom();
      });
      var propsRef = reactExports.useRef(props);
      propsRef.current = props;
      var onInternalResize = reactExports.useCallback(function(target) {
        var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;
        var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
        var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
        var fixedWidth = Math.floor(width);
        var fixedHeight = Math.floor(height);
        if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
          var size = {
            width: fixedWidth,
            height: fixedHeight,
            offsetWidth,
            offsetHeight
          };
          sizeRef.current = size;
          var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
          var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
          var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
            offsetWidth: mergedOffsetWidth,
            offsetHeight: mergedOffsetHeight
          });
          onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data);
          if (onResize2) {
            Promise.resolve().then(function() {
              onResize2(sizeInfo, target);
            });
          }
        }
      }, []);
      reactExports.useEffect(function() {
        var currentElement = getDom();
        if (currentElement && !disabled) {
          observe(currentElement, onInternalResize);
        }
        return function() {
          return unobserve(currentElement, onInternalResize);
        };
      }, [elementRef.current, disabled]);
      return /* @__PURE__ */ reactExports.createElement(DomWrapper$1, {
        ref: wrapperRef
      }, canRef ? /* @__PURE__ */ reactExports.cloneElement(mergedChildren, {
        ref: mergedRef
      }) : mergedChildren);
    }
    var RefSingleObserver = /* @__PURE__ */ reactExports.forwardRef(SingleObserver);
    var INTERNAL_PREFIX_KEY = "rc-observer-key";
    function ResizeObserver$1(props, ref) {
      var children = props.children;
      var childNodes = typeof children === "function" ? [children] : toArray$2(children);
      return childNodes.map(function(child, index2) {
        var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
        return /* @__PURE__ */ reactExports.createElement(RefSingleObserver, _extends$g({}, props, {
          key,
          ref: index2 === 0 ? ref : void 0
        }), child);
      });
    }
    var RefResizeObserver = /* @__PURE__ */ reactExports.forwardRef(ResizeObserver$1);
    RefResizeObserver.Collection = Collection;
    function omit(obj, fields) {
      var clone = _objectSpread2({}, obj);
      if (Array.isArray(fields)) {
        fields.forEach(function(key) {
          delete clone[key];
        });
      }
      return clone;
    }
    function _arrayLikeToArray(arr, len2) {
      if (len2 == null || len2 > arr.length)
        len2 = arr.length;
      for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function murmur2(str) {
      var h2 = 0;
      var k2, i2 = 0, len2 = str.length;
      for (; len2 >= 4; ++i2, len2 -= 4) {
        k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len2) {
        case 3:
          h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i2) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties$2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function isEqual(obj1, obj2) {
      var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var refSet = /* @__PURE__ */ new Set();
      function deepEqual(a, b2) {
        var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var circular = refSet.has(a);
        warningOnce(!circular, "Warning: There may be circular references");
        if (circular) {
          return false;
        }
        if (a === b2) {
          return true;
        }
        if (shallow && level > 1) {
          return false;
        }
        refSet.add(a);
        var newLevel = level + 1;
        if (Array.isArray(a)) {
          if (!Array.isArray(b2) || a.length !== b2.length) {
            return false;
          }
          for (var i2 = 0; i2 < a.length; i2++) {
            if (!deepEqual(a[i2], b2[i2], newLevel)) {
              return false;
            }
          }
          return true;
        }
        if (a && b2 && _typeof$1(a) === "object" && _typeof$1(b2) === "object") {
          var keys2 = Object.keys(a);
          if (keys2.length !== Object.keys(b2).length) {
            return false;
          }
          return keys2.every(function(key) {
            return deepEqual(a[key], b2[key], newLevel);
          });
        }
        return false;
      }
      return deepEqual(obj1, obj2);
    }
    var Entity = /* @__PURE__ */ function() {
      function Entity2() {
        _classCallCheck$a(this, Entity2);
        _defineProperty$2(this, "cache", /* @__PURE__ */ new Map());
      }
      _createClass$8(Entity2, [{
        key: "get",
        value: function get2(keys2) {
          return this.cache.get(keys2.join("%")) || null;
        }
      }, {
        key: "update",
        value: function update(keys2, valueFn) {
          var path = keys2.join("%");
          var prevValue = this.cache.get(path);
          var nextValue = valueFn(prevValue);
          if (nextValue === null) {
            this.cache.delete(path);
          } else {
            this.cache.set(path, nextValue);
          }
        }
      }]);
      return Entity2;
    }();
    var ATTR_TOKEN = "data-token-hash";
    var ATTR_MARK = "data-css-hash";
    var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
    var CSS_IN_JS_INSTANCE_ID = Math.random().toString(12).slice(2);
    function createCache() {
      if (typeof document !== "undefined" && document.head && document.body) {
        var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
        var firstChild = document.head.firstChild;
        Array.from(styles).forEach(function(style2) {
          style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || CSS_IN_JS_INSTANCE_ID;
          document.head.insertBefore(style2, firstChild);
        });
        var styleHash = {};
        Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
          var hash = style2.getAttribute(ATTR_MARK);
          if (styleHash[hash]) {
            if (style2[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
              var _style$parentNode;
              (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
            }
          } else {
            styleHash[hash] = true;
          }
        });
      }
      return new Entity();
    }
    var StyleContext = /* @__PURE__ */ reactExports.createContext({
      hashPriority: "low",
      cache: createCache(),
      defaultCache: true
    });
    const StyleContext$1 = StyleContext;
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i2) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
      var _React$useContext = reactExports.useContext(StyleContext$1), globalCache = _React$useContext.cache;
      var fullPath = [prefix].concat(_toConsumableArray(keyPath));
      reactExports.useMemo(
        function() {
          globalCache.update(fullPath, function(prevCache) {
            var _ref = prevCache || [], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
            var tmpCache = cache;
            var mergedCache = tmpCache || cacheFn();
            return [times + 1, mergedCache];
          });
        },
        /* eslint-disable react-hooks/exhaustive-deps */
        [fullPath.join("_")]
        /* eslint-enable */
      );
      reactExports.useEffect(function() {
        return function() {
          globalCache.update(fullPath, function(prevCache) {
            var _ref3 = prevCache || [], _ref4 = _slicedToArray(_ref3, 2), _ref4$ = _ref4[0], times = _ref4$ === void 0 ? 0 : _ref4$, cache = _ref4[1];
            var nextCount = times - 1;
            if (nextCount === 0) {
              onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache, false);
              return null;
            }
            return [times - 1, cache];
          });
        };
      }, fullPath);
      return globalCache.get(fullPath)[1];
    }
    function canUseDom() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }
    function contains(root2, n2) {
      if (!root2) {
        return false;
      }
      if (root2.contains) {
        return root2.contains(n2);
      }
      var node2 = n2;
      while (node2) {
        if (node2 === root2) {
          return true;
        }
        node2 = node2.parentNode;
      }
      return false;
    }
    var APPEND_ORDER = "data-rc-order";
    var MARK_KEY = "rc-util-key";
    var containerCache = /* @__PURE__ */ new Map();
    function getMark() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
      if (mark) {
        return mark.startsWith("data-") ? mark : "data-".concat(mark);
      }
      return MARK_KEY;
    }
    function getContainer(option) {
      if (option.attachTo) {
        return option.attachTo;
      }
      var head = document.querySelector("head");
      return head || document.body;
    }
    function getOrder(prepend) {
      if (prepend === "queue") {
        return "prependQueue";
      }
      return prepend ? "prepend" : "append";
    }
    function findStyles(container) {
      return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
        return node2.tagName === "STYLE";
      });
    }
    function injectCSS(css) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!canUseDom()) {
        return null;
      }
      var csp = option.csp, prepend = option.prepend;
      var styleNode = document.createElement("style");
      styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
      if (csp !== null && csp !== void 0 && csp.nonce) {
        styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
      }
      styleNode.innerHTML = css;
      var container = getContainer(option);
      var firstChild = container.firstChild;
      if (prepend) {
        if (prepend === "queue") {
          var existStyle = findStyles(container).filter(function(node2) {
            return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
          });
          if (existStyle.length) {
            container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
            return styleNode;
          }
        }
        container.insertBefore(styleNode, firstChild);
      } else {
        container.appendChild(styleNode);
      }
      return styleNode;
    }
    function findExistNode(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var container = getContainer(option);
      return findStyles(container).find(function(node2) {
        return node2.getAttribute(getMark(option)) === key;
      });
    }
    function removeCSS(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var existNode = findExistNode(key, option);
      if (existNode) {
        var container = getContainer(option);
        container.removeChild(existNode);
      }
    }
    function syncRealContainer(container, option) {
      var cachedRealContainer = containerCache.get(container);
      if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
        var placeholderStyle = injectCSS("", option);
        var parentNode = placeholderStyle.parentNode;
        containerCache.set(container, parentNode);
        container.removeChild(placeholderStyle);
      }
    }
    function updateCSS(css, key) {
      var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var container = getContainer(option);
      syncRealContainer(container, option);
      var existNode = findExistNode(key, option);
      if (existNode) {
        var _option$csp, _option$csp2;
        if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
          var _option$csp3;
          existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
        }
        if (existNode.innerHTML !== css) {
          existNode.innerHTML = css;
        }
        return existNode;
      }
      var newNode = injectCSS(css, option);
      newNode.setAttribute(getMark(option), key);
      return newNode;
    }
    function flattenToken(token2) {
      var str = "";
      Object.keys(token2).forEach(function(key) {
        var value = token2[key];
        str += key;
        if (value && _typeof$1(value) === "object") {
          str += flattenToken(value);
        } else {
          str += value;
        }
      });
      return str;
    }
    function token2key(token2, salt) {
      return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
    }
    var layerKey = "layer-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
    var layerWidth = "903px";
    function supportSelector(styleStr, handleElement) {
      if (canUseDom()) {
        var _ele$parentNode;
        updateCSS(styleStr, layerKey);
        var _ele = document.createElement("div");
        _ele.style.position = "fixed";
        _ele.style.left = "0";
        _ele.style.top = "0";
        handleElement === null || handleElement === void 0 ? void 0 : handleElement(_ele);
        document.body.appendChild(_ele);
        var support = getComputedStyle(_ele).width === layerWidth;
        (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 ? void 0 : _ele$parentNode.removeChild(_ele);
        removeCSS(layerKey);
        return support;
      }
      return false;
    }
    var canLayer = void 0;
    function supportLayer() {
      if (canLayer === void 0) {
        canLayer = supportSelector("@layer ".concat(layerKey, " { .").concat(layerKey, " { width: ").concat(layerWidth, "!important; } }"), function(ele) {
          ele.className = layerKey;
        });
      }
      return canLayer;
    }
    var EMPTY_OVERRIDE = {};
    var hashPrefix = "css";
    var tokenKeys = /* @__PURE__ */ new Map();
    function recordCleanToken(tokenKey) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
    }
    function removeStyleTags(key) {
      if (typeof document !== "undefined") {
        var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
        styles.forEach(function(style2) {
          if (style2[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
            var _style$parentNode;
            (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
          }
        });
      }
    }
    function cleanTokenStyle(tokenKey) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
      var tokenKeyList = Array.from(tokenKeys.keys());
      var cleanableKeyList = tokenKeyList.filter(function(key) {
        var count = tokenKeys.get(key) || 0;
        return count <= 0;
      });
      if (cleanableKeyList.length < tokenKeyList.length) {
        cleanableKeyList.forEach(function(key) {
          removeStyleTags(key);
          tokenKeys.delete(key);
        });
      }
    }
    function useCacheToken(theme2, tokens) {
      var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken;
      var mergedToken = reactExports.useMemo(function() {
        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
      }, [tokens]);
      var tokenStr = reactExports.useMemo(function() {
        return flattenToken(mergedToken);
      }, [mergedToken]);
      var overrideTokenStr = reactExports.useMemo(function() {
        return flattenToken(override);
      }, [override]);
      var cachedToken = useClientCache("token", [salt, theme2.id, tokenStr, overrideTokenStr], function() {
        var derivativeToken = theme2.getDerivativeToken(mergedToken);
        var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, derivativeToken), override);
        if (formatToken2) {
          mergedDerivativeToken = formatToken2(mergedDerivativeToken);
        }
        var tokenKey = token2key(mergedDerivativeToken, salt);
        mergedDerivativeToken._tokenKey = tokenKey;
        recordCleanToken(tokenKey);
        var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
        mergedDerivativeToken._hashId = hashId;
        return [mergedDerivativeToken, hashId];
      }, function(cache) {
        cleanTokenStyle(cache[0]._tokenKey);
      });
      return cachedToken;
    }
    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var IMPORT = "@import";
    var KEYFRAMES = "@keyframes";
    var abs = Math.abs;
    var from = String.fromCharCode;
    function trim(value) {
      return value.trim();
    }
    function replace(value, pattern2, replacement) {
      return value.replace(pattern2, replacement);
    }
    function indexof(value, search) {
      return value.indexOf(search);
    }
    function charat(value, index2) {
      return value.charCodeAt(index2) | 0;
    }
    function substr(value, begin, end) {
      return value.slice(begin, end);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array2) {
      return array2.push(value), value;
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position = 0;
    var character = 0;
    var characters = "";
    function node(value, root2, parent, type2, props, children, length2) {
      return { value, root: root2, parent, type: type2, props, children, line, column, length: length2, return: "" };
    }
    function char() {
      return character;
    }
    function prev() {
      character = position > 0 ? charat(characters, --position) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position < length ? charat(characters, position++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position);
    }
    function caret() {
      return position;
    }
    function slice(begin, end) {
      return substr(characters, begin, end);
    }
    function token(type2) {
      switch (type2) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type2) {
      return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
    }
    function whitespace$1(type2) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token(type2) > 2 || token(character) > 3 ? "" : " ";
    }
    function escaping(index2, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type2) {
      while (next())
        switch (character) {
          case type2:
            return position;
          case 34:
          case 39:
            if (type2 !== 34 && type2 !== 39)
              delimiter(character);
            break;
          case 40:
            if (type2 === 41)
              delimiter(type2);
            break;
          case 92:
            next();
            break;
        }
      return position;
    }
    function commenter(type2, index2) {
      while (next())
        if (type2 + character === 47 + 10)
          break;
        else if (type2 + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice(index2, position - 1) + "*" + from(type2 === 47 ? type2 : next());
    }
    function identifier(index2) {
      while (!token(peek()))
        next();
      return slice(index2, position);
    }
    function compile(value) {
      return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
      var index2 = 0;
      var offset = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property2 = 0;
      var previous = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type2 = "";
      var props = rules2;
      var children = rulesets;
      var reference = rule;
      var characters2 = type2;
      while (scanning)
        switch (previous = character2, character2 = next()) {
          case 40:
            if (previous != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace$1(previous);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment(commenter(next(), caret()), root2, parent), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index2++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset:
                if (property2 > 0 && strlen(characters2) - length2)
                  append(property2 > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference = ruleset(characters2, root2, parent, index2, offset, rules2, points, type2, props = [], children = [], length2), rulesets);
                if (character2 === 123)
                  if (offset === 0)
                    parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 109:
                      case 115:
                        parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type2, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                        break;
                      default:
                        parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                    }
            }
            index2 = offset = property2 = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property2 = previous;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from(character2), character2 * variable) {
              case 38:
                ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root2, parent, index2, offset, rules2, points, type2, props, children, length2) {
      var post = offset - 1;
      var rule = offset === 0 ? rules2 : [""];
      var size = sizeof(rule);
      for (var i2 = 0, j = 0, k2 = 0; i2 < index2; ++i2)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i2])), z2 = value; x2 < size; ++x2)
          if (z2 = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node(value, root2, parent, offset === 0 ? RULESET : type2, props, children, length2);
    }
    function comment(value, root2, parent) {
      return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
    }
    function declaration(value, root2, parent, length2) {
      return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
    }
    function serialize(children, callback) {
      var output = "";
      var length2 = sizeof(children);
      for (var i2 = 0; i2 < length2; i2++)
        output += callback(children[i2], i2, children, callback) || "";
      return output;
    }
    function stringify$1(element, index2, children, callback) {
      switch (element.type) {
        case IMPORT:
        case DECLARATION:
          return element.return = element.return || element.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element.return = element.value + "{" + serialize(element.children, callback) + "}";
        case RULESET:
          element.value = element.props.join(",");
      }
      return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    var isClientSide = canUseDom();
    var SKIP_CHECK = "_skip_check_";
    function normalizeStyle(styleStr) {
      var serialized = serialize(compile(styleStr), stringify$1);
      return serialized.replace(/\{%%%\:[^;];}/g, ";");
    }
    function isCompoundCSSProperty(value) {
      return _typeof$1(value) === "object" && value && SKIP_CHECK in value;
    }
    function injectSelectorHash(key, hashId, hashPriority) {
      if (!hashId) {
        return key;
      }
      var hashClassName = ".".concat(hashId);
      var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
      var keys2 = key.split(",").map(function(k2) {
        var _firstPath$match;
        var fullPath = k2.trim().split(/\s+/);
        var firstPath = fullPath[0] || "";
        var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
        firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
        return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
      });
      return keys2.join(",");
    }
    var globalEffectStyleKeys = /* @__PURE__ */ new Set();
    var parseStyle = function parseStyle2(interpolation) {
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        root: true,
        parentSelectors: []
      }, root2 = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
      var hashId = config.hashId, layer = config.layer;
      config.path;
      var hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
      config.linters;
      var styleStr = "";
      var effectStyle = {};
      function parseKeyframes(keyframes) {
        var animationName = keyframes.getName(hashId);
        if (!effectStyle[animationName]) {
          var _parseStyle = parseStyle2(keyframes.style, config, {
            root: false,
            parentSelectors
          }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
          effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
        }
      }
      function flattenList(list) {
        var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        list.forEach(function(item) {
          if (Array.isArray(item)) {
            flattenList(item, fullList);
          } else if (item) {
            fullList.push(item);
          }
        });
        return fullList;
      }
      var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
      flattenStyleList.forEach(function(originStyle) {
        var style2 = typeof originStyle === "string" && !root2 ? {} : originStyle;
        if (typeof style2 === "string") {
          styleStr += "".concat(style2, "\n");
        } else if (style2._keyframe) {
          parseKeyframes(style2);
        } else {
          var mergedStyle = transformers.reduce(function(prev2, trans) {
            var _trans$visit;
            return (trans === null || trans === void 0 ? void 0 : (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
          }, style2);
          Object.keys(mergedStyle).forEach(function(key) {
            var value = mergedStyle[key];
            if (_typeof$1(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
              var subInjectHash = false;
              var mergedKey = key.trim();
              var nextRoot = false;
              if ((root2 || injectHash) && hashId) {
                if (mergedKey.startsWith("@")) {
                  subInjectHash = true;
                } else {
                  mergedKey = injectSelectorHash(key, hashId, hashPriority);
                }
              } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
                mergedKey = "";
                nextRoot = true;
              }
              var _parseStyle3 = parseStyle2(value, config, {
                root: nextRoot,
                injectHash: subInjectHash,
                parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
              }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
              effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle);
              styleStr += "".concat(mergedKey).concat(_parsedStr2);
            } else {
              var _value;
              var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
              var styleName = key.replace(/[A-Z]/g, function(match) {
                return "-".concat(match.toLowerCase());
              });
              var formatValue = actualValue;
              if (!unitlessKeys[key] && typeof formatValue === "number" && formatValue !== 0) {
                formatValue = "".concat(formatValue, "px");
              }
              if (key === "animationName" && value !== null && value !== void 0 && value._keyframe) {
                parseKeyframes(value);
                formatValue = value.getName(hashId);
              }
              styleStr += "".concat(styleName, ":").concat(formatValue, ";");
            }
          });
        }
      });
      if (!root2) {
        styleStr = "{".concat(styleStr, "}");
      } else if (layer && supportLayer()) {
        var layerCells = layer.split(",");
        var layerName = layerCells[layerCells.length - 1].trim();
        styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");
        if (layerCells.length > 1) {
          styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
        }
      }
      return [styleStr, effectStyle];
    };
    function uniqueHash(path, styleStr) {
      return murmur2("".concat(path.join("%")).concat(styleStr));
    }
    function Empty() {
      return null;
    }
    function useStyleRegister(info, styleFn) {
      var token2 = info.token, path = info.path, hashId = info.hashId, layer = info.layer;
      var _React$useContext = reactExports.useContext(StyleContext$1), autoClear = _React$useContext.autoClear;
      _React$useContext.mock;
      var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters;
      var tokenKey = token2._tokenKey;
      var fullPath = [tokenKey].concat(_toConsumableArray(path));
      var isMergedClientSide = isClientSide;
      var _useGlobalCache = useClientCache(
        "style",
        fullPath,
        // Create cache if needed
        function() {
          var styleObj = styleFn();
          var _parseStyle5 = parseStyle(styleObj, {
            hashId,
            hashPriority,
            layer,
            path: path.join("-"),
            transformers,
            linters
          }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
          var styleStr = normalizeStyle(parsedStyle);
          var styleId = uniqueHash(fullPath, styleStr);
          if (isMergedClientSide) {
            var style2 = updateCSS(styleStr, styleId, {
              mark: ATTR_MARK,
              prepend: "queue",
              attachTo: container
            });
            style2[CSS_IN_JS_INSTANCE] = CSS_IN_JS_INSTANCE_ID;
            style2.setAttribute(ATTR_TOKEN, tokenKey);
            Object.keys(effectStyle).forEach(function(effectKey) {
              if (!globalEffectStyleKeys.has(effectKey)) {
                globalEffectStyleKeys.add(effectKey);
                updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), {
                  mark: ATTR_MARK,
                  prepend: "queue",
                  attachTo: container
                });
              }
            });
          }
          return [styleStr, tokenKey, styleId];
        },
        // Remove cache if no need
        function(_ref2, fromHMR) {
          var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
          if ((fromHMR || autoClear) && isClientSide) {
            removeCSS(styleId, {
              mark: ATTR_MARK
            });
          }
        }
      ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
      return function(node2) {
        var styleNode;
        if (!ssrInline || isMergedClientSide || !defaultCache) {
          styleNode = /* @__PURE__ */ reactExports.createElement(Empty, null);
        } else {
          var _ref4;
          styleNode = /* @__PURE__ */ reactExports.createElement("style", _extends$g({}, (_ref4 = {}, _defineProperty$2(_ref4, ATTR_TOKEN, cachedTokenKey), _defineProperty$2(_ref4, ATTR_MARK, cachedStyleId), _ref4), {
            dangerouslySetInnerHTML: {
              __html: cachedStyleStr
            }
          }));
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, styleNode, node2);
      };
    }
    var Keyframe = /* @__PURE__ */ function() {
      function Keyframe2(name, style2) {
        _classCallCheck$a(this, Keyframe2);
        _defineProperty$2(this, "name", void 0);
        _defineProperty$2(this, "style", void 0);
        _defineProperty$2(this, "_keyframe", true);
        this.name = name;
        this.style = style2;
      }
      _createClass$8(Keyframe2, [{
        key: "getName",
        value: function getName() {
          var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
        }
      }]);
      return Keyframe2;
    }();
    function sameDerivativeOption(left, right) {
      if (left.length !== right.length) {
        return false;
      }
      for (var i2 = 0; i2 < left.length; i2++) {
        if (left[i2] !== right[i2]) {
          return false;
        }
      }
      return true;
    }
    var ThemeCache = /* @__PURE__ */ function() {
      function ThemeCache2() {
        _classCallCheck$a(this, ThemeCache2);
        _defineProperty$2(this, "cache", void 0);
        _defineProperty$2(this, "keys", void 0);
        _defineProperty$2(this, "cacheCallTimes", void 0);
        this.cache = /* @__PURE__ */ new Map();
        this.keys = [];
        this.cacheCallTimes = 0;
      }
      _createClass$8(ThemeCache2, [{
        key: "size",
        value: function size() {
          return this.keys.length;
        }
      }, {
        key: "internalGet",
        value: function internalGet(derivativeOption) {
          var _cache2, _cache3;
          var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var cache = {
            map: this.cache
          };
          derivativeOption.forEach(function(derivative2) {
            if (!cache) {
              cache = void 0;
            } else {
              var _cache, _cache$map;
              cache = (_cache = cache) === null || _cache === void 0 ? void 0 : (_cache$map = _cache.map) === null || _cache$map === void 0 ? void 0 : _cache$map.get(derivative2);
            }
          });
          if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
            cache.value[1] = this.cacheCallTimes++;
          }
          return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
        }
      }, {
        key: "get",
        value: function get2(derivativeOption) {
          var _this$internalGet;
          return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
        }
      }, {
        key: "has",
        value: function has(derivativeOption) {
          return !!this.internalGet(derivativeOption);
        }
      }, {
        key: "set",
        value: function set2(derivativeOption, value) {
          var _this = this;
          if (!this.has(derivativeOption)) {
            if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
              var _this$keys$reduce = this.keys.reduce(function(result, key) {
                var _result = _slicedToArray(result, 2), callTimes = _result[1];
                if (_this.internalGet(key)[1] < callTimes) {
                  return [key, _this.internalGet(key)[1]];
                }
                return result;
              }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
              this.delete(targetKey);
            }
            this.keys.push(derivativeOption);
          }
          var cache = this.cache;
          derivativeOption.forEach(function(derivative2, index2) {
            if (index2 === derivativeOption.length - 1) {
              cache.set(derivative2, {
                value: [value, _this.cacheCallTimes++]
              });
            } else {
              var cacheValue = cache.get(derivative2);
              if (!cacheValue) {
                cache.set(derivative2, {
                  map: /* @__PURE__ */ new Map()
                });
              } else if (!cacheValue.map) {
                cacheValue.map = /* @__PURE__ */ new Map();
              }
              cache = cache.get(derivative2).map;
            }
          });
        }
      }, {
        key: "deleteByPath",
        value: function deleteByPath(currentCache, derivatives) {
          var cache = currentCache.get(derivatives[0]);
          if (derivatives.length === 1) {
            var _cache$value;
            if (!cache.map) {
              currentCache.delete(derivatives[0]);
            } else {
              currentCache.set(derivatives[0], {
                map: cache.map
              });
            }
            return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
          }
          var result = this.deleteByPath(cache.map, derivatives.slice(1));
          if ((!cache.map || cache.map.size === 0) && !cache.value) {
            currentCache.delete(derivatives[0]);
          }
          return result;
        }
      }, {
        key: "delete",
        value: function _delete(derivativeOption) {
          if (this.has(derivativeOption)) {
            this.keys = this.keys.filter(function(item) {
              return !sameDerivativeOption(item, derivativeOption);
            });
            return this.deleteByPath(this.cache, derivativeOption);
          }
          return void 0;
        }
      }]);
      return ThemeCache2;
    }();
    _defineProperty$2(ThemeCache, "MAX_CACHE_SIZE", 20);
    _defineProperty$2(ThemeCache, "MAX_CACHE_OFFSET", 5);
    var uuid$2 = 0;
    var Theme = /* @__PURE__ */ function() {
      function Theme2(derivatives) {
        _classCallCheck$a(this, Theme2);
        _defineProperty$2(this, "derivatives", void 0);
        _defineProperty$2(this, "id", void 0);
        this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
        this.id = uuid$2;
        if (derivatives.length === 0) {
          warning$2(derivatives.length > 0);
        }
        uuid$2 += 1;
      }
      _createClass$8(Theme2, [{
        key: "getDerivativeToken",
        value: function getDerivativeToken(token2) {
          return this.derivatives.reduce(function(result, derivative2) {
            return derivative2(token2, result);
          }, void 0);
        }
      }]);
      return Theme2;
    }();
    var cacheThemes = new ThemeCache();
    function createTheme(derivatives) {
      var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
      if (!cacheThemes.has(derivativeArr)) {
        cacheThemes.set(derivativeArr, new Theme(derivativeArr));
      }
      return cacheThemes.get(derivativeArr);
    }
    function noSplit(list) {
      list.notSplit = true;
      return list;
    }
    ({
      // Inset
      inset: ["top", "right", "bottom", "left"],
      insetBlock: ["top", "bottom"],
      insetBlockStart: ["top"],
      insetBlockEnd: ["bottom"],
      insetInline: ["left", "right"],
      insetInlineStart: ["left"],
      insetInlineEnd: ["right"],
      // Margin
      marginBlock: ["marginTop", "marginBottom"],
      marginBlockStart: ["marginTop"],
      marginBlockEnd: ["marginBottom"],
      marginInline: ["marginLeft", "marginRight"],
      marginInlineStart: ["marginLeft"],
      marginInlineEnd: ["marginRight"],
      // Padding
      paddingBlock: ["paddingTop", "paddingBottom"],
      paddingBlockStart: ["paddingTop"],
      paddingBlockEnd: ["paddingBottom"],
      paddingInline: ["paddingLeft", "paddingRight"],
      paddingInlineStart: ["paddingLeft"],
      paddingInlineEnd: ["paddingRight"],
      // Border
      borderBlock: noSplit(["borderTop", "borderBottom"]),
      borderBlockStart: noSplit(["borderTop"]),
      borderBlockEnd: noSplit(["borderBottom"]),
      borderInline: noSplit(["borderLeft", "borderRight"]),
      borderInlineStart: noSplit(["borderLeft"]),
      borderInlineEnd: noSplit(["borderRight"]),
      // Border width
      borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
      borderBlockStartWidth: ["borderTopWidth"],
      borderBlockEndWidth: ["borderBottomWidth"],
      borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
      borderInlineStartWidth: ["borderLeftWidth"],
      borderInlineEndWidth: ["borderRightWidth"],
      // Border style
      borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
      borderBlockStartStyle: ["borderTopStyle"],
      borderBlockEndStyle: ["borderBottomStyle"],
      borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
      borderInlineStartStyle: ["borderLeftStyle"],
      borderInlineEndStyle: ["borderRightStyle"],
      // Border color
      borderBlockColor: ["borderTopColor", "borderBottomColor"],
      borderBlockStartColor: ["borderTopColor"],
      borderBlockEndColor: ["borderBottomColor"],
      borderInlineColor: ["borderLeftColor", "borderRightColor"],
      borderInlineStartColor: ["borderLeftColor"],
      borderInlineEndColor: ["borderRightColor"],
      // Border radius
      borderStartStartRadius: ["borderTopLeftRadius"],
      borderStartEndRadius: ["borderTopRightRadius"],
      borderEndStartRadius: ["borderBottomLeftRadius"],
      borderEndEndRadius: ["borderBottomRightRadius"]
    });
    var IconContext = /* @__PURE__ */ reactExports.createContext({});
    const Context$1 = IconContext;
    var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
    var warningFunc = function warningFunc2() {
      warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
    };
    var Context = /* @__PURE__ */ reactExports.createContext({
      getFieldValue: warningFunc,
      getFieldsValue: warningFunc,
      getFieldError: warningFunc,
      getFieldWarning: warningFunc,
      getFieldsError: warningFunc,
      isFieldsTouched: warningFunc,
      isFieldTouched: warningFunc,
      isFieldValidating: warningFunc,
      isFieldsValidating: warningFunc,
      resetFields: warningFunc,
      setFields: warningFunc,
      setFieldValue: warningFunc,
      setFieldsValue: warningFunc,
      validateFields: warningFunc,
      submit: warningFunc,
      getInternalHooks: function getInternalHooks() {
        warningFunc();
        return {
          dispatch: warningFunc,
          initEntityValue: warningFunc,
          registerField: warningFunc,
          useSubscribe: warningFunc,
          setInitialValues: warningFunc,
          destroyForm: warningFunc,
          setCallbacks: warningFunc,
          registerWatch: warningFunc,
          getFields: warningFunc,
          setValidateMessages: warningFunc,
          setPreserve: warningFunc,
          getInitialValue: warningFunc
        };
      }
    });
    function toArray$1(value) {
      if (value === void 0 || value === null) {
        return [];
      }
      return Array.isArray(value) ? value : [value];
    }
    function _regeneratorRuntime() {
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports2;
      };
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty2 = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function define3(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context2(tryLocsList || []);
        return defineProperty2(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method2) {
          define2(prototype, method2, function(arg) {
            return this._invoke(method2, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method2, arg, resolve, reject) {
          var record = tryCatch(generator[method2], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty2(this, "_invoke", {
          value: function value(method2, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method2, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method2, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method2)
              throw arg;
            return doneResult();
          }
          for (context.method = method2, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method2 = delegate.iterator[methodName];
        if (void 0 === method2)
          return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method2, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context2(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i2 = -1, next2 = function next3() {
              for (; ++i2 < iterable.length; )
                if (hasOwn.call(iterable, i2))
                  return next3.value = iterable[i2], next3.done = false, next3;
              return next3.value = void 0, next3.done = true, next3;
            };
            return next2.next = next2;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty2(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
        return this;
      }), define2(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object2 = Object(val), keys2 = [];
        for (var key in object2)
          keys2.push(key);
        return keys2.reverse(), function next2() {
          for (; keys2.length; ) {
            var key2 = keys2.pop();
            if (key2 in object2)
              return next2.value = key2, next2.done = false, next2;
          }
          return next2.done = true, next2;
        };
      }, exports2.values = values, Context2.prototype = {
        constructor: Context2,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type2, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type2, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function _extends$f() {
      _extends$f = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$f.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning$1 = function warning2() {
    };
    if (typeof process !== "undefined" && process.env && false) {
      warning$1 = function warning2(type2, errors2) {
        if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
          if (errors2.every(function(e2) {
            return typeof e2 === "string";
          })) {
            console.warn(type2, errors2);
          }
        }
      };
    }
    function convertFieldsError(errors2) {
      if (!errors2 || !errors2.length)
        return null;
      var fields = {};
      errors2.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format$1(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i2 = 0;
      var len2 = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x2) {
          if (x2 === "%%") {
            return "%";
          }
          if (i2 >= len2) {
            return x2;
          }
          switch (x2) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x2;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type2) {
      return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
    }
    function isEmptyValue(value, type2) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type2 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type2) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors2) {
        results.push.apply(results, errors2 || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index2 = 0;
      var arrLength = arr.length;
      function next2(errors2) {
        if (errors2 && errors2.length) {
          callback(errors2);
          return;
        }
        var original = index2;
        index2 = index2 + 1;
        if (original < arrLength) {
          func(arr[original], next2);
        } else {
          callback([]);
        }
      }
      next2([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k2) {
        ret.push.apply(ret, objArr[k2] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors2, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors2;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve, reject) {
          var next2 = function next3(errors2) {
            callback(errors2);
            return errors2.length ? reject(new AsyncValidationError(errors2, convertFieldsError(errors2))) : resolve(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next2);
        });
        _pending["catch"](function(e2) {
          return e2;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve, reject) {
        var next2 = function next3(errors2) {
          results.push.apply(results, errors2);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next2);
          } else {
            asyncParallelArray(arr, func, next2);
          }
        });
      });
      pending["catch"](function(e2) {
        return e2;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue$5(value, path) {
      var v2 = value;
      for (var i2 = 0; i2 < path.length; i2++) {
        if (v2 == void 0) {
          return v2;
        }
        v2 = v2[path[i2]];
      }
      return v2;
    }
    function complementError(rule, source) {
      return function(oe2) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue$5(source, rule.fullFields);
        } else {
          fieldValue = source[oe2.field || rule.fullField];
        }
        if (isErrorObj(oe2)) {
          oe2.field = oe2.field || rule.fullField;
          oe2.fieldValue = fieldValue;
          return oe2;
        }
        return {
          message: typeof oe2 === "function" ? oe2() : oe2,
          fieldValue,
          field: oe2.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends$f({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required2(rule, value, source, errors2, options, type2) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
        errors2.push(format$1(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors2, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors2.push(format$1(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b2 = function b3(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip = function ip2(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
      };
      ip.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
      };
      ip.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer2(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array2(value) {
        return Array.isArray(value);
      },
      regexp: function regexp2(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e2) {
          return false;
        }
      },
      date: function date2(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number2(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object2(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method2(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type2(rule, value, source, errors2, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors2, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors2.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors2.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors2, options) {
      var len2 = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len2) {
        if (val !== rule.len) {
          errors2.push(format$1(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors2.push(format$1(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors2.push(format$1(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors2.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable2(rule, value, source, errors2, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors2.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern2(rule, value, source, errors2, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors2.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors2.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors2, options);
          rules.range(rule, value, source, errors2, options);
          rules.pattern(rule, value, source, errors2, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors2, options);
          }
        }
      }
      callback(errors2);
    };
    var method = function method2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var number = function number2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors2, options);
          rules.range(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var regexp = function regexp2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var integer = function integer2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors2, options);
          rules.range(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors2, options);
          rules.range(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var array = function array2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors2, options);
          rules.range(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var object = function object2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var ENUM = "enum";
    var enumerable = function enumerable2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var pattern = function pattern2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var date = function date2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors2, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors2, options);
          }
        }
      }
      callback(errors2);
    };
    var required = function required2(rule, value, callback, source, options) {
      var errors2 = [];
      var type2 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors2, options, type2);
      callback(errors2);
    };
    var type = function type2(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors2, options);
        }
      }
      callback(errors2);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors2 = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors2, options);
      }
      callback(errors2);
    };
    var validators = {
      string,
      method,
      number,
      "boolean": _boolean,
      regexp,
      integer,
      "float": floatFn,
      array,
      object,
      "enum": enumerable,
      pattern,
      date,
      url: type,
      hex: type,
      email: type,
      required,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define2(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o, oc2) {
        var _this2 = this;
        if (o === void 0) {
          o = {};
        }
        if (oc2 === void 0) {
          oc2 = function oc3() {
          };
        }
        var source = source_;
        var options = o;
        var callback = oc2;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors2 = [];
          var fields = {};
          function add(e2) {
            if (Array.isArray(e2)) {
              var _errors;
              errors2 = (_errors = errors2).concat.apply(_errors, e2);
            } else {
              errors2.push(e2);
            }
          }
          for (var i2 = 0; i2 < results.length; i2++) {
            add(results[i2]);
          }
          if (!errors2.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors2);
            callback(errors2, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z2) {
          var arr = _this2.rules[z2];
          var value = source[z2];
          arr.forEach(function(r2) {
            var rule = r2;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends$f({}, source);
              }
              value = source[z2] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends$f({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z2;
            rule.fullField = rule.fullField || z2;
            rule.type = _this2.getType(rule);
            series[z2] = series[z2] || [];
            series[z2].push({
              rule,
              value,
              source,
              field: z2
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema2) {
            return _extends$f({}, schema2, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb2(e2) {
            if (e2 === void 0) {
              e2 = [];
            }
            var errorList = Array.isArray(e2) ? e2 : [e2];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends$f({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema2 = new Schema2(paredFieldsSchema);
              schema2.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema2.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb2, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb2, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb2(error.message);
            }
            if (res === true) {
              cb2();
            } else if (res === false) {
              cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb2(res);
            } else if (res instanceof Error) {
              cb2(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb2();
            }, function(e2) {
              return cb2(e2);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format$1("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type2, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type2] = validator;
    };
    Schema.warning = warning$1;
    Schema.messages = messages;
    Schema.validators = validators;
    var typeTemplate$1 = "'${name}' is not a valid ${type}";
    var defaultValidateMessages = {
      default: "Validation error on field '${name}'",
      required: "'${name}' is required",
      enum: "'${name}' must be one of [${enum}]",
      whitespace: "'${name}' cannot be empty",
      date: {
        format: "'${name}' is invalid for format date",
        parse: "'${name}' could not be parsed as date",
        invalid: "'${name}' is invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "'${name}' must be exactly ${len} characters",
        min: "'${name}' must be at least ${min} characters",
        max: "'${name}' cannot be longer than ${max} characters",
        range: "'${name}' must be between ${min} and ${max} characters"
      },
      number: {
        len: "'${name}' must equal ${len}",
        min: "'${name}' cannot be less than ${min}",
        max: "'${name}' cannot be greater than ${max}",
        range: "'${name}' must be between ${min} and ${max}"
      },
      array: {
        len: "'${name}' must be exactly ${len} in length",
        min: "'${name}' cannot be less than ${min} in length",
        max: "'${name}' cannot be greater than ${max} in length",
        range: "'${name}' must be between ${min} and ${max} in length"
      },
      pattern: {
        mismatch: "'${name}' does not match pattern ${pattern}"
      }
    };
    function get$4(entity, path) {
      var current = entity;
      for (var i2 = 0; i2 < path.length; i2 += 1) {
        if (current === null || current === void 0) {
          return void 0;
        }
        current = current[path[i2]];
      }
      return current;
    }
    function _toArray(arr) {
      return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
    }
    function internalSet(entity, paths, value, removeIfUndefined) {
      if (!paths.length) {
        return value;
      }
      var _paths = _toArray(paths), path = _paths[0], restPath = _paths.slice(1);
      var clone;
      if (!entity && typeof path === "number") {
        clone = [];
      } else if (Array.isArray(entity)) {
        clone = _toConsumableArray(entity);
      } else {
        clone = _objectSpread2({}, entity);
      }
      if (removeIfUndefined && value === void 0 && restPath.length === 1) {
        delete clone[path][restPath[0]];
      } else {
        clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
      }
      return clone;
    }
    function set(entity, paths, value) {
      var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (paths.length && removeIfUndefined && value === void 0 && !get$4(entity, paths.slice(0, -1))) {
        return entity;
      }
      return internalSet(entity, paths, value, removeIfUndefined);
    }
    function cloneDeep$1(val) {
      if (Array.isArray(val)) {
        return cloneArrayDeep(val);
      } else if (_typeof$1(val) === "object" && val !== null) {
        return cloneObjectDeep(val);
      }
      return val;
    }
    function cloneObjectDeep(val) {
      if (Object.getPrototypeOf(val) === Object.prototype) {
        var res = {};
        for (var key in val) {
          res[key] = cloneDeep$1(val[key]);
        }
        return res;
      }
      return val;
    }
    function cloneArrayDeep(val) {
      return val.map(function(item) {
        return cloneDeep$1(item);
      });
    }
    function getNamePath(path) {
      return toArray$1(path);
    }
    function getValue$4(store, namePath) {
      var value = get$4(store, namePath);
      return value;
    }
    function setValue(store, namePath, value) {
      var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var newStore = set(store, namePath, value, removeIfUndefined);
      return newStore;
    }
    function cloneByNamePathList(store, namePathList) {
      var newStore = {};
      namePathList.forEach(function(namePath) {
        var value = getValue$4(store, namePath);
        newStore = setValue(newStore, namePath, value);
      });
      return newStore;
    }
    function containsNamePath(namePathList, namePath) {
      return namePathList && namePathList.some(function(path) {
        return matchNamePath(path, namePath);
      });
    }
    function isObject$8(obj) {
      return _typeof$1(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
    }
    function internalSetValues(store, values) {
      var newStore = Array.isArray(store) ? _toConsumableArray(store) : _objectSpread2({}, store);
      if (!values) {
        return newStore;
      }
      Object.keys(values).forEach(function(key) {
        var prevValue = newStore[key];
        var value = values[key];
        var recursive = isObject$8(prevValue) && isObject$8(value);
        newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : cloneDeep$1(value);
      });
      return newStore;
    }
    function setValues(store) {
      for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        restValues[_key - 1] = arguments[_key];
      }
      return restValues.reduce(function(current, newStore) {
        return internalSetValues(current, newStore);
      }, store);
    }
    function matchNamePath(namePath, changedNamePath) {
      if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
        return false;
      }
      return namePath.every(function(nameUnit, i2) {
        return changedNamePath[i2] === nameUnit;
      });
    }
    function isSimilar(source, target) {
      if (source === target) {
        return true;
      }
      if (!source && target || source && !target) {
        return false;
      }
      if (!source || !target || _typeof$1(source) !== "object" || _typeof$1(target) !== "object") {
        return false;
      }
      var sourceKeys = Object.keys(source);
      var targetKeys = Object.keys(target);
      var keys2 = new Set([].concat(sourceKeys, targetKeys));
      return _toConsumableArray(keys2).every(function(key) {
        var sourceValue = source[key];
        var targetValue = target[key];
        if (typeof sourceValue === "function" && typeof targetValue === "function") {
          return true;
        }
        return sourceValue === targetValue;
      });
    }
    function defaultGetValueFromEvent(valuePropName) {
      var event = arguments.length <= 1 ? void 0 : arguments[1];
      if (event && event.target && _typeof$1(event.target) === "object" && valuePropName in event.target) {
        return event.target[valuePropName];
      }
      return event;
    }
    function move(array2, moveIndex, toIndex) {
      var length2 = array2.length;
      if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
        return array2;
      }
      var item = array2[moveIndex];
      var diff = moveIndex - toIndex;
      if (diff > 0) {
        return [].concat(_toConsumableArray(array2.slice(0, toIndex)), [item], _toConsumableArray(array2.slice(toIndex, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, length2)));
      }
      if (diff < 0) {
        return [].concat(_toConsumableArray(array2.slice(0, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array2.slice(toIndex + 1, length2)));
      }
      return array2;
    }
    var AsyncValidator = Schema;
    function replaceMessage(template, kv) {
      return template.replace(/\$\{\w+\}/g, function(str) {
        var key = str.slice(2, -1);
        return kv[key];
      });
    }
    var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
    function validateRule(_x, _x2, _x3, _x4, _x5) {
      return _validateRule.apply(this, arguments);
    }
    function _validateRule() {
      _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
        var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                cloneRule = _objectSpread2({}, rule);
                delete cloneRule.ruleIndex;
                if (cloneRule.validator) {
                  originValidator = cloneRule.validator;
                  cloneRule.validator = function() {
                    try {
                      return originValidator.apply(void 0, arguments);
                    } catch (error) {
                      console.error(error);
                      return Promise.reject(CODE_LOGIC_ERROR);
                    }
                  };
                }
                subRuleField = null;
                if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
                  subRuleField = cloneRule.defaultField;
                  delete cloneRule.defaultField;
                }
                validator = new AsyncValidator(_defineProperty$2({}, name, [cloneRule]));
                messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
                validator.messages(messages2);
                result = [];
                _context2.prev = 9;
                _context2.next = 12;
                return Promise.resolve(validator.validate(_defineProperty$2({}, name, value), _objectSpread2({}, options)));
              case 12:
                _context2.next = 17;
                break;
              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](9);
                if (_context2.t0.errors) {
                  result = _context2.t0.errors.map(function(_ref4, index2) {
                    var message = _ref4.message;
                    var mergedMessage = message === CODE_LOGIC_ERROR ? messages2.default : message;
                    return /* @__PURE__ */ reactExports.isValidElement(mergedMessage) ? (
                      // Wrap ReactNode with `key`
                      /* @__PURE__ */ reactExports.cloneElement(mergedMessage, {
                        key: "error_".concat(index2)
                      })
                    ) : mergedMessage;
                  });
                }
              case 17:
                if (!(!result.length && subRuleField)) {
                  _context2.next = 22;
                  break;
                }
                _context2.next = 20;
                return Promise.all(value.map(function(subValue, i2) {
                  return validateRule("".concat(name, ".").concat(i2), subValue, subRuleField, options, messageVariables);
                }));
              case 20:
                subResults = _context2.sent;
                return _context2.abrupt("return", subResults.reduce(function(prev2, errors2) {
                  return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors2));
                }, []));
              case 22:
                kv = _objectSpread2(_objectSpread2({}, rule), {}, {
                  name,
                  enum: (rule.enum || []).join(", ")
                }, messageVariables);
                fillVariableResult = result.map(function(error) {
                  if (typeof error === "string") {
                    return replaceMessage(error, kv);
                  }
                  return error;
                });
                return _context2.abrupt("return", fillVariableResult);
              case 25:
              case "end":
                return _context2.stop();
            }
        }, _callee2, null, [[9, 14]]);
      }));
      return _validateRule.apply(this, arguments);
    }
    function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
      var name = namePath.join(".");
      var filledRules = rules2.map(function(currentRule, ruleIndex) {
        var originValidatorFunc = currentRule.validator;
        var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
          ruleIndex
        });
        if (originValidatorFunc) {
          cloneRule.validator = function(rule, val, callback) {
            var hasPromise = false;
            var wrappedCallback = function wrappedCallback2() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              Promise.resolve().then(function() {
                warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
                if (!hasPromise) {
                  callback.apply(void 0, args);
                }
              });
            };
            var promise = originValidatorFunc(rule, val, wrappedCallback);
            hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
            warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
            if (hasPromise) {
              promise.then(function() {
                callback();
              }).catch(function(err) {
                callback(err || " ");
              });
            }
          };
        }
        return cloneRule;
      }).sort(function(_ref, _ref2) {
        var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
        var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
        if (!!w1 === !!w2) {
          return i1 - i2;
        }
        if (w1) {
          return 1;
        }
        return -1;
      });
      var summaryPromise;
      if (validateFirst === true) {
        summaryPromise = new Promise(/* @__PURE__ */ function() {
          var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
            var i2, rule, errors2;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    i2 = 0;
                  case 1:
                    if (!(i2 < filledRules.length)) {
                      _context.next = 12;
                      break;
                    }
                    rule = filledRules[i2];
                    _context.next = 5;
                    return validateRule(name, value, rule, options, messageVariables);
                  case 5:
                    errors2 = _context.sent;
                    if (!errors2.length) {
                      _context.next = 9;
                      break;
                    }
                    reject([{
                      errors: errors2,
                      rule
                    }]);
                    return _context.abrupt("return");
                  case 9:
                    i2 += 1;
                    _context.next = 1;
                    break;
                  case 12:
                    resolve([]);
                  case 13:
                  case "end":
                    return _context.stop();
                }
            }, _callee);
          }));
          return function(_x6, _x7) {
            return _ref3.apply(this, arguments);
          };
        }());
      } else {
        var rulePromises = filledRules.map(function(rule) {
          return validateRule(name, value, rule, options, messageVariables).then(function(errors2) {
            return {
              errors: errors2,
              rule
            };
          });
        });
        summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors2) {
          return Promise.reject(errors2);
        });
      }
      summaryPromise.catch(function(e2) {
        return e2;
      });
      return summaryPromise;
    }
    function finishOnAllFailed(_x8) {
      return _finishOnAllFailed.apply(this, arguments);
    }
    function _finishOnAllFailed() {
      _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
                  var _ref5;
                  var errors2 = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                  return errors2;
                }));
              case 1:
              case "end":
                return _context3.stop();
            }
        }, _callee3);
      }));
      return _finishOnAllFailed.apply(this, arguments);
    }
    function finishOnFirstFailed(_x9) {
      return _finishOnFirstFailed.apply(this, arguments);
    }
    function _finishOnFirstFailed() {
      _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
        var count;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                count = 0;
                return _context4.abrupt("return", new Promise(function(resolve) {
                  rulePromises.forEach(function(promise) {
                    promise.then(function(ruleError) {
                      if (ruleError.errors.length) {
                        resolve([ruleError]);
                      }
                      count += 1;
                      if (count === rulePromises.length) {
                        resolve([]);
                      }
                    });
                  });
                }));
              case 2:
              case "end":
                return _context4.stop();
            }
        }, _callee4);
      }));
      return _finishOnFirstFailed.apply(this, arguments);
    }
    var _excluded$9 = ["name"];
    var EMPTY_ERRORS = [];
    function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
      if (typeof shouldUpdate === "function") {
        return shouldUpdate(prev2, next2, "source" in info ? {
          source: info.source
        } : {});
      }
      return prevValue !== nextValue;
    }
    var Field = /* @__PURE__ */ function(_React$Component) {
      _inherits$a(Field2, _React$Component);
      var _super = _createSuper(Field2);
      function Field2(props) {
        var _this;
        _classCallCheck$a(this, Field2);
        _this = _super.call(this, props);
        _this.state = {
          resetCount: 0
        };
        _this.cancelRegisterFunc = null;
        _this.mounted = false;
        _this.touched = false;
        _this.dirty = false;
        _this.validatePromise = void 0;
        _this.prevValidating = void 0;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.cancelRegister = function() {
          var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
          if (_this.cancelRegisterFunc) {
            _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
          }
          _this.cancelRegisterFunc = null;
        };
        _this.getNamePath = function() {
          var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
          var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
          return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
        };
        _this.getRules = function() {
          var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
          return rules2.map(function(rule) {
            if (typeof rule === "function") {
              return rule(fieldContext);
            }
            return rule;
          });
        };
        _this.refresh = function() {
          if (!_this.mounted)
            return;
          _this.setState(function(_ref) {
            var resetCount = _ref.resetCount;
            return {
              resetCount: resetCount + 1
            };
          });
        };
        _this.triggerMetaEvent = function(destroy) {
          var onMetaChange = _this.props.onMetaChange;
          onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
            destroy
          }));
        };
        _this.onStoreChange = function(prevStore, namePathList, info) {
          var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
          var store = info.store;
          var namePath = _this.getNamePath();
          var prevValue = _this.getValue(prevStore);
          var curValue = _this.getValue(store);
          var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
          if (info.type === "valueUpdate" && info.source === "external" && prevValue !== curValue) {
            _this.touched = true;
            _this.dirty = true;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
          }
          switch (info.type) {
            case "reset":
              if (!namePathList || namePathMatch) {
                _this.touched = false;
                _this.dirty = false;
                _this.validatePromise = null;
                _this.errors = EMPTY_ERRORS;
                _this.warnings = EMPTY_ERRORS;
                _this.triggerMetaEvent();
                onReset === null || onReset === void 0 ? void 0 : onReset();
                _this.refresh();
                return;
              }
              break;
            case "remove": {
              if (shouldUpdate) {
                _this.reRender();
                return;
              }
              break;
            }
            case "setField": {
              if (namePathMatch) {
                var data = info.data;
                if ("touched" in data) {
                  _this.touched = data.touched;
                }
                if ("validating" in data && !("originRCField" in data)) {
                  _this.validatePromise = data.validating ? Promise.resolve([]) : null;
                }
                if ("errors" in data) {
                  _this.errors = data.errors || EMPTY_ERRORS;
                }
                if ("warnings" in data) {
                  _this.warnings = data.warnings || EMPTY_ERRORS;
                }
                _this.dirty = true;
                _this.triggerMetaEvent();
                _this.reRender();
                return;
              }
              if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                _this.reRender();
                return;
              }
              break;
            }
            case "dependenciesUpdate": {
              var dependencyList = dependencies.map(getNamePath);
              if (dependencyList.some(function(dependency) {
                return containsNamePath(info.relatedFields, dependency);
              })) {
                _this.reRender();
                return;
              }
              break;
            }
            default:
              if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                _this.reRender();
                return;
              }
              break;
          }
          if (shouldUpdate === true) {
            _this.reRender();
          }
        };
        _this.validateRules = function(options) {
          var namePath = _this.getNamePath();
          var currentValue = _this.getValue();
          var rootPromise = Promise.resolve().then(function() {
            if (!_this.mounted) {
              return [];
            }
            var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
            var _ref2 = options || {}, triggerName = _ref2.triggerName;
            var filteredRules = _this.getRules();
            if (triggerName) {
              filteredRules = filteredRules.filter(function(rule) {
                return rule;
              }).filter(function(rule) {
                var validateTrigger = rule.validateTrigger;
                if (!validateTrigger) {
                  return true;
                }
                var triggerList = toArray$1(validateTrigger);
                return triggerList.includes(triggerName);
              });
            }
            var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
            promise.catch(function(e2) {
              return e2;
            }).then(function() {
              var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
              if (_this.validatePromise === rootPromise) {
                var _ruleErrors$forEach;
                _this.validatePromise = null;
                var nextErrors = [];
                var nextWarnings = [];
                (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref3) {
                  var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors2 = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
                  if (warningOnly) {
                    nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors2));
                  } else {
                    nextErrors.push.apply(nextErrors, _toConsumableArray(errors2));
                  }
                });
                _this.errors = nextErrors;
                _this.warnings = nextWarnings;
                _this.triggerMetaEvent();
                _this.reRender();
              }
            });
            return promise;
          });
          _this.validatePromise = rootPromise;
          _this.dirty = true;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();
          _this.reRender();
          return rootPromise;
        };
        _this.isFieldValidating = function() {
          return !!_this.validatePromise;
        };
        _this.isFieldTouched = function() {
          return _this.touched;
        };
        _this.isFieldDirty = function() {
          if (_this.dirty || _this.props.initialValue !== void 0) {
            return true;
          }
          var fieldContext = _this.props.fieldContext;
          var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
          if (getInitialValue(_this.getNamePath()) !== void 0) {
            return true;
          }
          return false;
        };
        _this.getErrors = function() {
          return _this.errors;
        };
        _this.getWarnings = function() {
          return _this.warnings;
        };
        _this.isListField = function() {
          return _this.props.isListField;
        };
        _this.isList = function() {
          return _this.props.isList;
        };
        _this.isPreserve = function() {
          return _this.props.preserve;
        };
        _this.getMeta = function() {
          _this.prevValidating = _this.isFieldValidating();
          var meta = {
            touched: _this.isFieldTouched(),
            validating: _this.prevValidating,
            errors: _this.errors,
            warnings: _this.warnings,
            name: _this.getNamePath(),
            validated: _this.validatePromise === null
          };
          return meta;
        };
        _this.getOnlyChild = function(children) {
          if (typeof children === "function") {
            var meta = _this.getMeta();
            return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {
              isFunction: true
            });
          }
          var childList = toArray$2(children);
          if (childList.length !== 1 || !/* @__PURE__ */ reactExports.isValidElement(childList[0])) {
            return {
              child: childList,
              isFunction: false
            };
          }
          return {
            child: childList[0],
            isFunction: false
          };
        };
        _this.getValue = function(store) {
          var getFieldsValue = _this.props.fieldContext.getFieldsValue;
          var namePath = _this.getNamePath();
          return getValue$4(store || getFieldsValue(true), namePath);
        };
        _this.getControlled = function() {
          var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
          var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
          var namePath = _this.getNamePath();
          var getInternalHooks2 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
          var _getInternalHooks = getInternalHooks2(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
          var value = _this.getValue();
          var mergedGetValueProps = getValueProps || function(val) {
            return _defineProperty$2({}, valuePropName, val);
          };
          var originTriggerFunc = childProps[trigger];
          var control = _objectSpread2(_objectSpread2({}, childProps), mergedGetValueProps(value));
          control[trigger] = function() {
            _this.touched = true;
            _this.dirty = true;
            _this.triggerMetaEvent();
            var newValue;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (getValueFromEvent) {
              newValue = getValueFromEvent.apply(void 0, args);
            } else {
              newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
            }
            if (normalize2) {
              newValue = normalize2(newValue, value, getFieldsValue(true));
            }
            dispatch({
              type: "updateValue",
              namePath,
              value: newValue
            });
            if (originTriggerFunc) {
              originTriggerFunc.apply(void 0, args);
            }
          };
          var validateTriggerList = toArray$1(mergedValidateTrigger || []);
          validateTriggerList.forEach(function(triggerName) {
            var originTrigger = control[triggerName];
            control[triggerName] = function() {
              if (originTrigger) {
                originTrigger.apply(void 0, arguments);
              }
              var rules2 = _this.props.rules;
              if (rules2 && rules2.length) {
                dispatch({
                  type: "validateField",
                  namePath,
                  triggerName
                });
              }
            };
          });
          return control;
        };
        if (props.fieldContext) {
          var getInternalHooks = props.fieldContext.getInternalHooks;
          var _getInternalHooks2 = getInternalHooks(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
          initEntityValue(_assertThisInitialized(_this));
        }
        return _this;
      }
      _createClass$8(Field2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
          this.mounted = true;
          if (fieldContext) {
            var getInternalHooks = fieldContext.getInternalHooks;
            var _getInternalHooks3 = getInternalHooks(HOOK_MARK), registerField = _getInternalHooks3.registerField;
            this.cancelRegisterFunc = registerField(this);
          }
          if (shouldUpdate === true) {
            this.reRender();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.cancelRegister();
          this.triggerMetaEvent(true);
          this.mounted = false;
        }
      }, {
        key: "reRender",
        value: function reRender() {
          if (!this.mounted)
            return;
          this.forceUpdate();
        }
      }, {
        key: "render",
        value: function render2() {
          var resetCount = this.state.resetCount;
          var children = this.props.children;
          var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
          var returnChildNode;
          if (isFunction2) {
            returnChildNode = child;
          } else if (/* @__PURE__ */ reactExports.isValidElement(child)) {
            returnChildNode = /* @__PURE__ */ reactExports.cloneElement(child, this.getControlled(child.props));
          } else {
            warningOnce(!child, "`children` of Field is not validate ReactElement.");
            returnChildNode = child;
          }
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, {
            key: resetCount
          }, returnChildNode);
        }
      }]);
      return Field2;
    }(reactExports.Component);
    Field.contextType = Context;
    Field.defaultProps = {
      trigger: "onChange",
      valuePropName: "value"
    };
    function WrapperField(_ref5) {
      var name = _ref5.name, restProps = _objectWithoutProperties$2(_ref5, _excluded$9);
      var fieldContext = reactExports.useContext(Context);
      var namePath = name !== void 0 ? getNamePath(name) : void 0;
      var key = "keep";
      if (!restProps.isListField) {
        key = "_".concat((namePath || []).join("_"));
      }
      return /* @__PURE__ */ reactExports.createElement(Field, _extends$g({
        key,
        name: namePath
      }, restProps, {
        fieldContext
      }));
    }
    var ListContext = /* @__PURE__ */ reactExports.createContext(null);
    var List = function List2(_ref) {
      var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger;
      var context = reactExports.useContext(Context);
      var keyRef = reactExports.useRef({
        keys: [],
        id: 0
      });
      var keyManager = keyRef.current;
      var prefixName = reactExports.useMemo(function() {
        var parentPrefixName = getNamePath(context.prefixName) || [];
        return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
      }, [context.prefixName, name]);
      var fieldContext = reactExports.useMemo(function() {
        return _objectSpread2(_objectSpread2({}, context), {}, {
          prefixName
        });
      }, [context, prefixName]);
      var listContext = reactExports.useMemo(function() {
        return {
          getKey: function getKey(namePath) {
            var len2 = prefixName.length;
            var pathName = namePath[len2];
            return [keyManager.keys[pathName], namePath.slice(len2 + 1)];
          }
        };
      }, [prefixName]);
      if (typeof children !== "function") {
        warningOnce(false, "Form.List only accepts function as children.");
        return null;
      }
      var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
        var source = _ref2.source;
        if (source === "internal") {
          return false;
        }
        return prevValue !== nextValue;
      };
      return /* @__PURE__ */ reactExports.createElement(ListContext.Provider, {
        value: listContext
      }, /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value: fieldContext
      }, /* @__PURE__ */ reactExports.createElement(WrapperField, {
        name: [],
        shouldUpdate,
        rules: rules2,
        validateTrigger,
        initialValue,
        isList: true
      }, function(_ref3, meta) {
        var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
        var getFieldValue = context.getFieldValue;
        var getNewValue = function getNewValue2() {
          var values = getFieldValue(prefixName || []);
          return values || [];
        };
        var operations = {
          add: function add(defaultValue, index2) {
            var newValue = getNewValue();
            if (index2 >= 0 && index2 <= newValue.length) {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
              onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
            } else {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
              onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
            }
            keyManager.id += 1;
          },
          remove: function remove(index2) {
            var newValue = getNewValue();
            var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
            if (indexSet.size <= 0) {
              return;
            }
            keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
              return !indexSet.has(keysIndex);
            });
            onChange(newValue.filter(function(_, valueIndex) {
              return !indexSet.has(valueIndex);
            }));
          },
          move: function move$1(from2, to) {
            if (from2 === to) {
              return;
            }
            var newValue = getNewValue();
            if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
              return;
            }
            keyManager.keys = move(keyManager.keys, from2, to);
            onChange(move(newValue, from2, to));
          }
        };
        var listValue = value || [];
        if (!Array.isArray(listValue)) {
          listValue = [];
        }
        return children(listValue.map(function(__, index2) {
          var key = keyManager.keys[index2];
          if (key === void 0) {
            keyManager.keys[index2] = keyManager.id;
            key = keyManager.keys[index2];
            keyManager.id += 1;
          }
          return {
            name: index2,
            key,
            isListField: true
          };
        }), operations, meta);
      })));
    };
    function allPromiseFinish(promiseList) {
      var hasError = false;
      var count = promiseList.length;
      var results = [];
      if (!promiseList.length) {
        return Promise.resolve([]);
      }
      return new Promise(function(resolve, reject) {
        promiseList.forEach(function(promise, index2) {
          promise.catch(function(e2) {
            hasError = true;
            return e2;
          }).then(function(result) {
            count -= 1;
            results[index2] = result;
            if (count > 0) {
              return;
            }
            if (hasError) {
              reject(results);
            }
            resolve(results);
          });
        });
      });
    }
    var SPLIT = "__@field_split__";
    function normalize(namePath) {
      return namePath.map(function(cell) {
        return "".concat(_typeof$1(cell), ":").concat(cell);
      }).join(SPLIT);
    }
    var NameMap = /* @__PURE__ */ function() {
      function NameMap2() {
        _classCallCheck$a(this, NameMap2);
        this.kvs = /* @__PURE__ */ new Map();
      }
      _createClass$8(NameMap2, [{
        key: "set",
        value: function set2(key, value) {
          this.kvs.set(normalize(key), value);
        }
      }, {
        key: "get",
        value: function get2(key) {
          return this.kvs.get(normalize(key));
        }
      }, {
        key: "update",
        value: function update(key, updater) {
          var origin = this.get(key);
          var next2 = updater(origin);
          if (!next2) {
            this.delete(key);
          } else {
            this.set(key, next2);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          this.kvs.delete(normalize(key));
        }
        // Since we only use this in test, let simply realize this
      }, {
        key: "map",
        value: function map2(callback) {
          return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
            var cells = key.split(SPLIT);
            return callback({
              key: cells.map(function(cell) {
                var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type2 = _cell$match2[1], unit = _cell$match2[2];
                return type2 === "number" ? Number(unit) : unit;
              }),
              value
            });
          });
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var json = {};
          this.map(function(_ref3) {
            var key = _ref3.key, value = _ref3.value;
            json[key.join(".")] = value;
            return null;
          });
          return json;
        }
      }]);
      return NameMap2;
    }();
    var _excluded$8 = ["name", "errors"];
    var FormStore = /* @__PURE__ */ _createClass$8(function FormStore2(forceRootUpdate) {
      var _this = this;
      _classCallCheck$a(this, FormStore2);
      this.formHooked = false;
      this.forceRootUpdate = void 0;
      this.subscribable = true;
      this.store = {};
      this.fieldEntities = [];
      this.initialValues = {};
      this.callbacks = {};
      this.validateMessages = null;
      this.preserve = null;
      this.lastValidatePromise = null;
      this.getForm = function() {
        return {
          getFieldValue: _this.getFieldValue,
          getFieldsValue: _this.getFieldsValue,
          getFieldError: _this.getFieldError,
          getFieldWarning: _this.getFieldWarning,
          getFieldsError: _this.getFieldsError,
          isFieldsTouched: _this.isFieldsTouched,
          isFieldTouched: _this.isFieldTouched,
          isFieldValidating: _this.isFieldValidating,
          isFieldsValidating: _this.isFieldsValidating,
          resetFields: _this.resetFields,
          setFields: _this.setFields,
          setFieldValue: _this.setFieldValue,
          setFieldsValue: _this.setFieldsValue,
          validateFields: _this.validateFields,
          submit: _this.submit,
          _init: true,
          getInternalHooks: _this.getInternalHooks
        };
      };
      this.getInternalHooks = function(key) {
        if (key === HOOK_MARK) {
          _this.formHooked = true;
          return {
            dispatch: _this.dispatch,
            initEntityValue: _this.initEntityValue,
            registerField: _this.registerField,
            useSubscribe: _this.useSubscribe,
            setInitialValues: _this.setInitialValues,
            destroyForm: _this.destroyForm,
            setCallbacks: _this.setCallbacks,
            setValidateMessages: _this.setValidateMessages,
            getFields: _this.getFields,
            setPreserve: _this.setPreserve,
            getInitialValue: _this.getInitialValue,
            registerWatch: _this.registerWatch
          };
        }
        warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
        return null;
      };
      this.useSubscribe = function(subscribable) {
        _this.subscribable = subscribable;
      };
      this.prevWithoutPreserves = null;
      this.setInitialValues = function(initialValues, init) {
        _this.initialValues = initialValues || {};
        if (init) {
          var _this$prevWithoutPres;
          var nextStore = setValues({}, initialValues, _this.store);
          (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
            var namePath = _ref.key;
            nextStore = setValue(nextStore, namePath, getValue$4(initialValues, namePath));
          });
          _this.prevWithoutPreserves = null;
          _this.updateStore(nextStore);
        }
      };
      this.destroyForm = function() {
        var prevWithoutPreserves = new NameMap();
        _this.getFieldEntities(true).forEach(function(entity) {
          if (!_this.isMergedPreserve(entity.isPreserve())) {
            prevWithoutPreserves.set(entity.getNamePath(), true);
          }
        });
        _this.prevWithoutPreserves = prevWithoutPreserves;
      };
      this.getInitialValue = function(namePath) {
        var initValue = getValue$4(_this.initialValues, namePath);
        return namePath.length ? cloneDeep$1(initValue) : initValue;
      };
      this.setCallbacks = function(callbacks) {
        _this.callbacks = callbacks;
      };
      this.setValidateMessages = function(validateMessages) {
        _this.validateMessages = validateMessages;
      };
      this.setPreserve = function(preserve) {
        _this.preserve = preserve;
      };
      this.watchList = [];
      this.registerWatch = function(callback) {
        _this.watchList.push(callback);
        return function() {
          _this.watchList = _this.watchList.filter(function(fn) {
            return fn !== callback;
          });
        };
      };
      this.notifyWatch = function() {
        var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (_this.watchList.length) {
          var values = _this.getFieldsValue();
          _this.watchList.forEach(function(callback) {
            callback(values, namePath);
          });
        }
      };
      this.timeoutId = null;
      this.warningUnhooked = function() {
      };
      this.updateStore = function(nextStore) {
        _this.store = nextStore;
      };
      this.getFieldEntities = function() {
        var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (!pure) {
          return _this.fieldEntities;
        }
        return _this.fieldEntities.filter(function(field) {
          return field.getNamePath().length;
        });
      };
      this.getFieldsMap = function() {
        var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var cache = new NameMap();
        _this.getFieldEntities(pure).forEach(function(field) {
          var namePath = field.getNamePath();
          cache.set(namePath, field);
        });
        return cache;
      };
      this.getFieldEntitiesForNamePathList = function(nameList) {
        if (!nameList) {
          return _this.getFieldEntities(true);
        }
        var cache = _this.getFieldsMap(true);
        return nameList.map(function(name) {
          var namePath = getNamePath(name);
          return cache.get(namePath) || {
            INVALIDATE_NAME_PATH: getNamePath(name)
          };
        });
      };
      this.getFieldsValue = function(nameList, filterFunc) {
        _this.warningUnhooked();
        if (nameList === true && !filterFunc) {
          return _this.store;
        }
        var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
        var filteredNameList = [];
        fieldEntities.forEach(function(entity) {
          var _entity$isListField;
          var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
          if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
            return;
          }
          if (!filterFunc) {
            filteredNameList.push(namePath);
          } else {
            var meta = "getMeta" in entity ? entity.getMeta() : null;
            if (filterFunc(meta)) {
              filteredNameList.push(namePath);
            }
          }
        });
        return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
      };
      this.getFieldValue = function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        return getValue$4(_this.store, namePath);
      };
      this.getFieldsError = function(nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
        return fieldEntities.map(function(entity, index2) {
          if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
            return {
              name: entity.getNamePath(),
              errors: entity.getErrors(),
              warnings: entity.getWarnings()
            };
          }
          return {
            name: getNamePath(nameList[index2]),
            errors: [],
            warnings: []
          };
        });
      };
      this.getFieldError = function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.errors;
      };
      this.getFieldWarning = function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.warnings;
      };
      this.isFieldsTouched = function() {
        _this.warningUnhooked();
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var arg0 = args[0], arg1 = args[1];
        var namePathList;
        var isAllFieldsTouched = false;
        if (args.length === 0) {
          namePathList = null;
        } else if (args.length === 1) {
          if (Array.isArray(arg0)) {
            namePathList = arg0.map(getNamePath);
            isAllFieldsTouched = false;
          } else {
            namePathList = null;
            isAllFieldsTouched = arg0;
          }
        } else {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = arg1;
        }
        var fieldEntities = _this.getFieldEntities(true);
        var isFieldTouched = function isFieldTouched2(field) {
          return field.isFieldTouched();
        };
        if (!namePathList) {
          return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
        }
        var map2 = new NameMap();
        namePathList.forEach(function(shortNamePath) {
          map2.set(shortNamePath, []);
        });
        fieldEntities.forEach(function(field) {
          var fieldNamePath = field.getNamePath();
          namePathList.forEach(function(shortNamePath) {
            if (shortNamePath.every(function(nameUnit, i2) {
              return fieldNamePath[i2] === nameUnit;
            })) {
              map2.update(shortNamePath, function(list) {
                return [].concat(_toConsumableArray(list), [field]);
              });
            }
          });
        });
        var isNamePathListTouched = function isNamePathListTouched2(entities) {
          return entities.some(isFieldTouched);
        };
        var namePathListEntities = map2.map(function(_ref2) {
          var value = _ref2.value;
          return value;
        });
        return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
      };
      this.isFieldTouched = function(name) {
        _this.warningUnhooked();
        return _this.isFieldsTouched([name]);
      };
      this.isFieldsValidating = function(nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntities();
        if (!nameList) {
          return fieldEntities.some(function(testField) {
            return testField.isFieldValidating();
          });
        }
        var namePathList = nameList.map(getNamePath);
        return fieldEntities.some(function(testField) {
          var fieldNamePath = testField.getNamePath();
          return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
        });
      };
      this.isFieldValidating = function(name) {
        _this.warningUnhooked();
        return _this.isFieldsValidating([name]);
      };
      this.resetWithFieldInitialValue = function() {
        var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var cache = new NameMap();
        var fieldEntities = _this.getFieldEntities(true);
        fieldEntities.forEach(function(field) {
          var initialValue = field.props.initialValue;
          var namePath = field.getNamePath();
          if (initialValue !== void 0) {
            var records = cache.get(namePath) || /* @__PURE__ */ new Set();
            records.add({
              entity: field,
              value: initialValue
            });
            cache.set(namePath, records);
          }
        });
        var resetWithFields = function resetWithFields2(entities) {
          entities.forEach(function(field) {
            var initialValue = field.props.initialValue;
            if (initialValue !== void 0) {
              var namePath = field.getNamePath();
              var formInitialValue = _this.getInitialValue(namePath);
              if (formInitialValue !== void 0) {
                warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
              } else {
                var records = cache.get(namePath);
                if (records && records.size > 1) {
                  warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
                } else if (records) {
                  var originValue = _this.getFieldValue(namePath);
                  if (!info.skipExist || originValue === void 0) {
                    _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));
                  }
                }
              }
            }
          });
        };
        var requiredFieldEntities;
        if (info.entities) {
          requiredFieldEntities = info.entities;
        } else if (info.namePathList) {
          requiredFieldEntities = [];
          info.namePathList.forEach(function(namePath) {
            var records = cache.get(namePath);
            if (records) {
              var _requiredFieldEntitie;
              (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
                return r2.entity;
              })));
            }
          });
        } else {
          requiredFieldEntities = fieldEntities;
        }
        resetWithFields(requiredFieldEntities);
      };
      this.resetFields = function(nameList) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (!nameList) {
          _this.updateStore(setValues({}, _this.initialValues));
          _this.resetWithFieldInitialValue();
          _this.notifyObservers(prevStore, null, {
            type: "reset"
          });
          _this.notifyWatch();
          return;
        }
        var namePathList = nameList.map(getNamePath);
        namePathList.forEach(function(namePath) {
          var initialValue = _this.getInitialValue(namePath);
          _this.updateStore(setValue(_this.store, namePath, initialValue));
        });
        _this.resetWithFieldInitialValue({
          namePathList
        });
        _this.notifyObservers(prevStore, namePathList, {
          type: "reset"
        });
        _this.notifyWatch(namePathList);
      };
      this.setFields = function(fields) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        var namePathList = [];
        fields.forEach(function(fieldData) {
          var name = fieldData.name;
          fieldData.errors;
          var data = _objectWithoutProperties$2(fieldData, _excluded$8);
          var namePath = getNamePath(name);
          namePathList.push(namePath);
          if ("value" in data) {
            _this.updateStore(setValue(_this.store, namePath, data.value));
          }
          _this.notifyObservers(prevStore, [namePath], {
            type: "setField",
            data: fieldData
          });
        });
        _this.notifyWatch(namePathList);
      };
      this.getFields = function() {
        var entities = _this.getFieldEntities(true);
        var fields = entities.map(function(field) {
          var namePath = field.getNamePath();
          var meta = field.getMeta();
          var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
            name: namePath,
            value: _this.getFieldValue(namePath)
          });
          Object.defineProperty(fieldData, "originRCField", {
            value: true
          });
          return fieldData;
        });
        return fields;
      };
      this.initEntityValue = function(entity) {
        var initialValue = entity.props.initialValue;
        if (initialValue !== void 0) {
          var namePath = entity.getNamePath();
          var prevValue = getValue$4(_this.store, namePath);
          if (prevValue === void 0) {
            _this.updateStore(setValue(_this.store, namePath, initialValue));
          }
        }
      };
      this.isMergedPreserve = function(fieldPreserve) {
        var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
        return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
      };
      this.registerField = function(entity) {
        _this.fieldEntities.push(entity);
        var namePath = entity.getNamePath();
        _this.notifyWatch([namePath]);
        if (entity.props.initialValue !== void 0) {
          var prevStore = _this.store;
          _this.resetWithFieldInitialValue({
            entities: [entity],
            skipExist: true
          });
          _this.notifyObservers(prevStore, [entity.getNamePath()], {
            type: "valueUpdate",
            source: "internal"
          });
        }
        return function(isListField, preserve) {
          var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          _this.fieldEntities = _this.fieldEntities.filter(function(item) {
            return item !== entity;
          });
          if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
            var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
            if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
              return (
                // Only reset when no namePath exist
                !matchNamePath(field.getNamePath(), namePath)
              );
            })) {
              var _prevStore = _this.store;
              _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));
              _this.notifyObservers(_prevStore, [namePath], {
                type: "remove"
              });
              _this.triggerDependenciesUpdate(_prevStore, namePath);
            }
          }
          _this.notifyWatch([namePath]);
        };
      };
      this.dispatch = function(action) {
        switch (action.type) {
          case "updateValue": {
            var namePath = action.namePath, value = action.value;
            _this.updateValue(namePath, value);
            break;
          }
          case "validateField": {
            var _namePath = action.namePath, triggerName = action.triggerName;
            _this.validateFields([_namePath], {
              triggerName
            });
            break;
          }
        }
      };
      this.notifyObservers = function(prevStore, namePathList, info) {
        if (_this.subscribable) {
          var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, {
            store: _this.getFieldsValue(true)
          });
          _this.getFieldEntities().forEach(function(_ref3) {
            var onStoreChange = _ref3.onStoreChange;
            onStoreChange(prevStore, namePathList, mergedInfo);
          });
        } else {
          _this.forceRootUpdate();
        }
      };
      this.triggerDependenciesUpdate = function(prevStore, namePath) {
        var childrenFields = _this.getDependencyChildrenFields(namePath);
        if (childrenFields.length) {
          _this.validateFields(childrenFields);
        }
        _this.notifyObservers(prevStore, childrenFields, {
          type: "dependenciesUpdate",
          relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
        });
        return childrenFields;
      };
      this.updateValue = function(name, value) {
        var namePath = getNamePath(name);
        var prevStore = _this.store;
        _this.updateStore(setValue(_this.store, namePath, value));
        _this.notifyObservers(prevStore, [namePath], {
          type: "valueUpdate",
          source: "internal"
        });
        _this.notifyWatch([namePath]);
        var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
        var onValuesChange = _this.callbacks.onValuesChange;
        if (onValuesChange) {
          var changedValues = cloneByNamePathList(_this.store, [namePath]);
          onValuesChange(changedValues, _this.getFieldsValue());
        }
        _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
      };
      this.setFieldsValue = function(store) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (store) {
          var nextStore = setValues(_this.store, store);
          _this.updateStore(nextStore);
        }
        _this.notifyObservers(prevStore, null, {
          type: "valueUpdate",
          source: "external"
        });
        _this.notifyWatch();
      };
      this.setFieldValue = function(name, value) {
        _this.setFields([{
          name,
          value
        }]);
      };
      this.getDependencyChildrenFields = function(rootNamePath) {
        var children = /* @__PURE__ */ new Set();
        var childrenFields = [];
        var dependencies2fields = new NameMap();
        _this.getFieldEntities().forEach(function(field) {
          var dependencies = field.props.dependencies;
          (dependencies || []).forEach(function(dependency) {
            var dependencyNamePath = getNamePath(dependency);
            dependencies2fields.update(dependencyNamePath, function() {
              var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
              fields.add(field);
              return fields;
            });
          });
        });
        var fillChildren = function fillChildren2(namePath) {
          var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
          fields.forEach(function(field) {
            if (!children.has(field)) {
              children.add(field);
              var fieldNamePath = field.getNamePath();
              if (field.isFieldDirty() && fieldNamePath.length) {
                childrenFields.push(fieldNamePath);
                fillChildren2(fieldNamePath);
              }
            }
          });
        };
        fillChildren(rootNamePath);
        return childrenFields;
      };
      this.triggerOnFieldsChange = function(namePathList, filedErrors) {
        var onFieldsChange = _this.callbacks.onFieldsChange;
        if (onFieldsChange) {
          var fields = _this.getFields();
          if (filedErrors) {
            var cache = new NameMap();
            filedErrors.forEach(function(_ref4) {
              var name = _ref4.name, errors2 = _ref4.errors;
              cache.set(name, errors2);
            });
            fields.forEach(function(field) {
              field.errors = cache.get(field.name) || field.errors;
            });
          }
          var changedFields = fields.filter(function(_ref5) {
            var fieldName = _ref5.name;
            return containsNamePath(namePathList, fieldName);
          });
          onFieldsChange(changedFields, fields);
        }
      };
      this.validateFields = function(nameList, options) {
        _this.warningUnhooked();
        var provideNameList = !!nameList;
        var namePathList = provideNameList ? nameList.map(getNamePath) : [];
        var promiseList = [];
        _this.getFieldEntities(true).forEach(function(field) {
          if (!provideNameList) {
            namePathList.push(field.getNamePath());
          }
          if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {
            var namePath = field.getNamePath();
            if (
              // nameList[i] === undefined  nameList 
              // ['name'] -> ['name','list']
              namePath.every(function(nameUnit, i2) {
                return nameList[i2] === nameUnit || nameList[i2] === void 0;
              })
            ) {
              namePathList.push(namePath);
            }
          }
          if (!field.props.rules || !field.props.rules.length) {
            return;
          }
          var fieldNamePath = field.getNamePath();
          if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
            var promise = field.validateRules(_objectSpread2({
              validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
            }, options));
            promiseList.push(promise.then(function() {
              return {
                name: fieldNamePath,
                errors: [],
                warnings: []
              };
            }).catch(function(ruleErrors) {
              var _ruleErrors$forEach;
              var mergedErrors = [];
              var mergedWarnings = [];
              (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref6) {
                var warningOnly = _ref6.rule.warningOnly, errors2 = _ref6.errors;
                if (warningOnly) {
                  mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors2));
                } else {
                  mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors2));
                }
              });
              if (mergedErrors.length) {
                return Promise.reject({
                  name: fieldNamePath,
                  errors: mergedErrors,
                  warnings: mergedWarnings
                });
              }
              return {
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              };
            }));
          }
        });
        var summaryPromise = allPromiseFinish(promiseList);
        _this.lastValidatePromise = summaryPromise;
        summaryPromise.catch(function(results) {
          return results;
        }).then(function(results) {
          var resultNamePathList = results.map(function(_ref7) {
            var name = _ref7.name;
            return name;
          });
          _this.notifyObservers(_this.store, resultNamePathList, {
            type: "validateFinish"
          });
          _this.triggerOnFieldsChange(resultNamePathList, results);
        });
        var returnPromise = summaryPromise.then(function() {
          if (_this.lastValidatePromise === summaryPromise) {
            return Promise.resolve(_this.getFieldsValue(namePathList));
          }
          return Promise.reject([]);
        }).catch(function(results) {
          var errorList = results.filter(function(result) {
            return result && result.errors.length;
          });
          return Promise.reject({
            values: _this.getFieldsValue(namePathList),
            errorFields: errorList,
            outOfDate: _this.lastValidatePromise !== summaryPromise
          });
        });
        returnPromise.catch(function(e2) {
          return e2;
        });
        return returnPromise;
      };
      this.submit = function() {
        _this.warningUnhooked();
        _this.validateFields().then(function(values) {
          var onFinish = _this.callbacks.onFinish;
          if (onFinish) {
            try {
              onFinish(values);
            } catch (err) {
              console.error(err);
            }
          }
        }).catch(function(e2) {
          var onFinishFailed = _this.callbacks.onFinishFailed;
          if (onFinishFailed) {
            onFinishFailed(e2);
          }
        });
      };
      this.forceRootUpdate = forceRootUpdate;
    });
    function useForm(form) {
      var formRef = reactExports.useRef();
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
      if (!formRef.current) {
        if (form) {
          formRef.current = form;
        } else {
          var forceReRender = function forceReRender2() {
            forceUpdate({});
          };
          var formStore = new FormStore(forceReRender);
          formRef.current = formStore.getForm();
        }
      }
      return [formRef.current];
    }
    var FormContext = /* @__PURE__ */ reactExports.createContext({
      triggerFormChange: function triggerFormChange() {
      },
      triggerFormFinish: function triggerFormFinish() {
      },
      registerForm: function registerForm() {
      },
      unregisterForm: function unregisterForm() {
      }
    });
    var FormProvider = function FormProvider2(_ref) {
      var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
      var formContext = reactExports.useContext(FormContext);
      var formsRef = reactExports.useRef({});
      return /* @__PURE__ */ reactExports.createElement(FormContext.Provider, {
        value: _objectSpread2(_objectSpread2({}, formContext), {}, {
          validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
          // =========================================================
          // =                  Global Form Control                  =
          // =========================================================
          triggerFormChange: function triggerFormChange(name, changedFields) {
            if (onFormChange) {
              onFormChange(name, {
                changedFields,
                forms: formsRef.current
              });
            }
            formContext.triggerFormChange(name, changedFields);
          },
          triggerFormFinish: function triggerFormFinish(name, values) {
            if (onFormFinish) {
              onFormFinish(name, {
                values,
                forms: formsRef.current
              });
            }
            formContext.triggerFormFinish(name, values);
          },
          registerForm: function registerForm(name, form) {
            if (name) {
              formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty$2({}, name, form));
            }
            formContext.registerForm(name, form);
          },
          unregisterForm: function unregisterForm(name) {
            var newForms = _objectSpread2({}, formsRef.current);
            delete newForms[name];
            formsRef.current = newForms;
            formContext.unregisterForm(name);
          }
        })
      }, children);
    };
    var _excluded$7 = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
    var Form = function Form2(_ref, ref) {
      var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties$2(_ref, _excluded$7);
      var formContext = reactExports.useContext(FormContext);
      var _useForm = useForm(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
      var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
      reactExports.useImperativeHandle(ref, function() {
        return formInstance;
      });
      reactExports.useEffect(function() {
        formContext.registerForm(name, formInstance);
        return function() {
          formContext.unregisterForm(name);
        };
      }, [formContext, formInstance, name]);
      setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
      setCallbacks({
        onValuesChange,
        onFieldsChange: function onFieldsChange(changedFields) {
          formContext.triggerFormChange(name, changedFields);
          if (_onFieldsChange) {
            for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              rest[_key - 1] = arguments[_key];
            }
            _onFieldsChange.apply(void 0, [changedFields].concat(rest));
          }
        },
        onFinish: function onFinish(values2) {
          formContext.triggerFormFinish(name, values2);
          if (_onFinish) {
            _onFinish(values2);
          }
        },
        onFinishFailed
      });
      setPreserve(preserve);
      var mountRef = reactExports.useRef(null);
      setInitialValues(initialValues, !mountRef.current);
      if (!mountRef.current) {
        mountRef.current = true;
      }
      reactExports.useEffect(
        function() {
          return destroyForm;
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      );
      var childrenNode;
      var childrenRenderProps = typeof children === "function";
      if (childrenRenderProps) {
        var values = formInstance.getFieldsValue(true);
        childrenNode = children(values, formInstance);
      } else {
        childrenNode = children;
      }
      useSubscribe(!childrenRenderProps);
      var prevFieldsRef = reactExports.useRef();
      reactExports.useEffect(function() {
        if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
          formInstance.setFields(fields || []);
        }
        prevFieldsRef.current = fields;
      }, [fields, formInstance]);
      var formContextValue = reactExports.useMemo(function() {
        return _objectSpread2(_objectSpread2({}, formInstance), {}, {
          validateTrigger
        });
      }, [formInstance, validateTrigger]);
      var wrapperNode = /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value: formContextValue
      }, childrenNode);
      if (Component === false) {
        return wrapperNode;
      }
      return /* @__PURE__ */ reactExports.createElement(Component, _extends$g({}, restProps, {
        onSubmit: function onSubmit(event) {
          event.preventDefault();
          event.stopPropagation();
          formInstance.submit();
        },
        onReset: function onReset(event) {
          var _restProps$onReset;
          event.preventDefault();
          formInstance.resetFields();
          (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
        }
      }), wrapperNode);
    };
    function stringify(value) {
      try {
        return JSON.stringify(value);
      } catch (err) {
        return Math.random();
      }
    }
    function useWatch$1() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var _args$ = args[0], dependencies = _args$ === void 0 ? [] : _args$, form = args[1];
      var _useState = reactExports.useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue2 = _useState2[1];
      var valueStr = reactExports.useMemo(function() {
        return stringify(value);
      }, [value]);
      var valueStrRef = reactExports.useRef(valueStr);
      valueStrRef.current = valueStr;
      var fieldContext = reactExports.useContext(Context);
      var formInstance = form || fieldContext;
      var isValidForm = formInstance && formInstance._init;
      var namePath = getNamePath(dependencies);
      var namePathRef = reactExports.useRef(namePath);
      namePathRef.current = namePath;
      reactExports.useEffect(
        function() {
          if (!isValidForm) {
            return;
          }
          var getFieldsValue = formInstance.getFieldsValue, getInternalHooks = formInstance.getInternalHooks;
          var _getInternalHooks = getInternalHooks(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
          var cancelRegister = registerWatch(function(store) {
            var newValue = getValue$4(store, namePathRef.current);
            var nextValueStr = stringify(newValue);
            if (valueStrRef.current !== nextValueStr) {
              valueStrRef.current = nextValueStr;
              setValue2(newValue);
            }
          });
          var initialValue = getValue$4(getFieldsValue(), namePathRef.current);
          setValue2(initialValue);
          return cancelRegister;
        },
        // We do not need re-register since namePath content is the same
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [isValidForm]
      );
      return value;
    }
    var InternalForm = /* @__PURE__ */ reactExports.forwardRef(Form);
    var RefForm = InternalForm;
    RefForm.FormProvider = FormProvider;
    RefForm.Field = WrapperField;
    RefForm.List = List;
    RefForm.useForm = useForm;
    RefForm.useWatch = useWatch$1;
    const enUS$1 = {
      // Options.jsx
      items_per_page: "/ page",
      jump_to: "Go to",
      jump_to_confirm: "confirm",
      page: "Page",
      // Pagination.jsx
      prev_page: "Previous Page",
      next_page: "Next Page",
      prev_5: "Previous 5 Pages",
      next_5: "Next 5 Pages",
      prev_3: "Previous 3 Pages",
      next_3: "Next 3 Pages",
      page_size: "Page Size"
    };
    var locale$2 = {
      locale: "en_US",
      today: "Today",
      now: "Now",
      backToToday: "Back to today",
      ok: "OK",
      clear: "Clear",
      month: "Month",
      year: "Year",
      timeSelect: "select time",
      dateSelect: "select date",
      weekSelect: "Choose a week",
      monthSelect: "Choose a month",
      yearSelect: "Choose a year",
      decadeSelect: "Choose a decade",
      yearFormat: "YYYY",
      dateFormat: "M/D/YYYY",
      dayFormat: "D",
      dateTimeFormat: "M/D/YYYY HH:mm:ss",
      monthBeforeYear: true,
      previousMonth: "Previous month (PageUp)",
      nextMonth: "Next month (PageDown)",
      previousYear: "Last year (Control + left)",
      nextYear: "Next year (Control + right)",
      previousDecade: "Last decade",
      nextDecade: "Next decade",
      previousCentury: "Last century",
      nextCentury: "Next century"
    };
    const locale$1 = {
      placeholder: "Select time",
      rangePlaceholder: ["Start time", "End time"]
    };
    const TimePicker = locale$1;
    const locale = {
      lang: Object.assign({
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"]
      }, locale$2),
      timePickerLocale: Object.assign({}, TimePicker)
    };
    const enUS = locale;
    const typeTemplate = "${label} is not a valid ${type}";
    const localeValues = {
      locale: "en",
      Pagination: enUS$1,
      DatePicker: enUS,
      TimePicker,
      Calendar: enUS,
      global: {
        placeholder: "Please select"
      },
      Table: {
        filterTitle: "Filter menu",
        filterConfirm: "OK",
        filterReset: "Reset",
        filterEmptyText: "No filters",
        filterCheckall: "Select all items",
        filterSearchPlaceholder: "Search in filters",
        emptyText: "No data",
        selectAll: "Select current page",
        selectInvert: "Invert current page",
        selectNone: "Clear all data",
        selectionAll: "Select all data",
        sortTitle: "Sort",
        expand: "Expand row",
        collapse: "Collapse row",
        triggerDesc: "Click to sort descending",
        triggerAsc: "Click to sort ascending",
        cancelSort: "Click to cancel sorting"
      },
      Tour: {
        Next: "Next",
        Previous: "Previous",
        Finish: "Finish"
      },
      Modal: {
        okText: "OK",
        cancelText: "Cancel",
        justOkText: "OK"
      },
      Popconfirm: {
        okText: "OK",
        cancelText: "Cancel"
      },
      Transfer: {
        titles: ["", ""],
        searchPlaceholder: "Search here",
        itemUnit: "item",
        itemsUnit: "items",
        remove: "Remove",
        selectCurrent: "Select current page",
        removeCurrent: "Remove current page",
        selectAll: "Select all data",
        removeAll: "Remove all data",
        selectInvert: "Invert current page"
      },
      Upload: {
        uploading: "Uploading...",
        removeFile: "Remove file",
        uploadError: "Upload error",
        previewFile: "Preview file",
        downloadFile: "Download file"
      },
      Empty: {
        description: "No data"
      },
      Icon: {
        icon: "icon"
      },
      Text: {
        edit: "Edit",
        copy: "Copy",
        copied: "Copied",
        expand: "Expand"
      },
      PageHeader: {
        back: "Back"
      },
      Form: {
        optional: "(optional)",
        defaultValidateMessages: {
          default: "Field validation error for ${label}",
          required: "Please enter ${label}",
          enum: "${label} must be one of [${enum}]",
          whitespace: "${label} cannot be a blank character",
          date: {
            format: "${label} date format is invalid",
            parse: "${label} cannot be converted to a date",
            invalid: "${label} is an invalid date"
          },
          types: {
            string: typeTemplate,
            method: typeTemplate,
            array: typeTemplate,
            object: typeTemplate,
            number: typeTemplate,
            date: typeTemplate,
            boolean: typeTemplate,
            integer: typeTemplate,
            float: typeTemplate,
            regexp: typeTemplate,
            email: typeTemplate,
            url: typeTemplate,
            hex: typeTemplate
          },
          string: {
            len: "${label} must be ${len} characters",
            min: "${label} must be at least ${min} characters",
            max: "${label} must be up to ${max} characters",
            range: "${label} must be between ${min}-${max} characters"
          },
          number: {
            len: "${label} must be equal to ${len}",
            min: "${label} must be minimum ${min}",
            max: "${label} must be maximum ${max}",
            range: "${label} must be between ${min}-${max}"
          },
          array: {
            len: "Must be ${len} ${label}",
            min: "At least ${min} ${label}",
            max: "At most ${max} ${label}",
            range: "The amount of ${label} must be between ${min}-${max}"
          },
          pattern: {
            mismatch: "${label} does not match the pattern ${pattern}"
          }
        }
      },
      Image: {
        preview: "Preview"
      },
      QRCode: {
        expired: "QR code expired",
        refresh: "Refresh"
      }
    };
    const defaultLocale = localeValues;
    let runtimeLocale = Object.assign({}, defaultLocale.Modal);
    function changeConfirmLocale(newLocale) {
      if (newLocale) {
        runtimeLocale = Object.assign(Object.assign({}, runtimeLocale), newLocale);
      } else {
        runtimeLocale = Object.assign({}, defaultLocale.Modal);
      }
    }
    const LocaleContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const LocaleContext$1 = LocaleContext;
    const ANT_MARK = "internalMark";
    const LocaleProvider = (props) => {
      const {
        locale: locale2 = {},
        children,
        _ANT_MARK__
      } = props;
      reactExports.useEffect(() => {
        changeConfirmLocale(locale2 && locale2.Modal);
        return () => {
          changeConfirmLocale();
        };
      }, [locale2]);
      const getMemoizedContextValue = reactExports.useMemo(() => Object.assign(Object.assign({}, locale2), {
        exist: true
      }), [locale2]);
      return /* @__PURE__ */ reactExports.createElement(LocaleContext$1.Provider, {
        value: getMemoizedContextValue
      }, children);
    };
    const LocaleProvider$1 = LocaleProvider;
    const version$1 = "5.3.2";
    const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
    function bound01$1(n2, max) {
      if (isOnePointZero$1(n2)) {
        n2 = "100%";
      }
      var isPercent = isPercentage$1(n2);
      n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
      if (isPercent) {
        n2 = parseInt(String(n2 * max), 10) / 100;
      }
      if (Math.abs(n2 - max) < 1e-6) {
        return 1;
      }
      if (max === 360) {
        n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
      } else {
        n2 = n2 % max / parseFloat(String(max));
      }
      return n2;
    }
    function clamp01$1(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero$1(n2) {
      return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
    }
    function isPercentage$1(n2) {
      return typeof n2 === "string" && n2.indexOf("%") !== -1;
    }
    function boundAlpha$1(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function convertToPercentage$1(n2) {
      if (n2 <= 1) {
        return "".concat(Number(n2) * 100, "%");
      }
      return n2;
    }
    function pad2$1(c2) {
      return c2.length === 1 ? "0" + c2 : String(c2);
    }
    function rgbToRgb$1(r2, g2, b2) {
      return {
        r: bound01$1(r2, 255) * 255,
        g: bound01$1(g2, 255) * 255,
        b: bound01$1(b2, 255) * 255
      };
    }
    function rgbToHsl$1(r2, g2, b2) {
      r2 = bound01$1(r2, 255);
      g2 = bound01$1(g2, 255);
      b2 = bound01$1(b2, 255);
      var max = Math.max(r2, g2, b2);
      var min = Math.min(r2, g2, b2);
      var h2 = 0;
      var s = 0;
      var l2 = (max + min) / 2;
      if (max === min) {
        s = 0;
        h2 = 0;
      } else {
        var d2 = max - min;
        s = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, l: l2 };
    }
    function hue2rgb(p2, q2, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t2);
      }
      if (t2 < 1 / 2) {
        return q2;
      }
      if (t2 < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      }
      return p2;
    }
    function hslToRgb$1(h2, s, l2) {
      var r2;
      var g2;
      var b2;
      h2 = bound01$1(h2, 360);
      s = bound01$1(s, 100);
      l2 = bound01$1(l2, 100);
      if (s === 0) {
        g2 = l2;
        b2 = l2;
        r2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv$1(r2, g2, b2) {
      r2 = bound01$1(r2, 255);
      g2 = bound01$1(g2, 255);
      b2 = bound01$1(b2, 255);
      var max = Math.max(r2, g2, b2);
      var min = Math.min(r2, g2, b2);
      var h2 = 0;
      var v2 = max;
      var d2 = max - min;
      var s = max === 0 ? 0 : d2 / max;
      if (max === min) {
        h2 = 0;
      } else {
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, v: v2 };
    }
    function hsvToRgb$1(h2, s, v2) {
      h2 = bound01$1(h2, 360) * 6;
      s = bound01$1(s, 100);
      v2 = bound01$1(v2, 100);
      var i2 = Math.floor(h2);
      var f2 = h2 - i2;
      var p2 = v2 * (1 - s);
      var q2 = v2 * (1 - f2 * s);
      var t2 = v2 * (1 - (1 - f2) * s);
      var mod = i2 % 6;
      var r2 = [v2, q2, p2, p2, t2, v2][mod];
      var g2 = [t2, v2, v2, q2, p2, p2][mod];
      var b2 = [p2, p2, t2, v2, v2, q2][mod];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex$1(r2, g2, b2, allow3Char) {
      var hex = [
        pad2$1(Math.round(r2).toString(16)),
        pad2$1(Math.round(g2).toString(16)),
        pad2$1(Math.round(b2).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex$1(r2, g2, b2, a, allow4Char) {
      var hex = [
        pad2$1(Math.round(r2).toString(16)),
        pad2$1(Math.round(g2).toString(16)),
        pad2$1(Math.round(b2).toString(16)),
        pad2$1(convertDecimalToHex$1(a))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex$1(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal$1(h2) {
      return parseIntFromHex$1(h2) / 255;
    }
    function parseIntFromHex$1(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }
    var names$1 = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB$1(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v2 = null;
      var l2 = null;
      var ok2 = false;
      var format2 = false;
      if (typeof color === "string") {
        color = stringInputToObject$1(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit$1(color.r) && isValidCSSUnit$1(color.g) && isValidCSSUnit$1(color.b)) {
          rgb = rgbToRgb$1(color.r, color.g, color.b);
          ok2 = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit$1(color.h) && isValidCSSUnit$1(color.s) && isValidCSSUnit$1(color.v)) {
          s = convertToPercentage$1(color.s);
          v2 = convertToPercentage$1(color.v);
          rgb = hsvToRgb$1(color.h, s, v2);
          ok2 = true;
          format2 = "hsv";
        } else if (isValidCSSUnit$1(color.h) && isValidCSSUnit$1(color.s) && isValidCSSUnit$1(color.l)) {
          s = convertToPercentage$1(color.s);
          l2 = convertToPercentage$1(color.l);
          rgb = hslToRgb$1(color.h, s, l2);
          ok2 = true;
          format2 = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a = color.a;
        }
      }
      a = boundAlpha$1(a);
      return {
        ok: ok2,
        format: color.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers$1 = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject$1(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names$1[color]) {
        color = names$1[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers$1.rgb.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers$1.rgba.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers$1.hsl.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers$1.hsla.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers$1.hsv.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers$1.hsva.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers$1.hex8.exec(color);
      if (match) {
        return {
          r: parseIntFromHex$1(match[1]),
          g: parseIntFromHex$1(match[2]),
          b: parseIntFromHex$1(match[3]),
          a: convertHexToDecimal$1(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers$1.hex6.exec(color);
      if (match) {
        return {
          r: parseIntFromHex$1(match[1]),
          g: parseIntFromHex$1(match[2]),
          b: parseIntFromHex$1(match[3]),
          format: named ? "name" : "hex"
        };
      }
      match = matchers$1.hex4.exec(color);
      if (match) {
        return {
          r: parseIntFromHex$1(match[1] + match[1]),
          g: parseIntFromHex$1(match[2] + match[2]),
          b: parseIntFromHex$1(match[3] + match[3]),
          a: convertHexToDecimal$1(match[4] + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers$1.hex3.exec(color);
      if (match) {
        return {
          r: parseIntFromHex$1(match[1] + match[1]),
          g: parseIntFromHex$1(match[2] + match[2]),
          b: parseIntFromHex$1(match[3] + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit$1(color) {
      return Boolean(matchers$1.CSS_UNIT.exec(String(color)));
    }
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color, opts) {
          if (color === void 0) {
            color = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a;
          if (color instanceof TinyColor2) {
            return color;
          }
          if (typeof color === "number") {
            color = numberInputToObject(color);
          }
          this.originalInput = color;
          var rgb = inputToRGB$1(color);
          this.originalInput = color;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R2;
          var G2;
          var B2;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha$1(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s = this.toHsl().s;
          return s === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv$1(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv$1(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s = Math.round(hsv.s * 100);
          var v2 = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl$1(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl$1(this.r, this.g, this.b);
          var h2 = Math.round(hsl.h * 360);
          var s = Math.round(hsl.s * 100);
          var l2 = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex$1(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex$1(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r2 = Math.round(this.r);
          var g2 = Math.round(this.g);
          var b2 = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x2) {
            return "".concat(Math.round(bound01$1(x2, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x2) {
            return Math.round(bound01$1(x2, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex$1(this.r, this.g, this.b, false);
          for (var _i = 0, _a = Object.entries(names$1); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (hex === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format2) {
          var formatSet = Boolean(format2);
          format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01$1(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01$1(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01$1(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01$1(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color).toRgb();
          var p2 = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s = hsv.s;
          var v2 = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s, v: v2 }));
            v2 = (v2 + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg2 = this.toRgb();
          var bg2 = new TinyColor2(background).toRgb();
          var alpha = fg2.a + bg2.a * (1 - fg2.a);
          return new TinyColor2({
            r: (fg2.r * fg2.a + bg2.r * bg2.a * (1 - fg2.a)) / alpha,
            g: (fg2.g * fg2.a + bg2.g * bg2.a * (1 - fg2.a)) / alpha,
            b: (fg2.b * fg2.a + bg2.b * bg2.a * (1 - fg2.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n2) {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          var result = [this];
          var increment = 360 / n2;
          for (var i2 = 1; i2 < n2; i2++) {
            result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color) {
          return this.toRgbString() === new TinyColor2(color).toRgbString();
        };
        return TinyColor2;
      }()
    );
    var hueStep = 2;
    var saturationStep = 0.16;
    var saturationStep2 = 0.05;
    var brightnessStep1 = 0.05;
    var brightnessStep2 = 0.15;
    var lightColorCount = 5;
    var darkColorCount = 4;
    var darkColorMap = [{
      index: 7,
      opacity: 0.15
    }, {
      index: 6,
      opacity: 0.25
    }, {
      index: 5,
      opacity: 0.3
    }, {
      index: 5,
      opacity: 0.45
    }, {
      index: 5,
      opacity: 0.65
    }, {
      index: 5,
      opacity: 0.85
    }, {
      index: 4,
      opacity: 0.9
    }, {
      index: 3,
      opacity: 0.95
    }, {
      index: 2,
      opacity: 0.97
    }, {
      index: 1,
      opacity: 0.98
    }];
    function toHsv(_ref) {
      var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
      var hsv = rgbToHsv$1(r2, g2, b2);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v
      };
    }
    function toHex(_ref2) {
      var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
      return "#".concat(rgbToHex$1(r2, g2, b2, false));
    }
    function mix(rgb1, rgb2, amount) {
      var p2 = amount / 100;
      var rgb = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b
      };
      return rgb;
    }
    function getHue(hsv, i2, light) {
      var hue;
      if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
        hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
      } else {
        hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
      }
      if (hue < 0) {
        hue += 360;
      } else if (hue >= 360) {
        hue -= 360;
      }
      return hue;
    }
    function getSaturation(hsv, i2, light) {
      if (hsv.h === 0 && hsv.s === 0) {
        return hsv.s;
      }
      var saturation;
      if (light) {
        saturation = hsv.s - saturationStep * i2;
      } else if (i2 === darkColorCount) {
        saturation = hsv.s + saturationStep;
      } else {
        saturation = hsv.s + saturationStep2 * i2;
      }
      if (saturation > 1) {
        saturation = 1;
      }
      if (light && i2 === lightColorCount && saturation > 0.1) {
        saturation = 0.1;
      }
      if (saturation < 0.06) {
        saturation = 0.06;
      }
      return Number(saturation.toFixed(2));
    }
    function getValue$3(hsv, i2, light) {
      var value;
      if (light) {
        value = hsv.v + brightnessStep1 * i2;
      } else {
        value = hsv.v - brightnessStep2 * i2;
      }
      if (value > 1) {
        value = 1;
      }
      return Number(value.toFixed(2));
    }
    function generate$1(color) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var patterns = [];
      var pColor = inputToRGB$1(color);
      for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
        var hsv = toHsv(pColor);
        var colorString = toHex(inputToRGB$1({
          h: getHue(hsv, i2, true),
          s: getSaturation(hsv, i2, true),
          v: getValue$3(hsv, i2, true)
        }));
        patterns.push(colorString);
      }
      patterns.push(toHex(pColor));
      for (var _i = 1; _i <= darkColorCount; _i += 1) {
        var _hsv = toHsv(pColor);
        var _colorString = toHex(inputToRGB$1({
          h: getHue(_hsv, _i),
          s: getSaturation(_hsv, _i),
          v: getValue$3(_hsv, _i)
        }));
        patterns.push(_colorString);
      }
      if (opts.theme === "dark") {
        return darkColorMap.map(function(_ref3) {
          var index2 = _ref3.index, opacity = _ref3.opacity;
          var darkColorString = toHex(mix(inputToRGB$1(opts.backgroundColor || "#141414"), inputToRGB$1(patterns[index2]), opacity * 100));
          return darkColorString;
        });
      }
      return patterns;
    }
    var presetPrimaryColors = {
      red: "#F5222D",
      volcano: "#FA541C",
      orange: "#FA8C16",
      gold: "#FAAD14",
      yellow: "#FADB14",
      lime: "#A0D911",
      green: "#52C41A",
      cyan: "#13C2C2",
      blue: "#1677FF",
      geekblue: "#2F54EB",
      purple: "#722ED1",
      magenta: "#EB2F96",
      grey: "#666666"
    };
    var presetPalettes = {};
    var presetDarkPalettes = {};
    Object.keys(presetPrimaryColors).forEach(function(key) {
      presetPalettes[key] = generate$1(presetPrimaryColors[key]);
      presetPalettes[key].primary = presetPalettes[key][5];
      presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
        theme: "dark",
        backgroundColor: "#141414"
      });
      presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
    });
    var gold = presetPalettes.gold;
    const genControlHeight = (token2) => {
      const {
        controlHeight
      } = token2;
      return {
        controlHeightSM: controlHeight * 0.75,
        controlHeightXS: controlHeight * 0.5,
        controlHeightLG: controlHeight * 1.25
      };
    };
    const genControlHeight$1 = genControlHeight;
    function genSizeMapToken$1(token2) {
      const {
        sizeUnit,
        sizeStep
      } = token2;
      return {
        sizeXXL: sizeUnit * (sizeStep + 8),
        sizeXL: sizeUnit * (sizeStep + 4),
        sizeLG: sizeUnit * (sizeStep + 2),
        sizeMD: sizeUnit * (sizeStep + 1),
        sizeMS: sizeUnit * sizeStep,
        size: sizeUnit * sizeStep,
        sizeSM: sizeUnit * (sizeStep - 1),
        sizeXS: sizeUnit * (sizeStep - 2),
        sizeXXS: sizeUnit * (sizeStep - 3)
        // 4
      };
    }
    const defaultPresetColors = {
      blue: "#1677ff",
      purple: "#722ED1",
      cyan: "#13C2C2",
      green: "#52C41A",
      magenta: "#EB2F96",
      pink: "#eb2f96",
      red: "#F5222D",
      orange: "#FA8C16",
      yellow: "#FADB14",
      volcano: "#FA541C",
      geekblue: "#2F54EB",
      gold: "#FAAD14",
      lime: "#A0D911"
    };
    const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
      // Color
      colorPrimary: "#1677ff",
      colorSuccess: "#52c41a",
      colorWarning: "#faad14",
      colorError: "#ff4d4f",
      colorInfo: "#1677ff",
      colorTextBase: "",
      colorBgBase: "",
      // Font
      fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
      fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
      fontSize: 14,
      // Line
      lineWidth: 1,
      lineType: "solid",
      // Motion
      motionUnit: 0.1,
      motionBase: 0,
      motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
      motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
      motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
      motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
      motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
      motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
      motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
      motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
      // Radius
      borderRadius: 6,
      // Size
      sizeUnit: 4,
      sizeStep: 4,
      sizePopupArrow: 16,
      // Control Base
      controlHeight: 32,
      // zIndex
      zIndexBase: 0,
      zIndexPopupBase: 1e3,
      // Image
      opacityImage: 1,
      // Wireframe
      wireframe: false
    });
    const defaultSeedToken = seedToken;
    function genColorMapToken(seed, _ref) {
      let {
        generateColorPalettes: generateColorPalettes2,
        generateNeutralColorPalettes: generateNeutralColorPalettes2
      } = _ref;
      const {
        colorSuccess: colorSuccessBase,
        colorWarning: colorWarningBase,
        colorError: colorErrorBase,
        colorInfo: colorInfoBase,
        colorPrimary: colorPrimaryBase,
        colorBgBase,
        colorTextBase
      } = seed;
      const primaryColors = generateColorPalettes2(colorPrimaryBase);
      const successColors = generateColorPalettes2(colorSuccessBase);
      const warningColors = generateColorPalettes2(colorWarningBase);
      const errorColors = generateColorPalettes2(colorErrorBase);
      const infoColors = generateColorPalettes2(colorInfoBase);
      const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
      return Object.assign(Object.assign({}, neutralColors), {
        colorPrimaryBg: primaryColors[1],
        colorPrimaryBgHover: primaryColors[2],
        colorPrimaryBorder: primaryColors[3],
        colorPrimaryBorderHover: primaryColors[4],
        colorPrimaryHover: primaryColors[5],
        colorPrimary: primaryColors[6],
        colorPrimaryActive: primaryColors[7],
        colorPrimaryTextHover: primaryColors[8],
        colorPrimaryText: primaryColors[9],
        colorPrimaryTextActive: primaryColors[10],
        colorSuccessBg: successColors[1],
        colorSuccessBgHover: successColors[2],
        colorSuccessBorder: successColors[3],
        colorSuccessBorderHover: successColors[4],
        colorSuccessHover: successColors[4],
        colorSuccess: successColors[6],
        colorSuccessActive: successColors[7],
        colorSuccessTextHover: successColors[8],
        colorSuccessText: successColors[9],
        colorSuccessTextActive: successColors[10],
        colorErrorBg: errorColors[1],
        colorErrorBgHover: errorColors[2],
        colorErrorBorder: errorColors[3],
        colorErrorBorderHover: errorColors[4],
        colorErrorHover: errorColors[5],
        colorError: errorColors[6],
        colorErrorActive: errorColors[7],
        colorErrorTextHover: errorColors[8],
        colorErrorText: errorColors[9],
        colorErrorTextActive: errorColors[10],
        colorWarningBg: warningColors[1],
        colorWarningBgHover: warningColors[2],
        colorWarningBorder: warningColors[3],
        colorWarningBorderHover: warningColors[4],
        colorWarningHover: warningColors[4],
        colorWarning: warningColors[6],
        colorWarningActive: warningColors[7],
        colorWarningTextHover: warningColors[8],
        colorWarningText: warningColors[9],
        colorWarningTextActive: warningColors[10],
        colorInfoBg: infoColors[1],
        colorInfoBgHover: infoColors[2],
        colorInfoBorder: infoColors[3],
        colorInfoBorderHover: infoColors[4],
        colorInfoHover: infoColors[4],
        colorInfo: infoColors[6],
        colorInfoActive: infoColors[7],
        colorInfoTextHover: infoColors[8],
        colorInfoText: infoColors[9],
        colorInfoTextActive: infoColors[10],
        colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
        colorWhite: "#fff"
      });
    }
    const genRadius = (radiusBase) => {
      let radiusLG = radiusBase;
      let radiusSM = radiusBase;
      let radiusXS = radiusBase;
      let radiusOuter = radiusBase;
      if (radiusBase < 6 && radiusBase >= 5) {
        radiusLG = radiusBase + 1;
      } else if (radiusBase < 16 && radiusBase >= 6) {
        radiusLG = radiusBase + 2;
      } else if (radiusBase >= 16) {
        radiusLG = 16;
      }
      if (radiusBase < 7 && radiusBase >= 5) {
        radiusSM = 4;
      } else if (radiusBase < 8 && radiusBase >= 7) {
        radiusSM = 5;
      } else if (radiusBase < 14 && radiusBase >= 8) {
        radiusSM = 6;
      } else if (radiusBase < 16 && radiusBase >= 14) {
        radiusSM = 7;
      } else if (radiusBase >= 16) {
        radiusSM = 8;
      }
      if (radiusBase < 6 && radiusBase >= 2) {
        radiusXS = 1;
      } else if (radiusBase >= 6) {
        radiusXS = 2;
      }
      if (radiusBase > 4 && radiusBase < 8) {
        radiusOuter = 4;
      } else if (radiusBase >= 8) {
        radiusOuter = 6;
      }
      return {
        borderRadius: radiusBase > 16 ? 16 : radiusBase,
        borderRadiusXS: radiusXS,
        borderRadiusSM: radiusSM,
        borderRadiusLG: radiusLG,
        borderRadiusOuter: radiusOuter
      };
    };
    const genRadius$1 = genRadius;
    function genCommonMapToken(token2) {
      const {
        motionUnit,
        motionBase,
        borderRadius,
        lineWidth
      } = token2;
      return Object.assign({
        // motion
        motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
        motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
        motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
        // line
        lineWidthBold: lineWidth + 1
      }, genRadius$1(borderRadius));
    }
    const getAlphaColor$2 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
    const getSolidColor$1 = (baseColor, brightness) => {
      const instance = new TinyColor(baseColor);
      return instance.darken(brightness).toHexString();
    };
    const generateColorPalettes$1 = (baseColor) => {
      const colors = generate$1(baseColor);
      return {
        1: colors[0],
        2: colors[1],
        3: colors[2],
        4: colors[3],
        5: colors[4],
        6: colors[5],
        7: colors[6],
        8: colors[4],
        9: colors[5],
        10: colors[6]
        // 8: colors[7],
        // 9: colors[8],
        // 10: colors[9],
      };
    };
    const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
      const colorBgBase = bgBaseColor || "#fff";
      const colorTextBase = textBaseColor || "#000";
      return {
        colorBgBase,
        colorTextBase,
        colorText: getAlphaColor$2(colorTextBase, 0.88),
        colorTextSecondary: getAlphaColor$2(colorTextBase, 0.65),
        colorTextTertiary: getAlphaColor$2(colorTextBase, 0.45),
        colorTextQuaternary: getAlphaColor$2(colorTextBase, 0.25),
        colorFill: getAlphaColor$2(colorTextBase, 0.15),
        colorFillSecondary: getAlphaColor$2(colorTextBase, 0.06),
        colorFillTertiary: getAlphaColor$2(colorTextBase, 0.04),
        colorFillQuaternary: getAlphaColor$2(colorTextBase, 0.02),
        colorBgLayout: getSolidColor$1(colorBgBase, 4),
        colorBgContainer: getSolidColor$1(colorBgBase, 0),
        colorBgElevated: getSolidColor$1(colorBgBase, 0),
        colorBgSpotlight: getAlphaColor$2(colorTextBase, 0.85),
        colorBorder: getSolidColor$1(colorBgBase, 15),
        colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
      };
    };
    function getFontSizes(base2) {
      const fontSizes = new Array(10).fill(null).map((_, index2) => {
        const i2 = index2 - 1;
        const baseSize = base2 * Math.pow(2.71828, i2 / 5);
        const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
        return Math.floor(intSize / 2) * 2;
      });
      fontSizes[1] = base2;
      return fontSizes.map((size) => {
        const height = size + 8;
        return {
          size,
          lineHeight: height / size
        };
      });
    }
    const genFontMapToken = (fontSize) => {
      const fontSizePairs = getFontSizes(fontSize);
      const fontSizes = fontSizePairs.map((pair) => pair.size);
      const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
      return {
        fontSizeSM: fontSizes[0],
        fontSize: fontSizes[1],
        fontSizeLG: fontSizes[2],
        fontSizeXL: fontSizes[3],
        fontSizeHeading1: fontSizes[6],
        fontSizeHeading2: fontSizes[5],
        fontSizeHeading3: fontSizes[4],
        fontSizeHeading4: fontSizes[3],
        fontSizeHeading5: fontSizes[2],
        lineHeight: lineHeights[1],
        lineHeightLG: lineHeights[2],
        lineHeightSM: lineHeights[0],
        lineHeightHeading1: lineHeights[6],
        lineHeightHeading2: lineHeights[5],
        lineHeightHeading3: lineHeights[4],
        lineHeightHeading4: lineHeights[3],
        lineHeightHeading5: lineHeights[2]
      };
    };
    const genFontMapToken$1 = genFontMapToken;
    function derivative$2(token2) {
      const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
        const colors = generate$1(token2[colorKey]);
        return new Array(10).fill(1).reduce((prev2, _, i2) => {
          prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
          prev2[`${colorKey}${i2 + 1}`] = colors[i2];
          return prev2;
        }, {});
      }).reduce((prev2, cur) => {
        prev2 = Object.assign(Object.assign({}, prev2), cur);
        return prev2;
      }, {});
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
        generateColorPalettes: generateColorPalettes$1,
        generateNeutralColorPalettes: generateNeutralColorPalettes$1
      })), genFontMapToken$1(token2.fontSize)), genSizeMapToken$1(token2)), genControlHeight$1(token2)), genCommonMapToken(token2));
    }
    function isStableColor(color) {
      return color >= 0 && color <= 255;
    }
    function getAlphaColor$1(frontColor, backgroundColor) {
      const {
        r: fR,
        g: fG,
        b: fB,
        a: originAlpha
      } = new TinyColor(frontColor).toRgb();
      if (originAlpha < 1) {
        return frontColor;
      }
      const {
        r: bR,
        g: bG,
        b: bB
      } = new TinyColor(backgroundColor).toRgb();
      for (let fA = 0.01; fA <= 1; fA += 0.01) {
        const r2 = Math.round((fR - bR * (1 - fA)) / fA);
        const g2 = Math.round((fG - bG * (1 - fA)) / fA);
        const b2 = Math.round((fB - bB * (1 - fA)) / fA);
        if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
          return new TinyColor({
            r: r2,
            g: g2,
            b: b2,
            a: Math.round(fA * 100) / 100
          }).toRgbString();
        }
      }
      return new TinyColor({
        r: fR,
        g: fG,
        b: fB,
        a: 1
      }).toRgbString();
    }
    var __rest$b = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function formatToken(derivativeToken) {
      const {
        override
      } = derivativeToken, restToken = __rest$b(derivativeToken, ["override"]);
      const overrideTokens = Object.assign({}, override);
      Object.keys(defaultSeedToken).forEach((token2) => {
        delete overrideTokens[token2];
      });
      const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
      const screenXS = 480;
      const screenSM = 576;
      const screenMD = 768;
      const screenLG = 992;
      const screenXL = 1200;
      const screenXXL = 1600;
      const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
        colorLink: mergedToken.colorInfoText,
        colorLinkHover: mergedToken.colorInfoHover,
        colorLinkActive: mergedToken.colorInfoActive,
        // ============== Background ============== //
        colorFillContent: mergedToken.colorFillSecondary,
        colorFillContentHover: mergedToken.colorFill,
        colorFillAlter: mergedToken.colorFillQuaternary,
        colorBgContainerDisabled: mergedToken.colorFillTertiary,
        // ============== Split ============== //
        colorBorderBg: mergedToken.colorBgContainer,
        colorSplit: getAlphaColor$1(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
        // ============== Text ============== //
        colorTextPlaceholder: mergedToken.colorTextQuaternary,
        colorTextDisabled: mergedToken.colorTextQuaternary,
        colorTextHeading: mergedToken.colorText,
        colorTextLabel: mergedToken.colorTextSecondary,
        colorTextDescription: mergedToken.colorTextTertiary,
        colorTextLightSolid: mergedToken.colorWhite,
        colorHighlight: mergedToken.colorError,
        colorBgTextHover: mergedToken.colorFillSecondary,
        colorBgTextActive: mergedToken.colorFill,
        colorIcon: mergedToken.colorTextTertiary,
        colorIconHover: mergedToken.colorText,
        colorErrorOutline: getAlphaColor$1(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
        colorWarningOutline: getAlphaColor$1(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
        // Font
        fontSizeIcon: mergedToken.fontSizeSM,
        // Line
        lineWidthFocus: mergedToken.lineWidth * 4,
        // Control
        lineWidth: mergedToken.lineWidth,
        controlOutlineWidth: mergedToken.lineWidth * 2,
        // Checkbox size and expand icon size
        controlInteractiveSize: mergedToken.controlHeight / 2,
        controlItemBgHover: mergedToken.colorFillTertiary,
        controlItemBgActive: mergedToken.colorPrimaryBg,
        controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
        controlItemBgActiveDisabled: mergedToken.colorFill,
        controlTmpOutline: mergedToken.colorFillQuaternary,
        controlOutline: getAlphaColor$1(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
        lineType: mergedToken.lineType,
        borderRadius: mergedToken.borderRadius,
        borderRadiusXS: mergedToken.borderRadiusXS,
        borderRadiusSM: mergedToken.borderRadiusSM,
        borderRadiusLG: mergedToken.borderRadiusLG,
        fontWeightStrong: 600,
        opacityLoading: 0.65,
        linkDecoration: "none",
        linkHoverDecoration: "none",
        linkFocusDecoration: "none",
        controlPaddingHorizontal: 12,
        controlPaddingHorizontalSM: 8,
        paddingXXS: mergedToken.sizeXXS,
        paddingXS: mergedToken.sizeXS,
        paddingSM: mergedToken.sizeSM,
        padding: mergedToken.size,
        paddingMD: mergedToken.sizeMD,
        paddingLG: mergedToken.sizeLG,
        paddingXL: mergedToken.sizeXL,
        paddingContentHorizontalLG: mergedToken.sizeLG,
        paddingContentVerticalLG: mergedToken.sizeMS,
        paddingContentHorizontal: mergedToken.sizeMS,
        paddingContentVertical: mergedToken.sizeSM,
        paddingContentHorizontalSM: mergedToken.size,
        paddingContentVerticalSM: mergedToken.sizeXS,
        marginXXS: mergedToken.sizeXXS,
        marginXS: mergedToken.sizeXS,
        marginSM: mergedToken.sizeSM,
        margin: mergedToken.size,
        marginMD: mergedToken.sizeMD,
        marginLG: mergedToken.sizeLG,
        marginXL: mergedToken.sizeXL,
        marginXXL: mergedToken.sizeXXL,
        boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
        screenXS,
        screenXSMin: screenXS,
        screenXSMax: screenSM - 1,
        screenSM,
        screenSMMin: screenSM,
        screenSMMax: screenMD - 1,
        screenMD,
        screenMDMin: screenMD,
        screenMDMax: screenLG - 1,
        screenLG,
        screenLGMin: screenLG,
        screenLGMax: screenXL - 1,
        screenXL,
        screenXLMin: screenXL,
        screenXLMax: screenXXL - 1,
        screenXXL,
        screenXXLMin: screenXXL,
        boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
        boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
        boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
      }), overrideTokens);
      return aliasToken;
    }
    const operationUnit = (token2) => ({
      // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
      // And Typography use this to generate link style which should not do this.
      color: token2.colorLink,
      textDecoration: "none",
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "&:focus, &:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      }
    });
    function genPresetColor(token2, genCss) {
      return PresetColors.reduce((prev2, colorKey) => {
        const lightColor = token2[`${colorKey}1`];
        const lightBorderColor = token2[`${colorKey}3`];
        const darkColor = token2[`${colorKey}6`];
        const textColor = token2[`${colorKey}7`];
        return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
          lightColor,
          lightBorderColor,
          darkColor,
          textColor
        }));
      }, {});
    }
    const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
      const unitWidth = width / 2;
      const ax = 0;
      const ay = unitWidth;
      const bx = outerRadius * 1 / Math.sqrt(2);
      const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
      const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
      const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
      const dx = 2 * unitWidth - cx;
      const dy = cy;
      const ex = 2 * unitWidth - bx;
      const ey = by;
      const fx = 2 * unitWidth - ax;
      const fy = ay;
      const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
      return {
        pointerEvents: "none",
        width,
        height: width,
        overflow: "hidden",
        "&::before": {
          position: "absolute",
          bottom: 0,
          insetInlineStart: 0,
          width,
          height: width / 2,
          background: bgColor,
          clipPath: `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`,
          content: '""'
        },
        "&::after": {
          content: '""',
          position: "absolute",
          width: shadowWidth,
          height: shadowWidth,
          bottom: 0,
          insetInline: 0,
          margin: "auto",
          borderRadius: {
            _skip_check_: true,
            value: `0 0 ${innerRadius}px 0`
          },
          transform: "translateY(50%) rotate(-135deg)",
          boxShadow,
          zIndex: 0,
          background: "transparent"
        }
      };
    };
    const resetComponent = (token2) => ({
      boxSizing: "border-box",
      margin: 0,
      padding: 0,
      color: token2.colorText,
      fontSize: token2.fontSize,
      // font-variant: @font-variant-base;
      lineHeight: token2.lineHeight,
      listStyle: "none",
      // font-feature-settings: @font-feature-settings-base;
      fontFamily: token2.fontFamily
    });
    const resetIcon = () => ({
      display: "inline-flex",
      alignItems: "center",
      color: "inherit",
      fontStyle: "normal",
      lineHeight: 0,
      textAlign: "center",
      textTransform: "none",
      // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
      verticalAlign: "-0.125em",
      textRendering: "optimizeLegibility",
      "-webkit-font-smoothing": "antialiased",
      "-moz-osx-font-smoothing": "grayscale",
      "> *": {
        lineHeight: 1
      },
      svg: {
        display: "inline-block"
      }
    });
    const clearFix = () => ({
      // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
      "&::before": {
        display: "table",
        content: '""'
      },
      "&::after": {
        // https://github.com/ant-design/ant-design/issues/21864
        display: "table",
        clear: "both",
        content: '""'
      }
    });
    const genLinkStyle = (token2) => ({
      a: {
        color: token2.colorLink,
        textDecoration: token2.linkDecoration,
        backgroundColor: "transparent",
        outline: "none",
        cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        "-webkit-text-decoration-skip": "objects",
        "&:hover": {
          color: token2.colorLinkHover
        },
        "&:active": {
          color: token2.colorLinkActive
        },
        [`&:active,
  &:hover`]: {
          textDecoration: token2.linkHoverDecoration,
          outline: 0
        },
        // https://github.com/ant-design/ant-design/issues/22503
        "&:focus": {
          textDecoration: token2.linkFocusDecoration,
          outline: 0
        },
        "&[disabled]": {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    });
    const genCommonStyle = (token2, componentPrefixCls) => {
      const {
        fontFamily,
        fontSize
      } = token2;
      const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
      return {
        [rootPrefixSelector]: {
          fontFamily,
          fontSize,
          boxSizing: "border-box",
          "&::before, &::after": {
            boxSizing: "border-box"
          },
          [rootPrefixSelector]: {
            boxSizing: "border-box",
            "&::before, &::after": {
              boxSizing: "border-box"
            }
          }
        }
      };
    };
    const genFocusOutline = (token2) => ({
      outline: `${token2.lineWidthFocus}px solid ${token2.colorPrimaryBorder}`,
      outlineOffset: 1,
      transition: "outline-offset 0s, outline 0s"
    });
    const genFocusStyle = (token2) => ({
      "&:focus-visible": Object.assign({}, genFocusOutline(token2))
    });
    const defaultIconPrefixCls = "anticon";
    const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? `ant-${suffixCls}` : "ant";
    };
    const ConfigContext = /* @__PURE__ */ reactExports.createContext({
      // We provide a default function for Context without provider
      getPrefixCls: defaultGetPrefixCls,
      iconPrefixCls: defaultIconPrefixCls
    });
    function genComponentStyleHook(component, styleFn, getDefaultToken) {
      return (prefixCls) => {
        const [theme2, token2, hashId] = useToken$2();
        const {
          getPrefixCls,
          iconPrefixCls
        } = reactExports.useContext(ConfigContext);
        const rootPrefixCls = getPrefixCls();
        useStyleRegister({
          theme: theme2,
          token: token2,
          hashId,
          path: ["Shared", rootPrefixCls]
        }, () => [{
          // Link
          "&": genLinkStyle(token2)
        }]);
        return [useStyleRegister({
          theme: theme2,
          token: token2,
          hashId,
          path: [component, prefixCls, iconPrefixCls]
        }, () => {
          const {
            token: proxyToken,
            flush
          } = statisticToken(token2);
          const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
          const mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), token2[component]);
          const componentCls = `.${prefixCls}`;
          const mergedToken = merge$2(proxyToken, {
            componentCls,
            prefixCls,
            iconCls: `.${iconPrefixCls}`,
            antCls: `.${rootPrefixCls}`
          }, mergedComponentToken);
          const styleInterpolation = styleFn(mergedToken, {
            hashId,
            prefixCls,
            rootPrefixCls,
            iconPrefixCls,
            overrideComponentToken: token2[component]
          });
          flush(component, mergedComponentToken);
          return [genCommonStyle(token2, prefixCls), styleInterpolation];
        }), hashId];
      };
    }
    const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
    let recording = true;
    function merge$2() {
      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
        objs[_key] = arguments[_key];
      }
      if (!enableStatistic) {
        return Object.assign.apply(Object, [{}].concat(objs));
      }
      recording = false;
      const ret = {};
      objs.forEach((obj) => {
        const keys2 = Object.keys(obj);
        keys2.forEach((key) => {
          Object.defineProperty(ret, key, {
            configurable: true,
            enumerable: true,
            get: () => obj[key]
          });
        });
      });
      recording = true;
      return ret;
    }
    function noop() {
    }
    function statisticToken(token2) {
      let tokenKeys2;
      let proxy = token2;
      let flush = noop;
      if (enableStatistic) {
        tokenKeys2 = /* @__PURE__ */ new Set();
        proxy = new Proxy(token2, {
          get(obj, prop) {
            if (recording) {
              tokenKeys2.add(prop);
            }
            return obj[prop];
          }
        });
        flush = (componentName, componentToken) => {
          ({
            global: Array.from(tokenKeys2),
            component: componentToken
          });
        };
      }
      return {
        token: proxy,
        keys: tokenKeys2,
        flush
      };
    }
    const defaultTheme = createTheme(derivative$2);
    const defaultConfig = {
      token: defaultSeedToken,
      hashed: true
    };
    const DesignTokenContext = /* @__PURE__ */ React$1.createContext(defaultConfig);
    function useToken$2() {
      const {
        token: rootDesignToken,
        hashed,
        theme: theme2,
        components
      } = React$1.useContext(DesignTokenContext);
      const salt = `${version$1}-${hashed || ""}`;
      const mergedTheme = theme2 || defaultTheme;
      const [token2, hashId] = useCacheToken(mergedTheme, [defaultSeedToken, rootDesignToken], {
        salt,
        override: Object.assign({
          override: rootDesignToken
        }, components),
        formatToken
      });
      return [mergedTheme, token2, hashed ? hashId : ""];
    }
    const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
    function getStyle(globalPrefixCls2, theme2) {
      const variables = {};
      const formatColor = (color, updater) => {
        let clone = color.clone();
        clone = (updater === null || updater === void 0 ? void 0 : updater(clone)) || clone;
        return clone.toRgbString();
      };
      const fillColor = (colorVal, type2) => {
        const baseColor = new TinyColor(colorVal);
        const colorPalettes = generate$1(baseColor.toRgbString());
        variables[`${type2}-color`] = formatColor(baseColor);
        variables[`${type2}-color-disabled`] = colorPalettes[1];
        variables[`${type2}-color-hover`] = colorPalettes[4];
        variables[`${type2}-color-active`] = colorPalettes[6];
        variables[`${type2}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
        variables[`${type2}-color-deprecated-bg`] = colorPalettes[0];
        variables[`${type2}-color-deprecated-border`] = colorPalettes[2];
      };
      if (theme2.primaryColor) {
        fillColor(theme2.primaryColor, "primary");
        const primaryColor = new TinyColor(theme2.primaryColor);
        const primaryColors = generate$1(primaryColor.toRgbString());
        primaryColors.forEach((color, index2) => {
          variables[`primary-${index2 + 1}`] = color;
        });
        variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
        variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
        variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
        variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
        variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
        const primaryActiveColor = new TinyColor(primaryColors[0]);
        variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
        variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
      }
      if (theme2.successColor) {
        fillColor(theme2.successColor, "success");
      }
      if (theme2.warningColor) {
        fillColor(theme2.warningColor, "warning");
      }
      if (theme2.errorColor) {
        fillColor(theme2.errorColor, "error");
      }
      if (theme2.infoColor) {
        fillColor(theme2.infoColor, "info");
      }
      const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
      return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
    }
    function registerTheme(globalPrefixCls2, theme2) {
      const style2 = getStyle(globalPrefixCls2, theme2);
      if (canUseDom()) {
        updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`);
      }
    }
    const DisabledContext = /* @__PURE__ */ reactExports.createContext(false);
    const DisabledContextProvider = (_ref) => {
      let {
        children,
        disabled
      } = _ref;
      const originDisabled = reactExports.useContext(DisabledContext);
      return /* @__PURE__ */ reactExports.createElement(DisabledContext.Provider, {
        value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
      }, children);
    };
    const DisabledContext$1 = DisabledContext;
    const SizeContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const SizeContextProvider = (_ref) => {
      let {
        children,
        size
      } = _ref;
      const originSize = reactExports.useContext(SizeContext);
      return /* @__PURE__ */ reactExports.createElement(SizeContext.Provider, {
        value: size || originSize
      }, children);
    };
    const SizeContext$1 = SizeContext;
    function useConfig() {
      const componentDisabled = reactExports.useContext(DisabledContext$1);
      const componentSize = reactExports.useContext(SizeContext$1);
      return {
        componentDisabled,
        componentSize
      };
    }
    function useTheme(theme2, parentTheme) {
      const themeConfig = theme2 || {};
      const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? defaultConfig : parentTheme;
      const mergedTheme = useMemo(() => {
        if (!theme2) {
          return parentTheme;
        }
        const mergedComponents = Object.assign({}, parentThemeConfig.components);
        Object.keys(theme2.components || {}).forEach((componentName) => {
          mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme2.components[componentName]);
        });
        return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
          token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
          components: mergedComponents
        });
      }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
        const nextTheme = next2[index2];
        return !isEqual(prevTheme, nextTheme, true);
      }));
      return mergedTheme;
    }
    const useStyle$5 = (iconPrefixCls) => {
      const [theme2, token2] = useToken$2();
      return useStyleRegister({
        theme: theme2,
        token: token2,
        hashId: "",
        path: ["ant-design-icons", iconPrefixCls]
      }, () => [{
        [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
          [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
            display: "block"
          }
        })
      }]);
    };
    const useStyle$6 = useStyle$5;
    var __rest$a = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select"];
    const defaultPrefixCls = "ant";
    let globalPrefixCls;
    function getGlobalPrefixCls() {
      return globalPrefixCls || defaultPrefixCls;
    }
    const setGlobalConfig = (_ref) => {
      let {
        prefixCls,
        iconPrefixCls,
        theme: theme2
      } = _ref;
      if (prefixCls !== void 0) {
        globalPrefixCls = prefixCls;
      }
      if (theme2) {
        registerTheme(getGlobalPrefixCls(), theme2);
      }
    };
    const ProviderChildren = (props) => {
      const {
        children,
        csp: customCsp,
        autoInsertSpaceInButton,
        form,
        locale: locale2,
        componentSize,
        direction,
        space,
        virtual,
        dropdownMatchSelectWidth,
        legacyLocale,
        parentContext,
        iconPrefixCls: customIconPrefixCls,
        theme: theme2,
        componentDisabled
      } = props;
      const getPrefixCls = reactExports.useCallback((suffixCls, customizePrefixCls) => {
        const {
          prefixCls
        } = props;
        if (customizePrefixCls)
          return customizePrefixCls;
        const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
        return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
      }, [parentContext.getPrefixCls, props.prefixCls]);
      const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
      const shouldWrapSSR = iconPrefixCls !== parentContext.iconPrefixCls;
      const csp = customCsp || parentContext.csp;
      const wrapSSR = useStyle$6(iconPrefixCls);
      const mergedTheme = useTheme(theme2, parentContext.theme);
      const baseConfig = {
        csp,
        autoInsertSpaceInButton,
        locale: locale2 || legacyLocale,
        direction,
        space,
        virtual,
        dropdownMatchSelectWidth,
        getPrefixCls,
        iconPrefixCls,
        theme: mergedTheme
      };
      const config = Object.assign({}, parentContext);
      Object.keys(baseConfig).forEach((key) => {
        if (baseConfig[key] !== void 0) {
          config[key] = baseConfig[key];
        }
      });
      PASSED_PROPS.forEach((propName) => {
        const propValue = props[propName];
        if (propValue) {
          config[propName] = propValue;
        }
      });
      const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
        const prevKeys = Object.keys(prevConfig);
        const currentKeys = Object.keys(currentConfig);
        return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
      });
      const memoIconContextValue = reactExports.useMemo(() => ({
        prefixCls: iconPrefixCls,
        csp
      }), [iconPrefixCls, csp]);
      let childNode = shouldWrapSSR ? wrapSSR(children) : children;
      const validateMessages = reactExports.useMemo(() => {
        var _a, _b, _c;
        return setValues({}, ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
      }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
      if (Object.keys(validateMessages).length > 0) {
        childNode = /* @__PURE__ */ reactExports.createElement(FormProvider, {
          validateMessages
        }, children);
      }
      if (locale2) {
        childNode = /* @__PURE__ */ reactExports.createElement(LocaleProvider$1, {
          locale: locale2,
          _ANT_MARK__: ANT_MARK
        }, childNode);
      }
      if (iconPrefixCls || csp) {
        childNode = /* @__PURE__ */ reactExports.createElement(Context$1.Provider, {
          value: memoIconContextValue
        }, childNode);
      }
      if (componentSize) {
        childNode = /* @__PURE__ */ reactExports.createElement(SizeContextProvider, {
          size: componentSize
        }, childNode);
      }
      const memoTheme = reactExports.useMemo(() => {
        const _a = mergedTheme || {}, {
          algorithm: algorithm2,
          token: token2
        } = _a, rest = __rest$a(_a, ["algorithm", "token"]);
        const themeObj = algorithm2 && (!Array.isArray(algorithm2) || algorithm2.length > 0) ? createTheme(algorithm2) : void 0;
        return Object.assign(Object.assign({}, rest), {
          theme: themeObj,
          token: Object.assign(Object.assign({}, defaultSeedToken), token2)
        });
      }, [mergedTheme]);
      if (theme2) {
        childNode = /* @__PURE__ */ reactExports.createElement(DesignTokenContext.Provider, {
          value: memoTheme
        }, childNode);
      }
      if (componentDisabled !== void 0) {
        childNode = /* @__PURE__ */ reactExports.createElement(DisabledContextProvider, {
          disabled: componentDisabled
        }, childNode);
      }
      return /* @__PURE__ */ reactExports.createElement(ConfigContext.Provider, {
        value: memoedConfig
      }, childNode);
    };
    const ConfigProvider = (props) => {
      const context = reactExports.useContext(ConfigContext);
      const antLocale = reactExports.useContext(LocaleContext$1);
      return /* @__PURE__ */ reactExports.createElement(ProviderChildren, Object.assign({
        parentContext: context,
        legacyLocale: antLocale
      }, props));
    };
    ConfigProvider.ConfigContext = ConfigContext;
    ConfigProvider.SizeContext = SizeContext$1;
    ConfigProvider.config = setGlobalConfig;
    ConfigProvider.useConfig = useConfig;
    Object.defineProperty(ConfigProvider, "SizeContext", {
      get: () => {
        return SizeContext$1;
      }
    });
    var raf = function raf2(callback) {
      return +setTimeout(callback, 16);
    };
    var caf = function caf2(num) {
      return clearTimeout(num);
    };
    if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
      raf = function raf2(callback) {
        return window.requestAnimationFrame(callback);
      };
      caf = function caf2(handle) {
        return window.cancelAnimationFrame(handle);
      };
    }
    var rafUUID = 0;
    var rafIds = /* @__PURE__ */ new Map();
    function cleanup(id2) {
      rafIds.delete(id2);
    }
    var wrapperRaf = function wrapperRaf2(callback) {
      var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      rafUUID += 1;
      var id2 = rafUUID;
      function callRef(leftTimes) {
        if (leftTimes === 0) {
          cleanup(id2);
          callback();
        } else {
          var realId = raf(function() {
            callRef(leftTimes - 1);
          });
          rafIds.set(id2, realId);
        }
      }
      callRef(times);
      return id2;
    };
    wrapperRaf.cancel = function(id2) {
      var realId = rafIds.get(id2);
      cleanup(realId);
      return caf(realId);
    };
    function warning(valid, message) {
      warningOnce(valid, "[@ant-design/icons] ".concat(message));
    }
    function isIconDefinition(target) {
      return _typeof$1(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$1(target.icon) === "object" || typeof target.icon === "function");
    }
    function normalizeAttrs() {
      var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Object.keys(attrs).reduce(function(acc, key) {
        var val = attrs[key];
        switch (key) {
          case "class":
            acc.className = val;
            delete acc.class;
            break;
          default:
            acc[key] = val;
        }
        return acc;
      }, {});
    }
    function generate(node2, key, rootProps) {
      if (!rootProps) {
        return /* @__PURE__ */ React$1.createElement(node2.tag, _objectSpread2({
          key
        }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
          return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      return /* @__PURE__ */ React$1.createElement(node2.tag, _objectSpread2(_objectSpread2({
        key
      }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
        return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    function getSecondaryColor(primaryColor) {
      return generate$1(primaryColor)[0];
    }
    function normalizeTwoToneColors(twoToneColor) {
      if (!twoToneColor) {
        return [];
      }
      return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
    }
    var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
    var useInsertStyles = function useInsertStyles2() {
      var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
      var _useContext = reactExports.useContext(Context$1), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
      var mergedStyleStr = styleStr;
      if (prefixCls) {
        mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
      }
      reactExports.useEffect(function() {
        updateCSS(mergedStyleStr, "@ant-design-icons", {
          prepend: true,
          csp
        });
      }, []);
    };
    var _excluded$6 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
    var twoToneColorPalette = {
      primaryColor: "#333",
      secondaryColor: "#E6E6E6",
      calculated: false
    };
    function setTwoToneColors(_ref) {
      var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
      twoToneColorPalette.primaryColor = primaryColor;
      twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
      twoToneColorPalette.calculated = !!secondaryColor;
    }
    function getTwoToneColors() {
      return _objectSpread2({}, twoToneColorPalette);
    }
    var IconBase = function IconBase2(props) {
      var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties$2(props, _excluded$6);
      var colors = twoToneColorPalette;
      if (primaryColor) {
        colors = {
          primaryColor,
          secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
        };
      }
      useInsertStyles();
      warning(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
      if (!isIconDefinition(icon)) {
        return null;
      }
      var target = icon;
      if (target && typeof target.icon === "function") {
        target = _objectSpread2(_objectSpread2({}, target), {}, {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }
      return generate(target.icon, "svg-".concat(target.name), _objectSpread2({
        className,
        onClick,
        style: style2,
        "data-icon": target.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
      }, restProps));
    };
    IconBase.displayName = "IconReact";
    IconBase.getTwoToneColors = getTwoToneColors;
    IconBase.setTwoToneColors = setTwoToneColors;
    const ReactIcon = IconBase;
    function setTwoToneColor(twoToneColor) {
      var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return ReactIcon.setTwoToneColors({
        primaryColor,
        secondaryColor
      });
    }
    function getTwoToneColor() {
      var colors = ReactIcon.getTwoToneColors();
      if (!colors.calculated) {
        return colors.primaryColor;
      }
      return [colors.primaryColor, colors.secondaryColor];
    }
    var _excluded$5 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
    setTwoToneColor("#1890ff");
    var Icon = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _classNames;
      var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties$2(props, _excluded$5);
      var _React$useContext = reactExports.useContext(Context$1), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
      var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$2(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$2(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return /* @__PURE__ */ reactExports.createElement("span", _objectSpread2(_objectSpread2({
        role: "img",
        "aria-label": icon.name
      }, restProps), {}, {
        ref,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), /* @__PURE__ */ reactExports.createElement(ReactIcon, {
        icon,
        primaryColor,
        secondaryColor,
        style: svgStyle
      }));
    });
    Icon.displayName = "AntdIcon";
    Icon.getTwoToneColor = getTwoToneColor;
    Icon.setTwoToneColor = setTwoToneColor;
    const AntdIcon = Icon;
    var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
    const CloseCircleFilledSvg = CloseCircleFilled$2;
    var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _objectSpread2(_objectSpread2({}, props), {}, {
        ref,
        icon: CloseCircleFilledSvg
      }));
    };
    CloseCircleFilled.displayName = "CloseCircleFilled";
    const CloseCircleFilled$1 = /* @__PURE__ */ reactExports.forwardRef(CloseCircleFilled);
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
      prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
      prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
      prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
      return prefixes;
    }
    function getVendorPrefixes(domSupport, win) {
      var prefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      if (domSupport) {
        if (!("AnimationEvent" in win)) {
          delete prefixes.animationend.animation;
        }
        if (!("TransitionEvent" in win)) {
          delete prefixes.transitionend.transition;
        }
      }
      return prefixes;
    }
    var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
    var style = {};
    if (canUseDom()) {
      var _document$createEleme = document.createElement("div");
      style = _document$createEleme.style;
    }
    var prefixedEventNames = {};
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) {
        return prefixedEventNames[eventName];
      }
      var prefixMap = vendorPrefixes[eventName];
      if (prefixMap) {
        var stylePropList = Object.keys(prefixMap);
        var len2 = stylePropList.length;
        for (var i2 = 0; i2 < len2; i2 += 1) {
          var styleProp = stylePropList[i2];
          if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
            prefixedEventNames[eventName] = prefixMap[styleProp];
            return prefixedEventNames[eventName];
          }
        }
      }
      return "";
    }
    var internalAnimationEndName = getVendorPrefixedEventName("animationend");
    var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
    var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
    var animationEndName = internalAnimationEndName || "animationend";
    var transitionEndName = internalTransitionEndName || "transitionend";
    function getTransitionName$1(transitionName, transitionType) {
      if (!transitionName)
        return null;
      if (_typeof$1(transitionName) === "object") {
        var type2 = transitionType.replace(/-\w/g, function(match) {
          return match[1].toUpperCase();
        });
        return transitionName[type2];
      }
      return "".concat(transitionName, "-").concat(transitionType);
    }
    var STATUS_NONE = "none";
    var STATUS_APPEAR = "appear";
    var STATUS_ENTER = "enter";
    var STATUS_LEAVE = "leave";
    var STEP_NONE = "none";
    var STEP_PREPARE = "prepare";
    var STEP_START = "start";
    var STEP_ACTIVE = "active";
    var STEP_ACTIVATED = "end";
    function useSafeState(defaultValue) {
      var destroyRef = reactExports.useRef(false);
      var _React$useState = reactExports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue2 = _React$useState2[1];
      reactExports.useEffect(function() {
        destroyRef.current = false;
        return function() {
          destroyRef.current = true;
        };
      }, []);
      function safeSetState(updater, ignoreDestroy) {
        if (ignoreDestroy && destroyRef.current) {
          return;
        }
        setValue2(updater);
      }
      return [value, safeSetState];
    }
    const useNextFrame = function() {
      var nextFrameRef = reactExports.useRef(null);
      function cancelNextFrame() {
        wrapperRaf.cancel(nextFrameRef.current);
      }
      function nextFrame(callback) {
        var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        cancelNextFrame();
        var nextFrameId = wrapperRaf(function() {
          if (delay <= 1) {
            callback({
              isCanceled: function isCanceled() {
                return nextFrameId !== nextFrameRef.current;
              }
            });
          } else {
            nextFrame(callback, delay - 1);
          }
        });
        nextFrameRef.current = nextFrameId;
      }
      reactExports.useEffect(function() {
        return function() {
          cancelNextFrame();
        };
      }, []);
      return [nextFrame, cancelNextFrame];
    };
    var useIsomorphicLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
    var STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
    var SkipStep = false;
    var DoStep = true;
    function isActive(step) {
      return step === STEP_ACTIVE || step === STEP_ACTIVATED;
    }
    const useStepQueue = function(status2, callback) {
      var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
      var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
      function startQueue() {
        setStep(STEP_PREPARE, true);
      }
      useIsomorphicLayoutEffect(function() {
        if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
          var index2 = STEP_QUEUE.indexOf(step);
          var nextStep = STEP_QUEUE[index2 + 1];
          var result = callback(step);
          if (result === SkipStep) {
            setStep(nextStep, true);
          } else {
            nextFrame(function(info) {
              function doNext() {
                if (info.isCanceled())
                  return;
                setStep(nextStep, true);
              }
              if (result === true) {
                doNext();
              } else {
                Promise.resolve(result).then(doNext);
              }
            });
          }
        }
      }, [status2, step]);
      reactExports.useEffect(function() {
        return function() {
          cancelNextFrame();
        };
      }, []);
      return [startQueue, step];
    };
    const useDomMotionEvents = function(callback) {
      var cacheElementRef = reactExports.useRef();
      var callbackRef = reactExports.useRef(callback);
      callbackRef.current = callback;
      var onInternalMotionEnd = reactExports.useCallback(function(event) {
        callbackRef.current(event);
      }, []);
      function removeMotionEvents(element) {
        if (element) {
          element.removeEventListener(transitionEndName, onInternalMotionEnd);
          element.removeEventListener(animationEndName, onInternalMotionEnd);
        }
      }
      function patchMotionEvents(element) {
        if (cacheElementRef.current && cacheElementRef.current !== element) {
          removeMotionEvents(cacheElementRef.current);
        }
        if (element && element !== cacheElementRef.current) {
          element.addEventListener(transitionEndName, onInternalMotionEnd);
          element.addEventListener(animationEndName, onInternalMotionEnd);
          cacheElementRef.current = element;
        }
      }
      reactExports.useEffect(function() {
        return function() {
          removeMotionEvents(cacheElementRef.current);
        };
      }, []);
      return [patchMotionEvents, removeMotionEvents];
    };
    function useStatus(supportMotion, visible, getElement, _ref) {
      var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
      var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
      var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray(_useState3, 2), status2 = _useState4[0], setStatus = _useState4[1];
      var _useState5 = useSafeState(null), _useState6 = _slicedToArray(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
      var mountedRef = reactExports.useRef(false);
      var deadlineRef = reactExports.useRef(null);
      function getDomElement() {
        return getElement();
      }
      var activeRef = reactExports.useRef(false);
      function onInternalMotionEnd(event) {
        var element = getDomElement();
        if (event && !event.deadline && event.target !== element) {
          return;
        }
        var currentActive = activeRef.current;
        var canEnd;
        if (status2 === STATUS_APPEAR && currentActive) {
          canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
        } else if (status2 === STATUS_ENTER && currentActive) {
          canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
        } else if (status2 === STATUS_LEAVE && currentActive) {
          canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
        }
        if (status2 !== STATUS_NONE && currentActive && canEnd !== false) {
          setStatus(STATUS_NONE, true);
          setStyle(null, true);
        }
      }
      var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
      var eventHandlers = reactExports.useMemo(function() {
        var _ref2, _ref3, _ref4;
        switch (status2) {
          case STATUS_APPEAR:
            return _ref2 = {}, _defineProperty$2(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$2(_ref2, STEP_START, onAppearStart), _defineProperty$2(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
          case STATUS_ENTER:
            return _ref3 = {}, _defineProperty$2(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$2(_ref3, STEP_START, onEnterStart), _defineProperty$2(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
          case STATUS_LEAVE:
            return _ref4 = {}, _defineProperty$2(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$2(_ref4, STEP_START, onLeaveStart), _defineProperty$2(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
          default:
            return {};
        }
      }, [status2]);
      var _useStepQueue = useStepQueue(status2, function(newStep) {
        if (newStep === STEP_PREPARE) {
          var onPrepare = eventHandlers[STEP_PREPARE];
          if (!onPrepare) {
            return SkipStep;
          }
          return onPrepare(getDomElement());
        }
        if (step in eventHandlers) {
          var _eventHandlers$step;
          setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
        }
        if (step === STEP_ACTIVE) {
          patchMotionEvents(getDomElement());
          if (motionDeadline > 0) {
            clearTimeout(deadlineRef.current);
            deadlineRef.current = setTimeout(function() {
              onInternalMotionEnd({
                deadline: true
              });
            }, motionDeadline);
          }
        }
        return DoStep;
      }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
      var active2 = isActive(step);
      activeRef.current = active2;
      useIsomorphicLayoutEffect(function() {
        setAsyncVisible(visible);
        var isMounted = mountedRef.current;
        mountedRef.current = true;
        if (!supportMotion) {
          return;
        }
        var nextStatus;
        if (!isMounted && visible && motionAppear) {
          nextStatus = STATUS_APPEAR;
        }
        if (isMounted && visible && motionEnter) {
          nextStatus = STATUS_ENTER;
        }
        if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
          nextStatus = STATUS_LEAVE;
        }
        if (nextStatus) {
          setStatus(nextStatus);
          startStep();
        }
      }, [visible]);
      reactExports.useEffect(function() {
        if (
          // Cancel appear
          status2 === STATUS_APPEAR && !motionAppear || // Cancel enter
          status2 === STATUS_ENTER && !motionEnter || // Cancel leave
          status2 === STATUS_LEAVE && !motionLeave
        ) {
          setStatus(STATUS_NONE);
        }
      }, [motionAppear, motionEnter, motionLeave]);
      reactExports.useEffect(function() {
        return function() {
          mountedRef.current = false;
          clearTimeout(deadlineRef.current);
        };
      }, []);
      var firstMountChangeRef = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (asyncVisible) {
          firstMountChangeRef.current = true;
        }
        if (asyncVisible !== void 0 && status2 === STATUS_NONE) {
          if (firstMountChangeRef.current || asyncVisible) {
            onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
          }
          firstMountChangeRef.current = true;
        }
      }, [asyncVisible, status2]);
      var mergedStyle = style2;
      if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
        mergedStyle = _objectSpread2({
          transition: "none"
        }, mergedStyle);
      }
      return [status2, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
    }
    var DomWrapper = /* @__PURE__ */ function(_React$Component) {
      _inherits$a(DomWrapper2, _React$Component);
      var _super = _createSuper(DomWrapper2);
      function DomWrapper2() {
        _classCallCheck$a(this, DomWrapper2);
        return _super.apply(this, arguments);
      }
      _createClass$8(DomWrapper2, [{
        key: "render",
        value: function render2() {
          return this.props.children;
        }
      }]);
      return DomWrapper2;
    }(reactExports.Component);
    function genCSSMotion(config) {
      var transitionSupport = config;
      if (_typeof$1(config) === "object") {
        transitionSupport = config.transitionSupport;
      }
      function isSupportTransition(props) {
        return !!(props.motionName && transitionSupport);
      }
      var CSSMotion2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
        var supportMotion = isSupportTransition(props);
        var nodeRef = reactExports.useRef();
        var wrapperNodeRef = reactExports.useRef();
        function getDomElement() {
          try {
            return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
          } catch (e2) {
            return null;
          }
        }
        var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status2 = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
        var renderedRef = reactExports.useRef(mergedVisible);
        if (mergedVisible) {
          renderedRef.current = true;
        }
        var setNodeRef = reactExports.useCallback(function(node2) {
          nodeRef.current = node2;
          fillRef(ref, node2);
        }, [ref]);
        var motionChildren;
        var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
          visible
        });
        if (!children) {
          motionChildren = null;
        } else if (status2 === STATUS_NONE || !isSupportTransition(props)) {
          if (mergedVisible) {
            motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
          } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
            motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
              className: leavedClassName
            }), setNodeRef);
          } else if (forceRender || !removeOnLeave && !leavedClassName) {
            motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
              style: {
                display: "none"
              }
            }), setNodeRef);
          } else {
            motionChildren = null;
          }
        } else {
          var _classNames;
          var statusSuffix;
          if (statusStep === STEP_PREPARE) {
            statusSuffix = "prepare";
          } else if (isActive(statusStep)) {
            statusSuffix = "active";
          } else if (statusStep === STEP_START) {
            statusSuffix = "start";
          }
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            className: classNames(getTransitionName$1(motionName, status2), (_classNames = {}, _defineProperty$2(_classNames, getTransitionName$1(motionName, "".concat(status2, "-").concat(statusSuffix)), statusSuffix), _defineProperty$2(_classNames, motionName, typeof motionName === "string"), _classNames)),
            style: statusStyle
          }), setNodeRef);
        }
        if (/* @__PURE__ */ reactExports.isValidElement(motionChildren) && supportRef(motionChildren)) {
          var _ref = motionChildren, originNodeRef = _ref.ref;
          if (!originNodeRef) {
            motionChildren = /* @__PURE__ */ reactExports.cloneElement(motionChildren, {
              ref: setNodeRef
            });
          }
        }
        return /* @__PURE__ */ reactExports.createElement(DomWrapper, {
          ref: wrapperNodeRef
        }, motionChildren);
      });
      CSSMotion2.displayName = "CSSMotion";
      return CSSMotion2;
    }
    const CSSMotion = genCSSMotion(supportTransition);
    var STATUS_ADD = "add";
    var STATUS_KEEP = "keep";
    var STATUS_REMOVE = "remove";
    var STATUS_REMOVED = "removed";
    function wrapKeyToObject(key) {
      var keyObj;
      if (key && _typeof$1(key) === "object" && "key" in key) {
        keyObj = key;
      } else {
        keyObj = {
          key
        };
      }
      return _objectSpread2(_objectSpread2({}, keyObj), {}, {
        key: String(keyObj.key)
      });
    }
    function parseKeys() {
      var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return keys2.map(wrapKeyToObject);
    }
    function diffKeys() {
      var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var list = [];
      var currentIndex = 0;
      var currentLen = currentKeys.length;
      var prevKeyObjects = parseKeys(prevKeys);
      var currentKeyObjects = parseKeys(currentKeys);
      prevKeyObjects.forEach(function(keyObj) {
        var hit = false;
        for (var i2 = currentIndex; i2 < currentLen; i2 += 1) {
          var currentKeyObj = currentKeyObjects[i2];
          if (currentKeyObj.key === keyObj.key) {
            if (currentIndex < i2) {
              list = list.concat(currentKeyObjects.slice(currentIndex, i2).map(function(obj) {
                return _objectSpread2(_objectSpread2({}, obj), {}, {
                  status: STATUS_ADD
                });
              }));
              currentIndex = i2;
            }
            list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
              status: STATUS_KEEP
            }));
            currentIndex += 1;
            hit = true;
            break;
          }
        }
        if (!hit) {
          list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
            status: STATUS_REMOVE
          }));
        }
      });
      if (currentIndex < currentLen) {
        list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
          return _objectSpread2(_objectSpread2({}, obj), {}, {
            status: STATUS_ADD
          });
        }));
      }
      var keys2 = {};
      list.forEach(function(_ref) {
        var key = _ref.key;
        keys2[key] = (keys2[key] || 0) + 1;
      });
      var duplicatedKeys = Object.keys(keys2).filter(function(key) {
        return keys2[key] > 1;
      });
      duplicatedKeys.forEach(function(matchKey) {
        list = list.filter(function(_ref2) {
          var key = _ref2.key, status2 = _ref2.status;
          return key !== matchKey || status2 !== STATUS_REMOVE;
        });
        list.forEach(function(node2) {
          if (node2.key === matchKey) {
            node2.status = STATUS_KEEP;
          }
        });
      });
      return list;
    }
    var _excluded$4 = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2 = ["status"];
    var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
    function genCSSMotionList(transitionSupport) {
      var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
      var CSSMotionList = /* @__PURE__ */ function(_React$Component) {
        _inherits$a(CSSMotionList2, _React$Component);
        var _super = _createSuper(CSSMotionList2);
        function CSSMotionList2() {
          var _this;
          _classCallCheck$a(this, CSSMotionList2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty$2(_assertThisInitialized(_this), "state", {
            keyEntities: []
          });
          _defineProperty$2(_assertThisInitialized(_this), "removeKey", function(removeKey) {
            var keyEntities = _this.state.keyEntities;
            var nextKeyEntities = keyEntities.map(function(entity) {
              if (entity.key !== removeKey)
                return entity;
              return _objectSpread2(_objectSpread2({}, entity), {}, {
                status: STATUS_REMOVED
              });
            });
            _this.setState({
              keyEntities: nextKeyEntities
            });
            return nextKeyEntities.filter(function(_ref) {
              var status2 = _ref.status;
              return status2 !== STATUS_REMOVED;
            }).length;
          });
          return _this;
        }
        _createClass$8(CSSMotionList2, [{
          key: "render",
          value: function render2() {
            var _this2 = this;
            var keyEntities = this.state.keyEntities;
            var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties$2(_this$props, _excluded$4);
            var Component = component || reactExports.Fragment;
            var motionProps = {};
            MOTION_PROP_NAMES.forEach(function(prop) {
              motionProps[prop] = restProps[prop];
              delete restProps[prop];
            });
            delete restProps.keys;
            return /* @__PURE__ */ reactExports.createElement(Component, restProps, keyEntities.map(function(_ref2) {
              var status2 = _ref2.status, eventProps = _objectWithoutProperties$2(_ref2, _excluded2);
              var visible = status2 === STATUS_ADD || status2 === STATUS_KEEP;
              return /* @__PURE__ */ reactExports.createElement(CSSMotion$1, _extends$g({}, motionProps, {
                key: eventProps.key,
                visible,
                eventProps,
                onVisibleChanged: function onVisibleChanged(changedVisible) {
                  _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                    key: eventProps.key
                  });
                  if (!changedVisible) {
                    var restKeysCount = _this2.removeKey(eventProps.key);
                    if (restKeysCount === 0 && onAllRemoved) {
                      onAllRemoved();
                    }
                  }
                }
              }), children);
            }));
          }
        }], [{
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(_ref3, _ref4) {
            var keys2 = _ref3.keys;
            var keyEntities = _ref4.keyEntities;
            var parsedKeyObjects = parseKeys(keys2);
            var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
            return {
              keyEntities: mixedKeyEntities.filter(function(entity) {
                var prevEntity = keyEntities.find(function(_ref5) {
                  var key = _ref5.key;
                  return entity.key === key;
                });
                if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                  return false;
                }
                return true;
              })
            };
          }
          // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
        }]);
        return CSSMotionList2;
      }(reactExports.Component);
      _defineProperty$2(CSSMotionList, "defaultProps", {
        component: "div"
      });
      return CSSMotionList;
    }
    genCSSMotionList(supportTransition);
    const {
      isValidElement
    } = React$2;
    function isFragment(child) {
      return child && isValidElement(child) && child.type === reactExports.Fragment;
    }
    function replaceElement(element, replacement, props) {
      if (!isValidElement(element)) {
        return replacement;
      }
      return /* @__PURE__ */ reactExports.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
    }
    function cloneElement(element, props) {
      return replaceElement(element, element, props);
    }
    function useEvent(callback) {
      var fnRef = reactExports.useRef();
      fnRef.current = callback;
      var memoFn = reactExports.useCallback(function() {
        var _fnRef$current;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
      }, []);
      return memoFn;
    }
    var KeyCode = {
      /**
       * MAC_ENTER
       */
      MAC_ENTER: 3,
      /**
       * BACKSPACE
       */
      BACKSPACE: 8,
      /**
       * TAB
       */
      TAB: 9,
      /**
       * NUMLOCK on FF/Safari Mac
       */
      NUM_CENTER: 12,
      // NUMLOCK on FF/Safari Mac
      /**
       * ENTER
       */
      ENTER: 13,
      /**
       * SHIFT
       */
      SHIFT: 16,
      /**
       * CTRL
       */
      CTRL: 17,
      /**
       * ALT
       */
      ALT: 18,
      /**
       * PAUSE
       */
      PAUSE: 19,
      /**
       * CAPS_LOCK
       */
      CAPS_LOCK: 20,
      /**
       * ESC
       */
      ESC: 27,
      /**
       * SPACE
       */
      SPACE: 32,
      /**
       * PAGE_UP
       */
      PAGE_UP: 33,
      // also NUM_NORTH_EAST
      /**
       * PAGE_DOWN
       */
      PAGE_DOWN: 34,
      // also NUM_SOUTH_EAST
      /**
       * END
       */
      END: 35,
      // also NUM_SOUTH_WEST
      /**
       * HOME
       */
      HOME: 36,
      // also NUM_NORTH_WEST
      /**
       * LEFT
       */
      LEFT: 37,
      // also NUM_WEST
      /**
       * UP
       */
      UP: 38,
      // also NUM_NORTH
      /**
       * RIGHT
       */
      RIGHT: 39,
      // also NUM_EAST
      /**
       * DOWN
       */
      DOWN: 40,
      // also NUM_SOUTH
      /**
       * PRINT_SCREEN
       */
      PRINT_SCREEN: 44,
      /**
       * INSERT
       */
      INSERT: 45,
      // also NUM_INSERT
      /**
       * DELETE
       */
      DELETE: 46,
      // also NUM_DELETE
      /**
       * ZERO
       */
      ZERO: 48,
      /**
       * ONE
       */
      ONE: 49,
      /**
       * TWO
       */
      TWO: 50,
      /**
       * THREE
       */
      THREE: 51,
      /**
       * FOUR
       */
      FOUR: 52,
      /**
       * FIVE
       */
      FIVE: 53,
      /**
       * SIX
       */
      SIX: 54,
      /**
       * SEVEN
       */
      SEVEN: 55,
      /**
       * EIGHT
       */
      EIGHT: 56,
      /**
       * NINE
       */
      NINE: 57,
      /**
       * QUESTION_MARK
       */
      QUESTION_MARK: 63,
      // needs localization
      /**
       * A
       */
      A: 65,
      /**
       * B
       */
      B: 66,
      /**
       * C
       */
      C: 67,
      /**
       * D
       */
      D: 68,
      /**
       * E
       */
      E: 69,
      /**
       * F
       */
      F: 70,
      /**
       * G
       */
      G: 71,
      /**
       * H
       */
      H: 72,
      /**
       * I
       */
      I: 73,
      /**
       * J
       */
      J: 74,
      /**
       * K
       */
      K: 75,
      /**
       * L
       */
      L: 76,
      /**
       * M
       */
      M: 77,
      /**
       * N
       */
      N: 78,
      /**
       * O
       */
      O: 79,
      /**
       * P
       */
      P: 80,
      /**
       * Q
       */
      Q: 81,
      /**
       * R
       */
      R: 82,
      /**
       * S
       */
      S: 83,
      /**
       * T
       */
      T: 84,
      /**
       * U
       */
      U: 85,
      /**
       * V
       */
      V: 86,
      /**
       * W
       */
      W: 87,
      /**
       * X
       */
      X: 88,
      /**
       * Y
       */
      Y: 89,
      /**
       * Z
       */
      Z: 90,
      /**
       * META
       */
      META: 91,
      // WIN_KEY_LEFT
      /**
       * WIN_KEY_RIGHT
       */
      WIN_KEY_RIGHT: 92,
      /**
       * CONTEXT_MENU
       */
      CONTEXT_MENU: 93,
      /**
       * NUM_ZERO
       */
      NUM_ZERO: 96,
      /**
       * NUM_ONE
       */
      NUM_ONE: 97,
      /**
       * NUM_TWO
       */
      NUM_TWO: 98,
      /**
       * NUM_THREE
       */
      NUM_THREE: 99,
      /**
       * NUM_FOUR
       */
      NUM_FOUR: 100,
      /**
       * NUM_FIVE
       */
      NUM_FIVE: 101,
      /**
       * NUM_SIX
       */
      NUM_SIX: 102,
      /**
       * NUM_SEVEN
       */
      NUM_SEVEN: 103,
      /**
       * NUM_EIGHT
       */
      NUM_EIGHT: 104,
      /**
       * NUM_NINE
       */
      NUM_NINE: 105,
      /**
       * NUM_MULTIPLY
       */
      NUM_MULTIPLY: 106,
      /**
       * NUM_PLUS
       */
      NUM_PLUS: 107,
      /**
       * NUM_MINUS
       */
      NUM_MINUS: 109,
      /**
       * NUM_PERIOD
       */
      NUM_PERIOD: 110,
      /**
       * NUM_DIVISION
       */
      NUM_DIVISION: 111,
      /**
       * F1
       */
      F1: 112,
      /**
       * F2
       */
      F2: 113,
      /**
       * F3
       */
      F3: 114,
      /**
       * F4
       */
      F4: 115,
      /**
       * F5
       */
      F5: 116,
      /**
       * F6
       */
      F6: 117,
      /**
       * F7
       */
      F7: 118,
      /**
       * F8
       */
      F8: 119,
      /**
       * F9
       */
      F9: 120,
      /**
       * F10
       */
      F10: 121,
      /**
       * F11
       */
      F11: 122,
      /**
       * F12
       */
      F12: 123,
      /**
       * NUMLOCK
       */
      NUMLOCK: 144,
      /**
       * SEMICOLON
       */
      SEMICOLON: 186,
      // needs localization
      /**
       * DASH
       */
      DASH: 189,
      // needs localization
      /**
       * EQUALS
       */
      EQUALS: 187,
      // needs localization
      /**
       * COMMA
       */
      COMMA: 188,
      // needs localization
      /**
       * PERIOD
       */
      PERIOD: 190,
      // needs localization
      /**
       * SLASH
       */
      SLASH: 191,
      // needs localization
      /**
       * APOSTROPHE
       */
      APOSTROPHE: 192,
      // needs localization
      /**
       * SINGLE_QUOTE
       */
      SINGLE_QUOTE: 222,
      // needs localization
      /**
       * OPEN_SQUARE_BRACKET
       */
      OPEN_SQUARE_BRACKET: 219,
      // needs localization
      /**
       * BACKSLASH
       */
      BACKSLASH: 220,
      // needs localization
      /**
       * CLOSE_SQUARE_BRACKET
       */
      CLOSE_SQUARE_BRACKET: 221,
      // needs localization
      /**
       * WIN_KEY
       */
      WIN_KEY: 224,
      /**
       * MAC_FF_META
       */
      MAC_FF_META: 224,
      // Firefox (Gecko) fires this for the meta key instead of 91
      /**
       * WIN_IME
       */
      WIN_IME: 229,
      // ======================== Function ========================
      /**
       * whether text and modified key is entered at the same time.
       */
      isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
        var keyCode = e2.keyCode;
        if (e2.altKey && !e2.ctrlKey || e2.metaKey || // Function keys don't generate text
        keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
          return false;
        }
        switch (keyCode) {
          case KeyCode.ALT:
          case KeyCode.CAPS_LOCK:
          case KeyCode.CONTEXT_MENU:
          case KeyCode.CTRL:
          case KeyCode.DOWN:
          case KeyCode.END:
          case KeyCode.ESC:
          case KeyCode.HOME:
          case KeyCode.INSERT:
          case KeyCode.LEFT:
          case KeyCode.MAC_FF_META:
          case KeyCode.META:
          case KeyCode.NUMLOCK:
          case KeyCode.NUM_CENTER:
          case KeyCode.PAGE_DOWN:
          case KeyCode.PAGE_UP:
          case KeyCode.PAUSE:
          case KeyCode.PRINT_SCREEN:
          case KeyCode.RIGHT:
          case KeyCode.SHIFT:
          case KeyCode.UP:
          case KeyCode.WIN_KEY:
          case KeyCode.WIN_KEY_RIGHT:
            return false;
          default:
            return true;
        }
      },
      /**
       * whether character is entered.
       */
      isCharacterKey: function isCharacterKey(keyCode) {
        if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
          return true;
        }
        if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
          return true;
        }
        if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
          return true;
        }
        if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
          return true;
        }
        switch (keyCode) {
          case KeyCode.SPACE:
          case KeyCode.QUESTION_MARK:
          case KeyCode.NUM_PLUS:
          case KeyCode.NUM_MINUS:
          case KeyCode.NUM_PERIOD:
          case KeyCode.NUM_DIVISION:
          case KeyCode.SEMICOLON:
          case KeyCode.DASH:
          case KeyCode.EQUALS:
          case KeyCode.COMMA:
          case KeyCode.PERIOD:
          case KeyCode.SLASH:
          case KeyCode.APOSTROPHE:
          case KeyCode.SINGLE_QUOTE:
          case KeyCode.OPEN_SQUARE_BRACKET:
          case KeyCode.BACKSLASH:
          case KeyCode.CLOSE_SQUARE_BRACKET:
            return true;
          default:
            return false;
        }
      }
    };
    var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
    const LoadingOutlinedSvg = LoadingOutlined$2;
    var LoadingOutlined = function LoadingOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _objectSpread2(_objectSpread2({}, props), {}, {
        ref,
        icon: LoadingOutlinedSvg
      }));
    };
    LoadingOutlined.displayName = "LoadingOutlined";
    const LoadingOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(LoadingOutlined);
    var fullClone = _objectSpread2({}, ReactDOM$1);
    var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
    var createRoot;
    try {
      var mainVersion = Number((version || "").split(".")[0]);
      if (mainVersion >= 18) {
        createRoot = fullClone.createRoot;
      }
    } catch (e2) {
    }
    function toggleWarning(skip) {
      var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$1(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
      }
    }
    var MARK = "__rc_react_root__";
    function modernRender(node2, container) {
      toggleWarning(true);
      var root2 = container[MARK] || createRoot(container);
      toggleWarning(false);
      root2.render(node2);
      container[MARK] = root2;
    }
    function legacyRender(node2, container) {
      reactRender(node2, container);
    }
    function render$1(node2, container) {
      if (createRoot) {
        modernRender(node2, container);
        return;
      }
      legacyRender(node2, container);
    }
    function modernUnmount(_x) {
      return _modernUnmount.apply(this, arguments);
    }
    function _modernUnmount() {
      _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve().then(function() {
                  var _container$MARK;
                  (_container$MARK = container[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
                  delete container[MARK];
                }));
              case 1:
              case "end":
                return _context.stop();
            }
        }, _callee);
      }));
      return _modernUnmount.apply(this, arguments);
    }
    function legacyUnmount(container) {
      unmountComponentAtNode(container);
    }
    function unmount(_x2) {
      return _unmount.apply(this, arguments);
    }
    function _unmount() {
      _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(createRoot !== void 0)) {
                  _context2.next = 2;
                  break;
                }
                return _context2.abrupt("return", modernUnmount(container));
              case 2:
                legacyUnmount(container);
              case 3:
              case "end":
                return _context2.stop();
            }
        }, _callee2);
      }));
      return _unmount.apply(this, arguments);
    }
    const useLocale = (componentName, defaultLocale$1) => {
      const fullLocale = reactExports.useContext(LocaleContext$1);
      const getLocale = reactExports.useMemo(() => {
        var _a;
        const locale2 = defaultLocale$1 || defaultLocale[componentName];
        const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
        return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
      }, [componentName, defaultLocale$1, fullLocale]);
      const getLocaleCode = reactExports.useMemo(() => {
        const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
        if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
          return defaultLocale.locale;
        }
        return localeCode;
      }, [fullLocale]);
      return [getLocale, getLocaleCode];
    };
    const useLocale$1 = useLocale;
    globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const SpaceCompactItemContext = /* @__PURE__ */ reactExports.createContext(null);
    const useCompactItemContext = (prefixCls, direction) => {
      const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
      const compactItemClassnames = reactExports.useMemo(() => {
        if (!compactItemContext)
          return "";
        const {
          compactDirection,
          isFirstItem,
          isLastItem
        } = compactItemContext;
        const separator = compactDirection === "vertical" ? "-vertical-" : "-";
        return classNames({
          [`${prefixCls}-compact${separator}item`]: true,
          [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
          [`${prefixCls}-compact${separator}last-item`]: isLastItem,
          [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
        });
      }, [prefixCls, direction, compactItemContext]);
      return {
        compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
        compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
        compactItemClassnames
      };
    };
    const isVisible = function(element) {
      if (!element) {
        return false;
      }
      if (element instanceof Element) {
        if (element.offsetParent) {
          return true;
        }
        if (element.getBBox) {
          var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
          if (width || height) {
            return true;
          }
        }
        if (element.getBoundingClientRect) {
          var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
          if (_width || _height) {
            return true;
          }
        }
      }
      return false;
    };
    const genWaveStyle = (token2) => {
      const {
        componentCls,
        colorPrimary
      } = token2;
      return {
        [componentCls]: {
          position: "absolute",
          background: "transparent",
          pointerEvents: "none",
          boxSizing: "border-box",
          color: `var(--wave-color, ${colorPrimary})`,
          boxShadow: `0 0 0 0 currentcolor`,
          opacity: 0.2,
          // =================== Motion ===================
          "&.wave-motion-appear": {
            transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
            "&-active": {
              boxShadow: `0 0 0 6px currentcolor`,
              opacity: 0
            }
          }
        }
      };
    };
    const useStyle$4 = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
    function isNotGrey(color) {
      const match = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
      if (match && match[1] && match[2] && match[3]) {
        return !(match[1] === match[2] && match[2] === match[3]);
      }
      return true;
    }
    function isValidWaveColor(color) {
      return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
      color !== "transparent";
    }
    function getTargetWaveColor(node2) {
      const {
        borderTopColor,
        borderColor,
        backgroundColor
      } = getComputedStyle(node2);
      if (isValidWaveColor(borderTopColor)) {
        return borderTopColor;
      }
      if (isValidWaveColor(borderColor)) {
        return borderColor;
      }
      if (isValidWaveColor(backgroundColor)) {
        return backgroundColor;
      }
      return null;
    }
    function validateNum(value) {
      return Number.isNaN(value) ? 0 : value;
    }
    const WaveEffect = (props) => {
      const {
        className,
        target
      } = props;
      const divRef = reactExports.useRef(null);
      const [color, setWaveColor] = reactExports.useState(null);
      const [borderRadius, setBorderRadius] = reactExports.useState([]);
      const [left, setLeft] = reactExports.useState(0);
      const [top, setTop] = reactExports.useState(0);
      const [width, setWidth] = reactExports.useState(0);
      const [height, setHeight] = reactExports.useState(0);
      const [enabled, setEnabled] = reactExports.useState(false);
      const waveStyle = {
        left,
        top,
        width,
        height,
        borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
      };
      if (color) {
        waveStyle["--wave-color"] = color;
      }
      function syncPos() {
        const nodeStyle = getComputedStyle(target);
        setWaveColor(getTargetWaveColor(target));
        const isStatic = nodeStyle.position === "static";
        const {
          borderLeftWidth,
          borderTopWidth
        } = nodeStyle;
        setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
        setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
        setWidth(target.offsetWidth);
        setHeight(target.offsetHeight);
        const {
          borderTopLeftRadius,
          borderTopRightRadius,
          borderBottomLeftRadius,
          borderBottomRightRadius
        } = nodeStyle;
        setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
      }
      reactExports.useEffect(() => {
        if (target) {
          const id2 = wrapperRaf(() => {
            syncPos();
            setEnabled(true);
          });
          let resizeObserver2;
          if (typeof ResizeObserver !== "undefined") {
            resizeObserver2 = new ResizeObserver(syncPos);
            resizeObserver2.observe(target);
          }
          return () => {
            wrapperRaf.cancel(id2);
            resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
          };
        }
      }, []);
      if (!enabled) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        visible: true,
        motionAppear: true,
        motionName: "wave-motion",
        motionDeadline: 5e3,
        onAppearEnd: (_, event) => {
          var _a;
          if (event.deadline || event.propertyName === "opacity") {
            const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
            unmount(holder).then(() => {
              var _a2;
              (_a2 = holder.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(holder);
            });
          }
          return false;
        }
      }, (_ref) => {
        let {
          className: motionClassName
        } = _ref;
        return /* @__PURE__ */ reactExports.createElement("div", {
          ref: divRef,
          className: classNames(className, motionClassName),
          style: waveStyle
        });
      });
    };
    function showWaveEffect(node2, className) {
      const holder = document.createElement("div");
      holder.style.position = "absolute";
      holder.style.left = `0px`;
      holder.style.top = `0px`;
      node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
      render$1(/* @__PURE__ */ reactExports.createElement(WaveEffect, {
        target: node2,
        className
      }), holder);
    }
    function useWave(nodeRef, className) {
      function showWave() {
        const node2 = nodeRef.current;
        showWaveEffect(node2, className);
      }
      return showWave;
    }
    const Wave = (props) => {
      const {
        children,
        disabled
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const containerRef = reactExports.useRef(null);
      const prefixCls = getPrefixCls("wave");
      const [, hashId] = useStyle$4(prefixCls);
      const showWave = useWave(containerRef, classNames(prefixCls, hashId));
      React$1.useEffect(() => {
        const node2 = containerRef.current;
        if (!node2 || node2.nodeType !== 1 || disabled) {
          return;
        }
        const onClick = (e2) => {
          if (e2.target.tagName === "INPUT" || !isVisible(e2.target) || // No need wave
          !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
            return;
          }
          showWave();
        };
        node2.addEventListener("click", onClick, true);
        return () => {
          node2.removeEventListener("click", onClick, true);
        };
      }, [disabled]);
      if (!/* @__PURE__ */ React$1.isValidElement(children)) {
        return children !== null && children !== void 0 ? children : null;
      }
      const ref = supportRef(children) ? composeRef(children.ref, containerRef) : containerRef;
      return cloneElement(children, {
        ref
      });
    };
    const Wave$1 = Wave;
    var __rest$9 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const GroupSizeContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const ButtonGroup = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        size,
        className
      } = props, others = __rest$9(props, ["prefixCls", "size", "className"]);
      const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
      const [, , hashId] = useToken$2();
      let sizeCls = "";
      switch (size) {
        case "large":
          sizeCls = "lg";
          break;
        case "small":
          sizeCls = "sm";
          break;
      }
      const classes = classNames(prefixCls, {
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, hashId);
      return /* @__PURE__ */ reactExports.createElement(GroupSizeContext.Provider, {
        value: size
      }, /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        className: classes
      })));
    };
    const Group = ButtonGroup;
    const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
    const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
    function isString$1(str) {
      return typeof str === "string";
    }
    function isUnBorderedButtonType(type2) {
      return type2 === "text" || type2 === "link";
    }
    function splitCNCharsBySpace(child, needInserted) {
      if (child === null || child === void 0) {
        return;
      }
      const SPACE = needInserted ? " " : "";
      if (typeof child !== "string" && typeof child !== "number" && isString$1(child.type) && isTwoCNChar(child.props.children)) {
        return cloneElement(child, {
          children: child.props.children.split("").join(SPACE)
        });
      }
      if (typeof child === "string") {
        return isTwoCNChar(child) ? /* @__PURE__ */ React$1.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ React$1.createElement("span", null, child);
      }
      if (isFragment(child)) {
        return /* @__PURE__ */ React$1.createElement("span", null, child);
      }
      return child;
    }
    function spaceChildren(children, needInserted) {
      let isPrevChildPure = false;
      const childList = [];
      React$1.Children.forEach(children, (child) => {
        const type2 = typeof child;
        const isCurrentChildPure = type2 === "string" || type2 === "number";
        if (isPrevChildPure && isCurrentChildPure) {
          const lastIndex = childList.length - 1;
          const lastChild = childList[lastIndex];
          childList[lastIndex] = `${lastChild}${child}`;
        } else {
          childList.push(child);
        }
        isPrevChildPure = isCurrentChildPure;
      });
      return React$1.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
    }
    const getCollapsedWidth = () => ({
      width: 0,
      opacity: 0,
      transform: "scale(0)"
    });
    const getRealWidth = (node2) => ({
      width: node2.scrollWidth,
      opacity: 1,
      transform: "scale(1)"
    });
    const LoadingIcon = (_ref) => {
      let {
        prefixCls,
        loading,
        existIcon
      } = _ref;
      const visible = !!loading;
      if (existIcon) {
        return /* @__PURE__ */ React$1.createElement("span", {
          className: `${prefixCls}-loading-icon`
        }, /* @__PURE__ */ React$1.createElement(LoadingOutlined$1, null));
      }
      return /* @__PURE__ */ React$1.createElement(CSSMotion, {
        visible,
        // We do not really use this motionName
        motionName: `${prefixCls}-loading-icon-motion`,
        removeOnLeave: true,
        onAppearStart: getCollapsedWidth,
        onAppearActive: getRealWidth,
        onEnterStart: getCollapsedWidth,
        onEnterActive: getRealWidth,
        onLeaveStart: getRealWidth,
        onLeaveActive: getCollapsedWidth
      }, (_ref2, ref) => {
        let {
          className,
          style: style2
        } = _ref2;
        return /* @__PURE__ */ React$1.createElement("span", {
          className: `${prefixCls}-loading-icon`,
          style: style2,
          ref
        }, /* @__PURE__ */ React$1.createElement(LoadingOutlined$1, {
          className
        }));
      });
    };
    const LoadingIcon$1 = LoadingIcon;
    const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
      // Border
      [`> span, > ${buttonTypeCls}`]: {
        "&:not(:last-child)": {
          [`&, & > ${buttonTypeCls}`]: {
            "&:not(:disabled)": {
              borderInlineEndColor: borderColor
            }
          }
        },
        "&:not(:first-child)": {
          [`&, & > ${buttonTypeCls}`]: {
            "&:not(:disabled)": {
              borderInlineStartColor: borderColor
            }
          }
        }
      }
    });
    const genGroupStyle$1 = (token2) => {
      const {
        componentCls,
        fontSize,
        lineWidth,
        colorPrimaryHover,
        colorErrorHover
      } = token2;
      return {
        [`${componentCls}-group`]: [
          {
            position: "relative",
            display: "inline-flex",
            // Border
            [`> span, > ${componentCls}`]: {
              "&:not(:last-child)": {
                [`&, & > ${componentCls}`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0
                }
              },
              "&:not(:first-child)": {
                marginInlineStart: -lineWidth,
                [`&, & > ${componentCls}`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0
                }
              }
            },
            [componentCls]: {
              position: "relative",
              zIndex: 1,
              [`&:hover,
          &:focus,
          &:active`]: {
                zIndex: 2
              },
              "&[disabled]": {
                zIndex: 0
              }
            },
            [`${componentCls}-icon-only`]: {
              fontSize
            }
          },
          // Border Color
          genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
          genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
        ]
      };
    };
    const genGroupStyle$2 = genGroupStyle$1;
    function compactItemBorder(token2, parentCls, options) {
      const {
        focusElCls,
        focus,
        borderElCls
      } = options;
      const childCombinator = borderElCls ? "> *" : "";
      const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
      return {
        [`&-item:not(${parentCls}-last-item)`]: {
          marginInlineEnd: -token2.lineWidth
        },
        "&-item": Object.assign(Object.assign({
          [hoverEffects]: {
            zIndex: 2
          }
        }, focusElCls ? {
          [`&${focusElCls}`]: {
            zIndex: 2
          }
        } : {}), {
          [`&[disabled] ${childCombinator}`]: {
            zIndex: 0
          }
        })
      };
    }
    function compactItemBorderRadius(prefixCls, parentCls, options) {
      const {
        borderElCls
      } = options;
      const childCombinator = borderElCls ? `> ${borderElCls}` : "";
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
          borderRadius: 0
        },
        [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        }
      };
    }
    function genCompactItemStyle(token2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        focus: true
      };
      const {
        componentCls
      } = token2;
      const compactCls = `${componentCls}-compact`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
      };
    }
    function compactItemVerticalBorder(token2, parentCls) {
      return {
        // border collapse
        [`&-item:not(${parentCls}-last-item)`]: {
          marginBottom: -token2.lineWidth
        },
        "&-item": {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        }
      };
    }
    function compactItemBorderVerticalRadius(prefixCls, parentCls) {
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
          borderRadius: 0
        },
        [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderEndEndRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0
          }
        }
      };
    }
    function genCompactItemVerticalStyle(token2) {
      const compactCls = `${token2.componentCls}-compact-vertical`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
      };
    }
    const genSharedButtonStyle = (token2) => {
      const {
        componentCls,
        iconCls
      } = token2;
      return {
        [componentCls]: {
          outline: "none",
          position: "relative",
          display: "inline-block",
          fontWeight: 400,
          whiteSpace: "nowrap",
          textAlign: "center",
          backgroundImage: "none",
          backgroundColor: "transparent",
          border: `${token2.lineWidth}px ${token2.lineType} transparent`,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
          userSelect: "none",
          touchAction: "manipulation",
          lineHeight: token2.lineHeight,
          color: token2.colorText,
          "> span": {
            display: "inline-block"
          },
          // Leave a space between icon and text.
          [`> ${iconCls} + span, > span + ${iconCls}`]: {
            marginInlineStart: token2.marginXS
          },
          "> a": {
            color: "currentColor"
          },
          "&:not(:disabled)": Object.assign({}, genFocusStyle(token2)),
          // make `btn-icon-only` not too narrow
          [`&-icon-only${componentCls}-compact-item`]: {
            flex: "none"
          },
          // Special styles for Primary Button
          [`&-compact-item${componentCls}-primary`]: {
            [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: -token2.lineWidth,
                insetInlineStart: -token2.lineWidth,
                display: "inline-block",
                width: token2.lineWidth,
                height: `calc(100% + ${token2.lineWidth * 2}px)`,
                backgroundColor: token2.colorPrimaryHover,
                content: '""'
              }
            }
          },
          // Special styles for Primary Button
          "&-compact-vertical-item": {
            [`&${componentCls}-primary`]: {
              [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
                position: "relative",
                "&:before": {
                  position: "absolute",
                  top: -token2.lineWidth,
                  insetInlineStart: -token2.lineWidth,
                  display: "inline-block",
                  width: `calc(100% + ${token2.lineWidth * 2}px)`,
                  height: token2.lineWidth,
                  backgroundColor: token2.colorPrimaryHover,
                  content: '""'
                }
              }
            }
          }
        }
      };
    };
    const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
      "&:not(:disabled)": {
        "&:hover": hoverStyle,
        "&:active": activeStyle
      }
    });
    const genCircleButtonStyle = (token2) => ({
      minWidth: token2.controlHeight,
      paddingInlineStart: 0,
      paddingInlineEnd: 0,
      borderRadius: "50%"
    });
    const genRoundButtonStyle = (token2) => ({
      borderRadius: token2.controlHeight,
      paddingInlineStart: token2.controlHeight / 2,
      paddingInlineEnd: token2.controlHeight / 2
    });
    const genDisabledStyle$1 = (token2) => ({
      cursor: "not-allowed",
      borderColor: token2.colorBorder,
      color: token2.colorTextDisabled,
      backgroundColor: token2.colorBgContainerDisabled,
      boxShadow: "none"
    });
    const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
      [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
        color: textColor || void 0,
        backgroundColor: "transparent",
        borderColor: borderColor || void 0,
        boxShadow: "none"
      }, genHoverActiveButtonStyle(Object.assign({
        backgroundColor: "transparent"
      }, hoverStyle), Object.assign({
        backgroundColor: "transparent"
      }, activeStyle))), {
        "&:disabled": {
          cursor: "not-allowed",
          color: textColorDisabled || void 0,
          borderColor: borderColorDisabled || void 0
        }
      })
    });
    const genSolidDisabledButtonStyle = (token2) => ({
      "&:disabled": Object.assign({}, genDisabledStyle$1(token2))
    });
    const genSolidButtonStyle = (token2) => Object.assign({}, genSolidDisabledButtonStyle(token2));
    const genPureDisabledButtonStyle = (token2) => ({
      "&:disabled": {
        cursor: "not-allowed",
        color: token2.colorTextDisabled
      }
    });
    const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
      backgroundColor: token2.colorBgContainer,
      borderColor: token2.colorBorder,
      boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
    }), genHoverActiveButtonStyle({
      color: token2.colorPrimaryHover,
      borderColor: token2.colorPrimaryHover
    }, {
      color: token2.colorPrimaryActive,
      borderColor: token2.colorPrimaryActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
        color: token2.colorError,
        borderColor: token2.colorError
      }, genHoverActiveButtonStyle({
        color: token2.colorErrorHover,
        borderColor: token2.colorErrorBorderHover
      }, {
        color: token2.colorErrorActive,
        borderColor: token2.colorErrorActive
      })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
    });
    const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
      color: token2.colorTextLightSolid,
      backgroundColor: token2.colorPrimary,
      boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
    }), genHoverActiveButtonStyle({
      color: token2.colorTextLightSolid,
      backgroundColor: token2.colorPrimaryHover
    }, {
      color: token2.colorTextLightSolid,
      backgroundColor: token2.colorPrimaryActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorPrimaryHover,
      borderColor: token2.colorPrimaryHover
    }, {
      color: token2.colorPrimaryActive,
      borderColor: token2.colorPrimaryActive
    })), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
        backgroundColor: token2.colorError,
        boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
      }, genHoverActiveButtonStyle({
        backgroundColor: token2.colorErrorHover
      }, {
        backgroundColor: token2.colorErrorActive
      })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
        color: token2.colorErrorHover,
        borderColor: token2.colorErrorHover
      }, {
        color: token2.colorErrorActive,
        borderColor: token2.colorErrorActive
      })), genSolidDisabledButtonStyle(token2))
    });
    const genDashedButtonStyle = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle(token2)), {
      borderStyle: "dashed"
    });
    const genLinkButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({
      color: token2.colorLink
    }, genHoverActiveButtonStyle({
      color: token2.colorLinkHover
    }, {
      color: token2.colorLinkActive
    })), genPureDisabledButtonStyle(token2)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
        color: token2.colorError
      }, genHoverActiveButtonStyle({
        color: token2.colorErrorHover
      }, {
        color: token2.colorErrorActive
      })), genPureDisabledButtonStyle(token2))
    });
    const genTextButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle({
      color: token2.colorText,
      backgroundColor: token2.colorBgTextHover
    }, {
      color: token2.colorText,
      backgroundColor: token2.colorBgTextActive
    })), genPureDisabledButtonStyle(token2)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
        color: token2.colorError
      }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
        color: token2.colorErrorHover,
        backgroundColor: token2.colorErrorBg
      }, {
        color: token2.colorErrorHover,
        backgroundColor: token2.colorErrorBg
      }))
    });
    const genDisabledButtonStyle = (token2) => Object.assign(Object.assign({}, genDisabledStyle$1(token2)), {
      [`&${token2.componentCls}:hover`]: Object.assign({}, genDisabledStyle$1(token2))
    });
    const genTypeButtonStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-default`]: genDefaultButtonStyle(token2),
        [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
        [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
        [`${componentCls}-link`]: genLinkButtonStyle(token2),
        [`${componentCls}-text`]: genTextButtonStyle(token2),
        [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
      };
    };
    const genSizeButtonStyle = function(token2) {
      let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const {
        componentCls,
        iconCls,
        controlHeight,
        fontSize,
        lineHeight,
        lineWidth,
        borderRadius,
        buttonPaddingHorizontal
      } = token2;
      const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
      const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
      const iconOnlyCls = `${componentCls}-icon-only`;
      return [
        // Size
        {
          [`${componentCls}${sizePrefixCls}`]: {
            fontSize,
            height: controlHeight,
            padding: `${paddingVertical}px ${paddingHorizontal}px`,
            borderRadius,
            [`&${iconOnlyCls}`]: {
              width: controlHeight,
              paddingInlineStart: 0,
              paddingInlineEnd: 0,
              [`&${componentCls}-round`]: {
                width: "auto"
              },
              "> span": {
                transform: "scale(1.143)"
                // 14px -> 16px
              }
            },
            // Loading
            [`&${componentCls}-loading`]: {
              opacity: token2.opacityLoading,
              cursor: "default"
            },
            [`${componentCls}-loading-icon`]: {
              transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
            },
            [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
              marginInlineEnd: token2.marginXS
            }
          }
        },
        // Shape - patch prefixCls again to override solid border radius style
        {
          [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
        },
        {
          [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
        }
      ];
    };
    const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
    const genSizeSmallButtonStyle = (token2) => {
      const smallToken = merge$2(token2, {
        controlHeight: token2.controlHeightSM,
        padding: token2.paddingXS,
        buttonPaddingHorizontal: 8,
        borderRadius: token2.borderRadiusSM
      });
      return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
    };
    const genSizeLargeButtonStyle = (token2) => {
      const largeToken = merge$2(token2, {
        controlHeight: token2.controlHeightLG,
        fontSize: token2.fontSizeLG,
        borderRadius: token2.borderRadiusLG
      });
      return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
    };
    const genBlockButtonStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          [`&${componentCls}-block`]: {
            width: "100%"
          }
        }
      };
    };
    const useStyle$3 = genComponentStyleHook("Button", (token2) => {
      const {
        controlTmpOutline,
        paddingContentHorizontal
      } = token2;
      const buttonToken = merge$2(token2, {
        colorOutlineDefault: controlTmpOutline,
        buttonPaddingHorizontal: paddingContentHorizontal
      });
      return [
        // Shared
        genSharedButtonStyle(buttonToken),
        // Size
        genSizeSmallButtonStyle(buttonToken),
        genSizeBaseButtonStyle(buttonToken),
        genSizeLargeButtonStyle(buttonToken),
        // Block
        genBlockButtonStyle(buttonToken),
        // Group (type, ghost, danger, disabled, loading)
        genTypeButtonStyle(buttonToken),
        // Button Group
        genGroupStyle$2(buttonToken),
        // Space Compact
        genCompactItemStyle(token2),
        genCompactItemVerticalStyle(token2)
      ];
    });
    var __rest$8 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function getLoadingConfig(loading) {
      if (typeof loading === "object" && loading) {
        const delay = loading === null || loading === void 0 ? void 0 : loading.delay;
        const isDelay = !Number.isNaN(delay) && typeof delay === "number";
        return {
          loading: false,
          delay: isDelay ? delay : 0
        };
      }
      return {
        loading: !!loading,
        delay: 0
      };
    }
    const InternalButton = (props, ref) => {
      const {
        loading = false,
        prefixCls: customizePrefixCls,
        type: type2 = "default",
        danger,
        shape = "default",
        size: customizeSize,
        disabled: customDisabled,
        className,
        rootClassName,
        children,
        icon,
        ghost = false,
        block = false,
        // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
        htmlType = "button"
      } = props, rest = __rest$8(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType"]);
      const {
        getPrefixCls,
        autoInsertSpaceInButton,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("btn", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$3(prefixCls);
      const size = reactExports.useContext(SizeContext$1);
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const groupSize = reactExports.useContext(GroupSizeContext);
      const loadingOrDelay = reactExports.useMemo(() => getLoadingConfig(loading), [loading]);
      const [innerLoading, setLoading] = reactExports.useState(loadingOrDelay.loading);
      const [hasTwoCNChar, setHasTwoCNChar] = reactExports.useState(false);
      const buttonRef = ref || /* @__PURE__ */ reactExports.createRef();
      const isNeedInserted = () => reactExports.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type2);
      const fixTwoCNChar = () => {
        if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
          return;
        }
        const buttonText = buttonRef.current.textContent;
        if (isNeedInserted() && isTwoCNChar(buttonText)) {
          if (!hasTwoCNChar) {
            setHasTwoCNChar(true);
          }
        } else if (hasTwoCNChar) {
          setHasTwoCNChar(false);
        }
      };
      reactExports.useEffect(() => {
        let delayTimer = null;
        if (loadingOrDelay.delay > 0) {
          delayTimer = window.setTimeout(() => {
            delayTimer = null;
            setLoading(true);
          }, loadingOrDelay.delay);
        } else {
          setLoading(loadingOrDelay.loading);
        }
        function cleanupTimer() {
          if (delayTimer) {
            window.clearTimeout(delayTimer);
            delayTimer = null;
          }
        }
        return cleanupTimer;
      }, [loadingOrDelay]);
      reactExports.useEffect(fixTwoCNChar, [buttonRef]);
      const handleClick = (e2) => {
        const {
          onClick
        } = props;
        if (innerLoading || mergedDisabled) {
          e2.preventDefault();
          return;
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(e2);
      };
      const autoInsertSpace = autoInsertSpaceInButton !== false;
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const sizeClassNameMap = {
        large: "lg",
        small: "sm",
        middle: void 0
      };
      const sizeFullname = compactSize || groupSize || customizeSize || size;
      const sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
      const iconType = innerLoading ? "loading" : icon;
      const linkButtonRestProps = omit(rest, ["navigate"]);
      const hrefAndDisabled = linkButtonRestProps.href !== void 0 && mergedDisabled;
      const classes = classNames(prefixCls, hashId, {
        [`${prefixCls}-${shape}`]: shape !== "default" && shape,
        [`${prefixCls}-${type2}`]: type2,
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
        [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(type2),
        [`${prefixCls}-loading`]: innerLoading,
        [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-dangerous`]: !!danger,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-disabled`]: hrefAndDisabled
      }, compactItemClassnames, className, rootClassName);
      const iconNode = icon && !innerLoading ? icon : /* @__PURE__ */ reactExports.createElement(LoadingIcon$1, {
        existIcon: !!icon,
        prefixCls,
        loading: !!innerLoading
      });
      const kids = children || children === 0 ? spaceChildren(children, isNeedInserted() && autoInsertSpace) : null;
      if (linkButtonRestProps.href !== void 0) {
        return wrapSSR(/* @__PURE__ */ reactExports.createElement("a", Object.assign({}, linkButtonRestProps, {
          className: classes,
          onClick: handleClick,
          ref: buttonRef
        }), iconNode, kids));
      }
      let buttonNode = /* @__PURE__ */ reactExports.createElement("button", Object.assign({}, rest, {
        type: htmlType,
        className: classes,
        onClick: handleClick,
        disabled: mergedDisabled,
        ref: buttonRef
      }), iconNode, kids);
      if (!isUnBorderedButtonType(type2)) {
        buttonNode = /* @__PURE__ */ reactExports.createElement(Wave$1, {
          disabled: !!innerLoading
        }, buttonNode);
      }
      return wrapSSR(buttonNode);
    };
    const Button = /* @__PURE__ */ reactExports.forwardRef(InternalButton);
    Button.Group = Group;
    Button.__ANT_BUTTON = true;
    const Button$1 = Button;
    const getTransitionName = (rootPrefixCls, motion, transitionName) => {
      if (transitionName !== void 0) {
        return transitionName;
      }
      return `${rootPrefixCls}-${motion}`;
    };
    var OrderContext = /* @__PURE__ */ reactExports.createContext(null);
    var useLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
    var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
      var firstMountRef = reactExports.useRef(true);
      useLayoutEffect(function() {
        if (!firstMountRef.current) {
          return callback();
        }
      }, deps);
      useLayoutEffect(function() {
        firstMountRef.current = false;
        return function() {
          firstMountRef.current = true;
        };
      }, []);
    };
    var EMPTY_LIST = [];
    function useDom(render2, debug) {
      var _React$useState = reactExports.useState(function() {
        if (!canUseDom()) {
          return null;
        }
        var defaultEle = document.createElement("div");
        return defaultEle;
      }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
      var appendedRef = reactExports.useRef(false);
      var queueCreate = reactExports.useContext(OrderContext);
      var _React$useState3 = reactExports.useState(EMPTY_LIST), _React$useState4 = _slicedToArray(_React$useState3, 2), queue2 = _React$useState4[0], setQueue = _React$useState4[1];
      var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
        setQueue(function(origin) {
          var newQueue = [appendFn].concat(_toConsumableArray(origin));
          return newQueue;
        });
      });
      function append2() {
        if (!ele.parentElement) {
          document.body.appendChild(ele);
        }
        appendedRef.current = true;
      }
      function cleanup2() {
        var _ele$parentElement;
        (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
        appendedRef.current = false;
      }
      useLayoutEffect(function() {
        if (render2) {
          if (queueCreate) {
            queueCreate(append2);
          } else {
            append2();
          }
        } else {
          cleanup2();
        }
        return cleanup2;
      }, [render2]);
      useLayoutEffect(function() {
        if (queue2.length) {
          queue2.forEach(function(appendFn) {
            return appendFn();
          });
          setQueue(EMPTY_LIST);
        }
      }, [queue2]);
      return [ele, mergedQueueCreate];
    }
    var cached;
    function getScrollBarSize(fresh) {
      if (typeof document === "undefined") {
        return 0;
      }
      if (fresh || cached === void 0) {
        var inner = document.createElement("div");
        inner.style.width = "100%";
        inner.style.height = "200px";
        var outer = document.createElement("div");
        var outerStyle = outer.style;
        outerStyle.position = "absolute";
        outerStyle.top = "0";
        outerStyle.left = "0";
        outerStyle.pointerEvents = "none";
        outerStyle.visibility = "hidden";
        outerStyle.width = "200px";
        outerStyle.height = "150px";
        outerStyle.overflow = "hidden";
        outer.appendChild(inner);
        document.body.appendChild(outer);
        var widthContained = inner.offsetWidth;
        outer.style.overflow = "scroll";
        var widthScroll = inner.offsetWidth;
        if (widthContained === widthScroll) {
          widthScroll = outer.clientWidth;
        }
        document.body.removeChild(outer);
        cached = widthContained - widthScroll;
      }
      return cached;
    }
    function isBodyOverflowing() {
      return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
    }
    var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
    var uuid$1 = 0;
    function useScrollLocker(lock) {
      var mergedLock = !!lock;
      var _React$useState = reactExports.useState(function() {
        uuid$1 += 1;
        return "".concat(UNIQUE_ID, "_").concat(uuid$1);
      }), _React$useState2 = _slicedToArray(_React$useState, 1), id2 = _React$useState2[0];
      useLayoutEffect(function() {
        if (mergedLock) {
          var scrollbarSize = getScrollBarSize();
          var isOverflow = isBodyOverflowing();
          updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id2);
        } else {
          removeCSS(id2);
        }
        return function() {
          removeCSS(id2);
        };
      }, [mergedLock, id2]);
    }
    var inline = false;
    function inlineMock(nextInline) {
      if (typeof nextInline === "boolean") {
        inline = nextInline;
      }
      return inline;
    }
    var getPortalContainer = function getPortalContainer2(getContainer2) {
      if (getContainer2 === false) {
        return false;
      }
      if (!canUseDom() || !getContainer2) {
        return null;
      }
      if (typeof getContainer2 === "string") {
        return document.querySelector(getContainer2);
      }
      if (typeof getContainer2 === "function") {
        return getContainer2();
      }
      return getContainer2;
    };
    var Portal = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var open = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer;
      props.debug;
      var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
      var _React$useState = reactExports.useState(open), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
      var mergedRender = shouldRender || open;
      reactExports.useEffect(function() {
        if (autoDestroy || open) {
          setShouldRender(open);
        }
      }, [open, autoDestroy]);
      var _React$useState3 = reactExports.useState(function() {
        return getPortalContainer(getContainer2);
      }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
      reactExports.useEffect(function() {
        var customizeContainer = getPortalContainer(getContainer2);
        setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
      });
      var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer = _useDom2[0], queueCreate = _useDom2[1];
      var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer;
      useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
      var childRef = null;
      if (children && supportRef(children) && ref) {
        var _ref = children;
        childRef = _ref.ref;
      }
      var mergedRef = useComposeRef(childRef, ref);
      if (!mergedRender || !canUseDom() || innerContainer === void 0) {
        return null;
      }
      var renderInline = mergedContainer === false || inlineMock();
      var reffedChildren = children;
      if (ref) {
        reffedChildren = /* @__PURE__ */ reactExports.cloneElement(children, {
          ref: mergedRef
        });
      }
      return /* @__PURE__ */ reactExports.createElement(OrderContext.Provider, {
        value: queueCreate
      }, renderInline ? reffedChildren : /* @__PURE__ */ reactDomExports.createPortal(reffedChildren, mergedContainer));
    });
    function getUseId() {
      var fullClone2 = _objectSpread2({}, React$2);
      return fullClone2.useId;
    }
    var uuid = 0;
    function useId(id2) {
      var _React$useState = reactExports.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      var useOriginId = getUseId();
      var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
      reactExports.useEffect(function() {
        if (!useOriginId) {
          var nextId = uuid;
          uuid += 1;
          setInnerId("rc_unique_".concat(nextId));
        }
      }, []);
      if (id2) {
        return id2;
      }
      return reactNativeId || innerId;
    }
    const FormItemInputContext = /* @__PURE__ */ reactExports.createContext({});
    var isStyleNameSupport = function isStyleNameSupport2(styleName) {
      if (canUseDom() && window.document.documentElement) {
        var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
        var documentElement = window.document.documentElement;
        return styleNameList.some(function(name) {
          return name in documentElement.style;
        });
      }
      return false;
    };
    var isStyleValueSupport = function isStyleValueSupport2(styleName, value) {
      if (!isStyleNameSupport(styleName)) {
        return false;
      }
      var ele = document.createElement("div");
      var origin = ele.style[styleName];
      ele.style[styleName] = value;
      return ele.style[styleName] !== origin;
    };
    function isStyleSupport(styleName, styleValue) {
      if (!Array.isArray(styleName) && styleValue !== void 0) {
        return isStyleValueSupport(styleName, styleValue);
      }
      return isStyleNameSupport(styleName);
    }
    const initMotionCommon = (duration) => ({
      animationDuration: duration,
      animationFillMode: "both"
    });
    const initMotionCommonLeave = (duration) => ({
      animationDuration: duration,
      animationFillMode: "both"
    });
    const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
      let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      const sameLevelPrefix = sameLevel ? "&" : "";
      return {
        [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
          animationPlayState: "paused"
        }),
        [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
          animationPlayState: "paused"
        }),
        [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
          animationName: inKeyframes,
          animationPlayState: "running"
        },
        [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
          animationName: outKeyframes,
          animationPlayState: "running",
          pointerEvents: "none"
        }
      };
    };
    const zoomIn = new Keyframe("antZoomIn", {
      "0%": {
        transform: "scale(0.2)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        opacity: 1
      }
    });
    const zoomOut = new Keyframe("antZoomOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0.2)",
        opacity: 0
      }
    });
    const zoomBigIn = new Keyframe("antZoomBigIn", {
      "0%": {
        transform: "scale(0.8)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        opacity: 1
      }
    });
    const zoomBigOut = new Keyframe("antZoomBigOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0.8)",
        opacity: 0
      }
    });
    const zoomUpIn = new Keyframe("antZoomUpIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
      }
    });
    const zoomUpOut = new Keyframe("antZoomUpOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
      }
    });
    const zoomLeftIn = new Keyframe("antZoomLeftIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
      }
    });
    const zoomLeftOut = new Keyframe("antZoomLeftOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
      }
    });
    const zoomRightIn = new Keyframe("antZoomRightIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
      }
    });
    const zoomRightOut = new Keyframe("antZoomRightOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
      }
    });
    const zoomDownIn = new Keyframe("antZoomDownIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
      }
    });
    const zoomDownOut = new Keyframe("antZoomDownOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
      }
    });
    const zoomMotion = {
      zoom: {
        inKeyframes: zoomIn,
        outKeyframes: zoomOut
      },
      "zoom-big": {
        inKeyframes: zoomBigIn,
        outKeyframes: zoomBigOut
      },
      "zoom-big-fast": {
        inKeyframes: zoomBigIn,
        outKeyframes: zoomBigOut
      },
      "zoom-left": {
        inKeyframes: zoomLeftIn,
        outKeyframes: zoomLeftOut
      },
      "zoom-right": {
        inKeyframes: zoomRightIn,
        outKeyframes: zoomRightOut
      },
      "zoom-up": {
        inKeyframes: zoomUpIn,
        outKeyframes: zoomUpOut
      },
      "zoom-down": {
        inKeyframes: zoomDownIn,
        outKeyframes: zoomDownOut
      }
    };
    const initZoomMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = zoomMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
        [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
          transform: "scale(0)",
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutCirc,
          "&-prepare": {
            transform: "none"
          }
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInOutCirc
        }
      }];
    };
    function hasValue(value) {
      return value !== void 0;
    }
    function useMergedState(defaultStateValue, option) {
      var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
      var _useState = useSafeState(function() {
        if (hasValue(value)) {
          return value;
        } else if (hasValue(defaultValue)) {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        } else {
          return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
        }
      }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
      var mergedValue = value !== void 0 ? value : innerValue;
      var postMergedValue = postState ? postState(mergedValue) : mergedValue;
      var onChangeFn = useEvent(onChange);
      var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
      useLayoutUpdateEffect(function() {
        var prev2 = prevValue[0];
        if (innerValue !== prev2) {
          onChangeFn(innerValue, prev2);
        }
      }, [prevValue]);
      useLayoutUpdateEffect(function() {
        if (!hasValue(value)) {
          setInnerValue(value);
        }
      }, [value]);
      var triggerChange = useEvent(function(updater, ignoreDestroy) {
        setInnerValue(updater, ignoreDestroy);
        setPrevValue([mergedValue], ignoreDestroy);
      });
      return [postMergedValue, triggerChange];
    }
    const isMobile = function() {
      if (typeof navigator === "undefined" || typeof window === "undefined") {
        return false;
      }
      var agent = navigator.userAgent || navigator.vendor || window.opera;
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
    };
    var TriggerContext = /* @__PURE__ */ reactExports.createContext(null);
    function toArray(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function useAction(mobile, action, showAction, hideAction) {
      return reactExports.useMemo(function() {
        var mergedShowAction = toArray(showAction !== null && showAction !== void 0 ? showAction : action);
        var mergedHideAction = toArray(hideAction !== null && hideAction !== void 0 ? hideAction : action);
        var showActionSet = new Set(mergedShowAction);
        var hideActionSet = new Set(mergedHideAction);
        if (mobile) {
          if (showActionSet.has("hover")) {
            showActionSet.delete("hover");
            showActionSet.add("click");
          }
          if (hideActionSet.has("hover")) {
            hideActionSet.delete("hover");
            hideActionSet.add("click");
          }
        }
        return [showActionSet, hideActionSet];
      }, [mobile, action, showAction, hideAction]);
    }
    function isPointsEq() {
      var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
      if (isAlignPoint) {
        return a1[0] === a2[0];
      }
      return a1[0] === a2[0] && a1[1] === a2[1];
    }
    function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
      var points = align.points;
      var placements2 = Object.keys(builtinPlacements);
      for (var i2 = 0; i2 < placements2.length; i2 += 1) {
        var _builtinPlacements$pl;
        var placement = placements2[i2];
        if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
          return "".concat(prefixCls, "-placement-").concat(placement);
        }
      }
      return "";
    }
    function getMotion(prefixCls, motion, animation, transitionName) {
      if (motion) {
        return motion;
      }
      if (animation) {
        return {
          motionName: "".concat(prefixCls, "-").concat(animation)
        };
      }
      if (transitionName) {
        return {
          motionName: transitionName
        };
      }
      return null;
    }
    function getWin(ele) {
      return ele.ownerDocument.defaultView;
    }
    function collectScroller(ele) {
      var scrollerList = [];
      var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
      var scrollStyle = ["hidden", "scroll", "auto"];
      while (current) {
        var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY;
        if (scrollStyle.includes(overflowX) || scrollStyle.includes(overflowY)) {
          scrollerList.push(current);
        }
        current = current.parentElement;
      }
      return scrollerList;
    }
    function toNum(num) {
      return Number.isNaN(num) ? 1 : num;
    }
    function splitPoints() {
      var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return [points[0], points[1]];
    }
    function getAlignPoint(rect, points) {
      var topBottom = points[0];
      var leftRight = points[1];
      var x2;
      var y2;
      if (topBottom === "t") {
        y2 = rect.y;
      } else if (topBottom === "b") {
        y2 = rect.y + rect.height;
      } else {
        y2 = rect.y + rect.height / 2;
      }
      if (leftRight === "l") {
        x2 = rect.x;
      } else if (leftRight === "r") {
        x2 = rect.x + rect.width;
      } else {
        x2 = rect.x + rect.width / 2;
      }
      return {
        x: x2,
        y: y2
      };
    }
    function reversePoints(points, index2) {
      var reverseMap = {
        t: "b",
        b: "t",
        l: "r",
        r: "l"
      };
      return points.map(function(point, i2) {
        if (i2 === index2) {
          return reverseMap[point] || "c";
        }
        return point;
      }).join("");
    }
    function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
      var _React$useState = reactExports.useState({
        ready: false,
        offsetX: 0,
        offsetY: 0,
        arrowX: 0,
        arrowY: 0,
        scaleX: 1,
        scaleY: 1,
        align: builtinPlacements[placement] || {}
      }), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
      var alignCountRef = reactExports.useRef(0);
      var scrollerList = reactExports.useMemo(function() {
        if (!popupEle) {
          return [];
        }
        return collectScroller(popupEle);
      }, [popupEle]);
      var onAlign = useEvent(function() {
        if (popupEle && target && open) {
          let getIntersectionVisibleArea2 = function(x2, y2) {
            var r2 = x2 + popupWidth;
            var b2 = y2 + popupHeight;
            var visibleX = Math.max(x2, visibleArea.left);
            var visibleY = Math.max(y2, visibleArea.top);
            var visibleR = Math.min(r2, visibleArea.right);
            var visibleB = Math.min(b2, visibleArea.bottom);
            return (visibleR - visibleX) * (visibleB - visibleY);
          };
          var getIntersectionVisibleArea = getIntersectionVisibleArea2;
          var popupElement = popupEle;
          var originLeft = popupElement.style.left;
          var originTop = popupElement.style.top;
          var doc = popupElement.ownerDocument;
          var win = getWin(popupElement);
          var placementInfo = _objectSpread2(_objectSpread2({}, builtinPlacements[placement]), popupAlign);
          popupElement.style.left = "0";
          popupElement.style.top = "0";
          var targetRect;
          if (Array.isArray(target)) {
            targetRect = {
              x: target[0],
              y: target[1],
              width: 0,
              height: 0
            };
          } else {
            var rect = target.getBoundingClientRect();
            targetRect = {
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height
            };
          }
          var popupRect = popupElement.getBoundingClientRect();
          var _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height;
          var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
          var popupHeight = popupRect.height;
          var popupWidth = popupRect.width;
          var targetHeight = targetRect.height;
          var targetWidth = targetRect.width;
          var visibleArea = placementInfo.htmlRegion === "scroll" ? (
            // Scroll region should take scrollLeft & scrollTop into account
            {
              left: -scrollLeft,
              top: -scrollTop,
              right: scrollWidth - scrollLeft,
              bottom: scrollHeight - scrollTop
            }
          ) : {
            left: 0,
            top: 0,
            right: clientWidth,
            bottom: clientHeight
          };
          (scrollerList || []).forEach(function(ele) {
            if (ele instanceof HTMLBodyElement) {
              return;
            }
            var eleRect = ele.getBoundingClientRect();
            var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
            var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
            var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
            var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;
            var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;
            var eleRight = eleRect.x + eleRect.width - eleScrollWidth;
            var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;
            visibleArea.left = Math.max(visibleArea.left, eleRect.left);
            visibleArea.top = Math.max(visibleArea.top, eleRect.top);
            visibleArea.right = Math.min(visibleArea.right, eleRight);
            visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
          });
          popupElement.style.left = originLeft;
          popupElement.style.top = originTop;
          var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
          var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
          if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {
            return;
          }
          var offset = placementInfo.offset, targetOffset2 = placementInfo.targetOffset;
          var _ref = offset || [], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$, _ref2$2 = _ref2[1], popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;
          var _ref3 = targetOffset2 || [], _ref4 = _slicedToArray(_ref3, 2), _ref4$ = _ref4[0], targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$, _ref4$2 = _ref4[1], targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;
          targetRect.x += targetOffsetX;
          targetRect.y += targetOffsetY;
          var _ref5 = placementInfo.points || [], _ref6 = _slicedToArray(_ref5, 2), popupPoint = _ref6[0], targetPoint = _ref6[1];
          var targetPoints = splitPoints(targetPoint);
          var popupPoints = splitPoints(popupPoint);
          var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
          var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
          var nextAlignInfo = _objectSpread2({}, placementInfo);
          var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
          var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
          var originIntersectionVisibleArea = getIntersectionVisibleArea2(nextOffsetX, nextOffsetY);
          var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
          var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
          var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
          var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
          var overflow = placementInfo.overflow || {};
          var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
          var supportAdjust = function supportAdjust2(val) {
            if (typeof val === "boolean") {
              return val;
            }
            return val >= 0;
          };
          var nextPopupY = popupRect.y + nextOffsetY;
          var nextPopupBottom = nextPopupY + popupHeight;
          var needAdjustY = supportAdjust(adjustY);
          var sameTB = popupPoints[0] === targetPoints[0];
          if (needAdjustY && popupPoints[0] === "t" && nextPopupBottom > visibleArea.bottom) {
            var tmpNextOffsetY;
            if (sameTB) {
              tmpNextOffsetY -= popupHeight - targetHeight;
            } else {
              tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
            }
            if (getIntersectionVisibleArea2(nextOffsetX, tmpNextOffsetY) > originIntersectionVisibleArea) {
              nextOffsetY = tmpNextOffsetY;
              nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
            }
          }
          if (needAdjustY && popupPoints[0] === "b" && nextPopupY < visibleArea.top) {
            var _tmpNextOffsetY;
            if (sameTB) {
              _tmpNextOffsetY += popupHeight - targetHeight;
            } else {
              _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
            }
            if (getIntersectionVisibleArea2(nextOffsetX, _tmpNextOffsetY) > originIntersectionVisibleArea) {
              nextOffsetY = _tmpNextOffsetY;
              nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
            }
          }
          var nextPopupX = popupRect.x + nextOffsetX;
          var nextPopupRight = nextPopupX + popupWidth;
          var needAdjustX = supportAdjust(adjustX);
          var sameLR = popupPoints[1] === targetPoints[1];
          if (needAdjustX && popupPoints[1] === "l" && nextPopupRight > visibleArea.right) {
            var tmpNextOffsetX;
            if (sameLR) {
              tmpNextOffsetX -= popupWidth - targetWidth;
            } else {
              tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
            }
            if (getIntersectionVisibleArea2(tmpNextOffsetX, nextOffsetY) > originIntersectionVisibleArea) {
              nextOffsetX = tmpNextOffsetX;
              nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
            }
          }
          if (needAdjustX && popupPoints[1] === "r" && nextPopupX < visibleArea.left) {
            var _tmpNextOffsetX;
            if (sameLR) {
              _tmpNextOffsetX += popupWidth - targetWidth;
            } else {
              _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
            }
            if (getIntersectionVisibleArea2(_tmpNextOffsetX, nextOffsetY) > originIntersectionVisibleArea) {
              nextOffsetX = _tmpNextOffsetX;
              nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
            }
          }
          var numShiftX = shiftX === true ? 0 : shiftX;
          if (typeof numShiftX === "number") {
            if (nextPopupX < visibleArea.left) {
              nextOffsetX -= nextPopupX - visibleArea.left;
              if (targetRect.x + targetWidth < visibleArea.left + numShiftX) {
                nextOffsetX += targetRect.x - visibleArea.left + targetWidth - numShiftX;
              }
            }
            if (nextPopupRight > visibleArea.right) {
              nextOffsetX -= nextPopupRight - visibleArea.right;
              if (targetRect.x > visibleArea.right - numShiftX) {
                nextOffsetX += targetRect.x - visibleArea.right + numShiftX;
              }
            }
          }
          var numShiftY = shiftY === true ? 0 : shiftY;
          if (typeof numShiftY === "number") {
            if (nextPopupY < visibleArea.top) {
              nextOffsetY -= nextPopupY - visibleArea.top;
              if (targetRect.y + targetHeight < visibleArea.top + numShiftY) {
                nextOffsetY += targetRect.y - visibleArea.top + targetHeight - numShiftY;
              }
            }
            if (nextPopupBottom > visibleArea.bottom) {
              nextOffsetY -= nextPopupBottom - visibleArea.bottom;
              if (targetRect.y > visibleArea.bottom - numShiftY) {
                nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;
              }
            }
          }
          var popupLeft = popupRect.x + nextOffsetX;
          var popupRight = popupLeft + popupWidth;
          var popupTop = popupRect.y + nextOffsetY;
          var popupBottom = popupTop + popupHeight;
          var targetLeft = targetRect.x;
          var targetRight = targetLeft + targetWidth;
          var targetTop = targetRect.y;
          var targetBottom = targetTop + targetHeight;
          var maxLeft = Math.max(popupLeft, targetLeft);
          var minRight = Math.min(popupRight, targetRight);
          var xCenter = (maxLeft + minRight) / 2;
          var nextArrowX = xCenter - popupLeft;
          var maxTop = Math.max(popupTop, targetTop);
          var minBottom = Math.min(popupBottom, targetBottom);
          var yCenter = (maxTop + minBottom) / 2;
          var nextArrowY = yCenter - popupTop;
          onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);
          setOffsetInfo({
            ready: true,
            offsetX: nextOffsetX / _scaleX,
            offsetY: nextOffsetY / _scaleY,
            arrowX: nextArrowX / _scaleX,
            arrowY: nextArrowY / _scaleY,
            scaleX: _scaleX,
            scaleY: _scaleY,
            align: nextAlignInfo
          });
        }
      });
      var triggerAlign = function triggerAlign2() {
        alignCountRef.current += 1;
        var id2 = alignCountRef.current;
        Promise.resolve().then(function() {
          if (alignCountRef.current === id2) {
            onAlign();
          }
        });
      };
      var resetReady = function resetReady2() {
        setOffsetInfo(function(ori) {
          return _objectSpread2(_objectSpread2({}, ori), {}, {
            ready: false
          });
        });
      };
      useLayoutEffect(resetReady, [placement]);
      useLayoutEffect(function() {
        if (!open) {
          resetReady();
        }
      }, [open]);
      return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
    }
    function useWatch(open, target, popup, onAlign) {
      useLayoutEffect(function() {
        if (open && target && popup) {
          let notifyScroll2 = function() {
            onAlign();
          };
          var notifyScroll = notifyScroll2;
          var targetElement = target;
          var popupElement = popup;
          var targetScrollList = collectScroller(targetElement);
          var popupScrollList = collectScroller(popupElement);
          var win = getWin(popupElement);
          var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
          mergedList.forEach(function(scroller) {
            scroller.addEventListener("scroll", notifyScroll2, {
              passive: true
            });
          });
          win.addEventListener("resize", notifyScroll2, {
            passive: true
          });
          onAlign();
          return function() {
            mergedList.forEach(function(scroller) {
              scroller.removeEventListener("scroll", notifyScroll2);
              win.removeEventListener("resize", notifyScroll2);
            });
          };
        }
      }, [open, target, popup]);
    }
    function Arrow(props) {
      var prefixCls = props.prefixCls, align = props.align, _props$arrowX = props.arrowX, arrowX = _props$arrowX === void 0 ? 0 : _props$arrowX, _props$arrowY = props.arrowY, arrowY = _props$arrowY === void 0 ? 0 : _props$arrowY;
      var arrowRef = reactExports.useRef();
      if (!align || !align.points) {
        return null;
      }
      var alignStyle = {
        position: "absolute"
      };
      if (align.autoArrow !== false) {
        var popupPoints = align.points[0];
        var targetPoints = align.points[1];
        var popupTB = popupPoints[0];
        var popupLR = popupPoints[1];
        var targetTB = targetPoints[0];
        var targetLR = targetPoints[1];
        if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
          alignStyle.top = arrowY;
        } else if (popupTB === "t") {
          alignStyle.top = 0;
        } else {
          alignStyle.bottom = 0;
        }
        if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
          alignStyle.left = arrowX;
        } else if (popupLR === "l") {
          alignStyle.left = 0;
        } else {
          alignStyle.right = 0;
        }
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: arrowRef,
        className: "".concat(prefixCls, "-arrow"),
        style: alignStyle
      });
    }
    function Mask(props) {
      var prefixCls = props.prefixCls, open = props.open, zIndex = props.zIndex, mask = props.mask, motion = props.motion;
      if (!mask) {
        return null;
      }
      return /* @__PURE__ */ React.createElement(CSSMotion, _extends$g({}, motion, {
        motionAppear: true,
        visible: open,
        removeOnLeave: true
      }), function(_ref) {
        var className = _ref.className;
        return /* @__PURE__ */ React.createElement("div", {
          style: {
            zIndex
          },
          className: classNames("".concat(prefixCls, "-mask"), className)
        });
      });
    }
    var Popup$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open = props.open, keepDom = props.keepDom, onClick = props.onClick, mask = props.mask, arrow = props.arrow, align = props.align, arrowX = props.arrowX, arrowY = props.arrowY, motion = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
      var childNode = typeof popup === "function" ? popup() : popup;
      var isNodeVisible = open || keepDom;
      var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
      var _React$useState = reactExports.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
      useLayoutEffect(function() {
        if (!show && getPopupContainerNeedParams && target) {
          setShow(true);
        }
      }, [show, getPopupContainerNeedParams, target]);
      if (!show) {
        return null;
      }
      var offsetStyle = ready || !open ? {
        left: offsetX,
        top: offsetY
      } : {
        left: "-1000vw",
        top: "-1000vh"
      };
      var miscStyle = {};
      if (stretch) {
        if (stretch.includes("height") && targetHeight) {
          miscStyle.height = targetHeight;
        } else if (stretch.includes("minHeight") && targetHeight) {
          miscStyle.minHeight = targetHeight;
        }
        if (stretch.includes("width") && targetWidth) {
          miscStyle.width = targetWidth;
        } else if (stretch.includes("minWidth") && targetWidth) {
          miscStyle.minWidth = targetWidth;
        }
      }
      if (!open) {
        miscStyle.pointerEvents = "none";
      }
      return /* @__PURE__ */ reactExports.createElement(Portal2, {
        open: forceRender || isNodeVisible,
        getContainer: getPopupContainer && function() {
          return getPopupContainer(target);
        },
        autoDestroy
      }, /* @__PURE__ */ reactExports.createElement(Mask, {
        prefixCls,
        open,
        zIndex,
        mask,
        motion: maskMotion
      }), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onAlign,
        disabled: !open
      }, function(resizeObserverRef) {
        return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$g({
          motionAppear: true,
          motionEnter: true,
          motionLeave: true,
          removeOnLeave: false,
          forceRender,
          leavedClassName: "".concat(prefixCls, "-hidden")
        }, motion, {
          onAppearPrepare: onPrepare,
          onEnterPrepare: onPrepare,
          visible: open,
          onVisibleChanged: function onVisibleChanged(nextVisible) {
            var _motion$onVisibleChan;
            motion === null || motion === void 0 ? void 0 : (_motion$onVisibleChan = motion.onVisibleChanged) === null || _motion$onVisibleChan === void 0 ? void 0 : _motion$onVisibleChan.call(motion, nextVisible);
            _onVisibleChanged(nextVisible);
          }
        }), function(_ref, motionRef) {
          var motionClassName = _ref.className, motionStyle = _ref.style;
          var cls = classNames(prefixCls, motionClassName, className);
          return /* @__PURE__ */ reactExports.createElement("div", {
            ref: composeRef(resizeObserverRef, ref, motionRef),
            className: cls,
            style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, offsetStyle), miscStyle), motionStyle), {}, {
              boxSizing: "border-box",
              zIndex
            }, style2),
            onMouseEnter,
            onMouseLeave,
            onClick
          }, arrow && /* @__PURE__ */ reactExports.createElement(Arrow, {
            prefixCls,
            align,
            arrowX,
            arrowY
          }), childNode);
        });
      }));
    });
    var TriggerWrapper = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
      var canUseRef = supportRef(children);
      var setRef = reactExports.useCallback(function(node2) {
        fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
      }, [getTriggerDOMNode]);
      var mergedRef = useComposeRef(setRef, children.ref);
      return canUseRef ? /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: mergedRef
      }) : children;
    });
    var _excluded$3 = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
    function generateTrigger() {
      var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal;
      var Trigger2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties$2(props, _excluded$3);
        var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
        var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
        useLayoutEffect(function() {
          setMobile(isMobile());
        }, []);
        var subPopupElements = reactExports.useRef({});
        var parentContext = reactExports.useContext(TriggerContext);
        var context = reactExports.useMemo(function() {
          return {
            registerSubPopup: function registerSubPopup(id3, subPopupEle) {
              subPopupElements.current[id3] = subPopupEle;
              parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id3, subPopupEle);
            }
          };
        }, [parentContext]);
        var id2 = useId();
        var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
        var setPopupRef = useEvent(function(node2) {
          if (isDOM(node2) && popupEle !== node2) {
            setPopupEle(node2);
          }
          parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id2, node2);
        });
        var _React$useState5 = reactExports.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
        var setTargetRef = useEvent(function(node2) {
          if (isDOM(node2) && targetEle !== node2) {
            setTargetEle(node2);
          }
        });
        var child = reactExports.Children.only(children);
        var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
        var cloneProps = {};
        var inPopupOrChild = useEvent(function(ele) {
          var childDOM = targetEle;
          return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
            return subPopupEle.contains(ele) || ele === subPopupEle;
          });
        });
        var mergePopupMotion = getMotion(prefixCls, popupMotion, popupAnimation, popupTransitionName);
        var mergeMaskMotion = getMotion(prefixCls, maskMotion, maskAnimation, maskTransitionName);
        var _React$useState7 = reactExports.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
        var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
        var setMergedOpen = useEvent(function(nextOpen) {
          if (popupVisible === void 0) {
            setInternalOpen(nextOpen);
          }
        });
        useLayoutEffect(function() {
          setInternalOpen(popupVisible || false);
        }, [popupVisible]);
        var openRef = reactExports.useRef(mergedOpen);
        openRef.current = mergedOpen;
        var internalTriggerOpen = useEvent(function(nextOpen) {
          if (mergedOpen !== nextOpen) {
            setMergedOpen(nextOpen);
            onPopupVisibleChange === null || onPopupVisibleChange === void 0 ? void 0 : onPopupVisibleChange(nextOpen);
          }
        });
        var delayRef = reactExports.useRef();
        var clearDelay = function clearDelay2() {
          clearTimeout(delayRef.current);
        };
        var triggerOpen = function triggerOpen2(nextOpen) {
          var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          clearDelay();
          if (delay === 0) {
            internalTriggerOpen(nextOpen);
          } else {
            delayRef.current = setTimeout(function() {
              internalTriggerOpen(nextOpen);
            }, delay * 1e3);
          }
        };
        reactExports.useEffect(function() {
          return clearDelay;
        }, []);
        var _React$useState9 = reactExports.useState(false), _React$useState10 = _slicedToArray(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
        var mountRef = reactExports.useRef(true);
        useLayoutEffect(function() {
          if (!mountRef.current || mergedOpen) {
            setInMotion(true);
          }
          mountRef.current = true;
        }, [mergedOpen]);
        var _React$useState11 = reactExports.useState(null), _React$useState12 = _slicedToArray(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
        var _React$useState13 = reactExports.useState([0, 0]), _React$useState14 = _slicedToArray(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
        var setMousePosByEvent = function setMousePosByEvent2(event) {
          setMousePos([event.clientX, event.clientY]);
        };
        var _useAlign = useAlign(mergedOpen, popupEle, alignPoint ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 9), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], arrowX = _useAlign2[3], arrowY = _useAlign2[4], scaleX = _useAlign2[5], scaleY = _useAlign2[6], alignInfo = _useAlign2[7], onAlign = _useAlign2[8];
        var triggerAlign = useEvent(function() {
          if (!inMotion) {
            onAlign();
          }
        });
        useWatch(mergedOpen, targetEle, popupEle, triggerAlign);
        useLayoutEffect(function() {
          triggerAlign();
        }, [mousePos]);
        useLayoutEffect(function() {
          if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
            triggerAlign();
          }
        }, [JSON.stringify(popupAlign)]);
        var alignedClassName = reactExports.useMemo(function() {
          var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
          return classNames(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
        }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
        reactExports.useImperativeHandle(ref, function() {
          return {
            forceAlign: triggerAlign
          };
        });
        var onVisibleChanged = function onVisibleChanged2(visible) {
          setInMotion(false);
          onAlign();
          afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 ? void 0 : afterPopupVisibleChange(visible);
        };
        var onPrepare = function onPrepare2() {
          return new Promise(function(resolve) {
            setMotionPrepareResolve(function() {
              return resolve;
            });
          });
        };
        useLayoutEffect(function() {
          if (motionPrepareResolve) {
            onAlign();
            motionPrepareResolve();
            setMotionPrepareResolve(null);
          }
        }, [motionPrepareResolve]);
        var _React$useState15 = reactExports.useState(0), _React$useState16 = _slicedToArray(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
        var _React$useState17 = reactExports.useState(0), _React$useState18 = _slicedToArray(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
        var onTargetResize = function onTargetResize2(_, ele) {
          triggerAlign();
          if (stretch) {
            var rect = ele.getBoundingClientRect();
            setTargetWidth(rect.width);
            setTargetHeight(rect.height);
          }
        };
        var _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
        var wrapperAction = function wrapperAction2(eventName, nextOpen, delay, preEvent) {
          cloneProps[eventName] = function(event) {
            var _originChildProps$eve;
            preEvent === null || preEvent === void 0 ? void 0 : preEvent(event);
            triggerOpen(nextOpen, delay);
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 ? void 0 : _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
          };
        };
        var clickToShow = showActions.has("click");
        var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
        if (clickToShow || clickToHide) {
          cloneProps.onClick = function(event) {
            var _originChildProps$onC;
            if (openRef.current && clickToHide) {
              triggerOpen(false);
            } else if (!openRef.current && clickToShow) {
              setMousePosByEvent(event);
              triggerOpen(true);
            }
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 ? void 0 : _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
          };
        }
        reactExports.useEffect(function() {
          if (clickToHide && popupEle && (!mask || maskClosable)) {
            var onWindowClick = function onWindowClick2(_ref) {
              var target = _ref.target;
              if (openRef.current && !inPopupOrChild(target)) {
                triggerOpen(false);
              }
            };
            var win = getWin(popupEle);
            win.addEventListener("click", onWindowClick);
            return function() {
              win.removeEventListener("click", onWindowClick);
            };
          }
        }, [clickToHide, popupEle, mask, maskClosable]);
        var hoverToShow = showActions.has("hover");
        var hoverToHide = hideActions.has("hover");
        var onPopupMouseEnter;
        var onPopupMouseLeave;
        if (hoverToShow) {
          wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
            setMousePosByEvent(event);
          });
          onPopupMouseEnter = function onPopupMouseEnter2() {
            triggerOpen(true, mouseEnterDelay);
          };
          if (alignPoint) {
            cloneProps.onMouseMove = function(event) {
              var _originChildProps$onM;
              (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 ? void 0 : _originChildProps$onM.call(originChildProps, event);
            };
          }
        }
        if (hoverToHide) {
          wrapperAction("onMouseLeave", false, mouseLeaveDelay);
          onPopupMouseLeave = function onPopupMouseLeave2() {
            triggerOpen(false, mouseLeaveDelay);
          };
        }
        if (showActions.has("focus")) {
          wrapperAction("onFocus", true, focusDelay);
        }
        if (hideActions.has("focus")) {
          wrapperAction("onBlur", false, blurDelay);
        }
        if (showActions.has("contextMenu")) {
          cloneProps.onContextMenu = function(event) {
            var _originChildProps$onC2;
            setMousePosByEvent(event);
            triggerOpen(true);
            event.preventDefault();
            for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }
            (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 ? void 0 : _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
          };
        }
        if (className) {
          cloneProps.className = classNames(originChildProps.className, className);
        }
        var mergedChildrenProps = _objectSpread2(_objectSpread2({}, originChildProps), cloneProps);
        var passedProps = {};
        var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
        passedEventList.forEach(function(eventName) {
          if (restProps[eventName]) {
            passedProps[eventName] = function() {
              var _mergedChildrenProps$;
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 ? void 0 : _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
              restProps[eventName].apply(restProps, args);
            };
          }
        });
        var triggerNode = /* @__PURE__ */ reactExports.cloneElement(child, _objectSpread2(_objectSpread2({}, mergedChildrenProps), passedProps));
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          disabled: !mergedOpen,
          ref: setTargetRef,
          onResize: onTargetResize
        }, /* @__PURE__ */ reactExports.createElement(TriggerWrapper, {
          getTriggerDOMNode
        }, triggerNode)), /* @__PURE__ */ reactExports.createElement(TriggerContext.Provider, {
          value: context
        }, /* @__PURE__ */ reactExports.createElement(Popup$1, {
          portal: PortalComponent,
          ref: setPopupRef,
          prefixCls,
          popup,
          className: classNames(popupClassName, alignedClassName),
          style: popupStyle,
          target: targetEle,
          onMouseEnter: onPopupMouseEnter,
          onMouseLeave: onPopupMouseLeave,
          zIndex,
          open: mergedOpen,
          keepDom: inMotion,
          onClick: onPopupClick,
          mask,
          motion: mergePopupMotion,
          maskMotion: mergeMaskMotion,
          onVisibleChanged,
          onPrepare,
          forceRender,
          autoDestroy: mergedAutoDestroy,
          getPopupContainer,
          align: alignInfo,
          arrow,
          ready,
          offsetX,
          offsetY,
          arrowX,
          arrowY,
          onAlign: triggerAlign,
          stretch,
          targetWidth: targetWidth / scaleX,
          targetHeight: targetHeight / scaleY
        })));
      });
      return Trigger2;
    }
    const Trigger = generateTrigger(Portal);
    function getStatusClassNames(prefixCls, status2, hasFeedback) {
      return classNames({
        [`${prefixCls}-status-success`]: status2 === "success",
        [`${prefixCls}-status-warning`]: status2 === "warning",
        [`${prefixCls}-status-error`]: status2 === "error",
        [`${prefixCls}-status-validating`]: status2 === "validating",
        [`${prefixCls}-has-feedback`]: hasFeedback
      });
    }
    const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
    var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
    const CheckOutlinedSvg = CheckOutlined$2;
    var CheckOutlined = function CheckOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _objectSpread2(_objectSpread2({}, props), {}, {
        ref,
        icon: CheckOutlinedSvg
      }));
    };
    CheckOutlined.displayName = "CheckOutlined";
    const CheckOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CheckOutlined);
    var autoAdjustOverflowTopBottom = {
      shiftX: 64,
      adjustY: 1
    };
    var autoAdjustOverflowLeftRight = {
      adjustX: 1,
      shiftY: true
    };
    var targetOffset = [0, 0];
    var placements = {
      left: {
        points: ["cr", "cl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset
      },
      right: {
        points: ["cl", "cr"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset
      },
      top: {
        points: ["bc", "tc"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset
      },
      bottom: {
        points: ["tc", "bc"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset
      },
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset
      },
      leftTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset
      },
      rightTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset
      },
      rightBottom: {
        points: ["bl", "br"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset
      },
      leftBottom: {
        points: ["br", "bl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset
      }
    };
    function Popup(props) {
      var children = props.children, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content"), className),
        style: style2
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-inner"),
        id: id2,
        role: "tooltip",
        style: overlayInnerStyle
      }, typeof children === "function" ? children() : children));
    }
    var _excluded$2 = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
    var Tooltip$2 = function Tooltip2(props, ref) {
      var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
      props.arrowContent;
      var overlay = props.overlay, id2 = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, restProps = _objectWithoutProperties$2(props, _excluded$2);
      var triggerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return triggerRef.current;
      });
      var extraProps = _objectSpread2({}, restProps);
      if ("visible" in props) {
        extraProps.popupVisible = props.visible;
      }
      var getPopupElement = function getPopupElement2() {
        return /* @__PURE__ */ reactExports.createElement(Popup, {
          key: "content",
          prefixCls,
          id: id2,
          overlayInnerStyle
        }, overlay);
      };
      return /* @__PURE__ */ reactExports.createElement(Trigger, _extends$g({
        popupClassName: overlayClassName,
        prefixCls,
        popup: getPopupElement,
        action: trigger,
        builtinPlacements: placements,
        popupPlacement: placement,
        ref: triggerRef,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        onPopupVisibleChange: onVisibleChange,
        afterPopupVisibleChange: afterVisibleChange,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupMotion: motion,
        defaultPopupVisible: defaultVisible,
        autoDestroy: destroyTooltipOnHide,
        mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay,
        arrow: showArrow
      }, extraProps), children);
    };
    const Tooltip$3 = /* @__PURE__ */ reactExports.forwardRef(Tooltip$2);
    const getAlphaColor = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
    const getSolidColor = (baseColor, brightness) => {
      const instance = new TinyColor(baseColor);
      return instance.lighten(brightness).toHexString();
    };
    const generateColorPalettes = (baseColor) => {
      const colors = generate$1(baseColor, {
        theme: "dark"
      });
      return {
        1: colors[0],
        2: colors[1],
        3: colors[2],
        4: colors[3],
        5: colors[6],
        6: colors[5],
        7: colors[4],
        8: colors[6],
        9: colors[5],
        10: colors[4]
        // 8: colors[9],
        // 9: colors[8],
        // 10: colors[7],
      };
    };
    const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
      const colorBgBase = bgBaseColor || "#000";
      const colorTextBase = textBaseColor || "#fff";
      return {
        colorBgBase,
        colorTextBase,
        colorText: getAlphaColor(colorTextBase, 0.85),
        colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
        colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
        colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
        colorFill: getAlphaColor(colorTextBase, 0.18),
        colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
        colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
        colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
        colorBgElevated: getSolidColor(colorBgBase, 12),
        colorBgContainer: getSolidColor(colorBgBase, 8),
        colorBgLayout: getSolidColor(colorBgBase, 0),
        colorBgSpotlight: getSolidColor(colorBgBase, 26),
        colorBorder: getSolidColor(colorBgBase, 26),
        colorBorderSecondary: getSolidColor(colorBgBase, 19)
      };
    };
    const derivative$1 = (token2, mapToken) => {
      const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
        const colors = generate$1(token2[colorKey], {
          theme: "dark"
        });
        return new Array(10).fill(1).reduce((prev2, _, i2) => {
          prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
          prev2[`${colorKey}${i2 + 1}`] = colors[i2];
          return prev2;
        }, {});
      }).reduce((prev2, cur) => {
        prev2 = Object.assign(Object.assign({}, prev2), cur);
        return prev2;
      }, {});
      const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
      return Object.assign(Object.assign(Object.assign({}, mergedMapToken), colorPalettes), genColorMapToken(token2, {
        generateColorPalettes,
        generateNeutralColorPalettes
      }));
    };
    const darkAlgorithm = derivative$1;
    function genSizeMapToken(token2) {
      const {
        sizeUnit,
        sizeStep
      } = token2;
      const compactSizeStep = sizeStep - 2;
      return {
        sizeXXL: sizeUnit * (compactSizeStep + 10),
        sizeXL: sizeUnit * (compactSizeStep + 6),
        sizeLG: sizeUnit * (compactSizeStep + 2),
        sizeMD: sizeUnit * (compactSizeStep + 2),
        sizeMS: sizeUnit * (compactSizeStep + 1),
        size: sizeUnit * compactSizeStep,
        sizeSM: sizeUnit * compactSizeStep,
        sizeXS: sizeUnit * (compactSizeStep - 1),
        sizeXXS: sizeUnit * (compactSizeStep - 1)
      };
    }
    const derivative = (token2, mapToken) => {
      const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
      const fontSize = mergedMapToken.fontSizeSM;
      const controlHeight = mergedMapToken.controlHeight - 4;
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, mergedMapToken), genSizeMapToken(mapToken !== null && mapToken !== void 0 ? mapToken : token2)), genFontMapToken$1(fontSize)), {
        // controlHeight
        controlHeight
      }), genControlHeight$1(Object.assign(Object.assign({}, mergedMapToken), {
        controlHeight
      })));
    };
    const compactAlgorithm = derivative;
    function useToken$1() {
      const [theme2, token2, hashId] = useToken$2();
      return {
        theme: theme2,
        token: token2,
        hashId
      };
    }
    const theme = {
      /** @private Test Usage. Do not use in production. */
      defaultConfig,
      /** Default seedToken */
      defaultSeed: defaultConfig.token,
      useToken: useToken$1,
      defaultAlgorithm: derivative$2,
      darkAlgorithm,
      compactAlgorithm
    };
    const MAX_VERTICAL_CONTENT_RADIUS = 8;
    function getArrowOffset(options) {
      const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
      const {
        contentRadius,
        limitVerticalRadius
      } = options;
      const dropdownArrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
      const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius : dropdownArrowOffset;
      return {
        dropdownArrowOffset,
        dropdownArrowOffsetVertical
      };
    }
    function isInject(valid, code2) {
      if (!valid)
        return {};
      return code2;
    }
    function getArrowStyle(token2, options) {
      const {
        componentCls,
        sizePopupArrow,
        borderRadiusXS,
        borderRadiusOuter,
        boxShadowPopoverArrow
      } = token2;
      const {
        colorBg,
        contentRadius = token2.borderRadiusLG,
        limitVerticalRadius,
        arrowDistance = 0,
        arrowPlacement = {
          left: true,
          right: true,
          top: true,
          bottom: true
        }
      } = options;
      const {
        dropdownArrowOffsetVertical,
        dropdownArrowOffset
      } = getArrowOffset({
        contentRadius,
        limitVerticalRadius
      });
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
          // ============================ Basic ============================
          [`${componentCls}-arrow`]: [Object.assign(Object.assign({
            position: "absolute",
            zIndex: 1,
            display: "block"
          }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
            "&:before": {
              background: colorBg
            }
          })]
        }, isInject(!!arrowPlacement.top, {
          [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
            bottom: arrowDistance,
            transform: "translateY(100%) rotate(180deg)"
          },
          [`&-placement-top ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%) translateY(100%) rotate(180deg)"
          },
          [`&-placement-topLeft ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          },
          [`&-placement-topRight ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          }
        })), isInject(!!arrowPlacement.bottom, {
          [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
            top: arrowDistance,
            transform: `translateY(-100%)`
          },
          [`&-placement-bottom ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: `translateX(-50%) translateY(-100%)`
          },
          [`&-placement-bottomLeft ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          },
          [`&-placement-bottomRight ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: dropdownArrowOffset
            }
          }
        })), isInject(!!arrowPlacement.left, {
          [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
            right: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(100%) rotate(90deg)"
          },
          [`&-placement-left ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(100%) rotate(90deg)"
          },
          [`&-placement-leftTop ${componentCls}-arrow`]: {
            top: dropdownArrowOffsetVertical
          },
          [`&-placement-leftBottom ${componentCls}-arrow`]: {
            bottom: dropdownArrowOffsetVertical
          }
        })), isInject(!!arrowPlacement.right, {
          [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
            left: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-right ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-rightTop ${componentCls}-arrow`]: {
            top: dropdownArrowOffsetVertical
          },
          [`&-placement-rightBottom ${componentCls}-arrow`]: {
            bottom: dropdownArrowOffsetVertical
          }
        }))
      };
    }
    function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow) {
      if (autoAdjustOverflow === false) {
        return {
          adjustX: false,
          adjustY: false
        };
      }
      const overflow = autoAdjustOverflow && typeof autoAdjustOverflow === "object" ? autoAdjustOverflow : {};
      const baseOverflow = {};
      switch (placement) {
        case "top":
        case "bottom":
          baseOverflow.shiftX = arrowOffset.dropdownArrowOffset * 2 + arrowWidth;
          break;
        case "left":
        case "right":
          baseOverflow.shiftY = arrowOffset.dropdownArrowOffsetVertical * 2 + arrowWidth;
          break;
      }
      const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
      if (!mergedOverflow.shiftX) {
        mergedOverflow.adjustX = true;
      }
      if (!mergedOverflow.shiftY) {
        mergedOverflow.adjustY = true;
      }
      return mergedOverflow;
    }
    const PlacementAlignMap = {
      left: {
        points: ["cr", "cl"]
      },
      right: {
        points: ["cl", "cr"]
      },
      top: {
        points: ["bc", "tc"]
      },
      bottom: {
        points: ["tc", "bc"]
      },
      topLeft: {
        points: ["bl", "tl"]
      },
      leftTop: {
        points: ["tr", "tl"]
      },
      topRight: {
        points: ["br", "tr"]
      },
      rightTop: {
        points: ["tl", "tr"]
      },
      bottomRight: {
        points: ["tr", "br"]
      },
      rightBottom: {
        points: ["bl", "br"]
      },
      bottomLeft: {
        points: ["tl", "bl"]
      },
      leftBottom: {
        points: ["br", "bl"]
      }
    };
    const ArrowCenterPlacementAlignMap = {
      topLeft: {
        points: ["bl", "tc"]
      },
      leftTop: {
        points: ["tr", "cl"]
      },
      topRight: {
        points: ["br", "tc"]
      },
      rightTop: {
        points: ["tl", "cr"]
      },
      bottomRight: {
        points: ["tr", "bc"]
      },
      rightBottom: {
        points: ["bl", "cr"]
      },
      bottomLeft: {
        points: ["tl", "bc"]
      },
      leftBottom: {
        points: ["br", "cl"]
      }
    };
    const DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
    function getPlacements(config) {
      const {
        arrowWidth,
        autoAdjustOverflow,
        arrowPointAtCenter,
        offset,
        borderRadius
      } = config;
      const halfArrowWidth = arrowWidth / 2;
      const placementMap = {};
      Object.keys(PlacementAlignMap).forEach((key) => {
        const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
        const placementInfo = Object.assign(Object.assign({}, template), {
          offset: [0, 0]
        });
        placementMap[key] = placementInfo;
        if (DisableAutoArrowList.has(key)) {
          placementInfo.autoArrow = false;
        }
        switch (key) {
          case "top":
          case "topLeft":
          case "topRight":
            placementInfo.offset[1] = -halfArrowWidth - offset;
            break;
          case "bottom":
          case "bottomLeft":
          case "bottomRight":
            placementInfo.offset[1] = halfArrowWidth + offset;
            break;
          case "left":
          case "leftTop":
          case "leftBottom":
            placementInfo.offset[0] = -halfArrowWidth - offset;
            break;
          case "right":
          case "rightTop":
          case "rightBottom":
            placementInfo.offset[0] = halfArrowWidth + offset;
            break;
        }
        const arrowOffset = getArrowOffset({
          contentRadius: borderRadius,
          limitVerticalRadius: true
        });
        if (arrowPointAtCenter) {
          switch (key) {
            case "topLeft":
            case "bottomLeft":
              placementInfo.offset[0] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
              break;
            case "topRight":
            case "bottomRight":
              placementInfo.offset[0] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
              break;
            case "leftTop":
            case "rightTop":
              placementInfo.offset[1] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
              break;
            case "leftBottom":
            case "rightBottom":
              placementInfo.offset[1] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
              break;
          }
        }
        placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow);
      });
      return placementMap;
    }
    const genTooltipStyle = (token2) => {
      const {
        componentCls,
        // ant-tooltip
        tooltipMaxWidth,
        tooltipColor,
        tooltipBg,
        tooltipBorderRadius,
        zIndexPopup,
        controlHeight,
        boxShadowSecondary,
        paddingSM,
        paddingXS,
        tooltipRadiusOuter
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "absolute",
            zIndex: zIndexPopup,
            display: "block",
            width: "max-content",
            maxWidth: tooltipMaxWidth,
            visibility: "visible",
            "&-hidden": {
              display: "none"
            },
            "--antd-arrow-background-color": tooltipBg,
            // Wrapper for the tooltip content
            [`${componentCls}-inner`]: {
              minWidth: controlHeight,
              minHeight: controlHeight,
              padding: `${paddingSM / 2}px ${paddingXS}px`,
              color: tooltipColor,
              textAlign: "start",
              textDecoration: "none",
              wordWrap: "break-word",
              backgroundColor: tooltipBg,
              borderRadius: tooltipBorderRadius,
              boxShadow: boxShadowSecondary
            },
            // Limit left and right placement radius
            [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
              [`${componentCls}-inner`]: {
                borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
              }
            },
            [`${componentCls}-content`]: {
              position: "relative"
            }
          }), genPresetColor(token2, (colorKey, _ref) => {
            let {
              darkColor
            } = _ref;
            return {
              [`&${componentCls}-${colorKey}`]: {
                [`${componentCls}-inner`]: {
                  backgroundColor: darkColor
                },
                [`${componentCls}-arrow`]: {
                  "--antd-arrow-background-color": darkColor
                }
              }
            };
          })), {
            // RTL
            "&-rtl": {
              direction: "rtl"
            }
          })
        },
        // Arrow Style
        getArrowStyle(merge$2(token2, {
          borderRadiusOuter: tooltipRadiusOuter
        }), {
          colorBg: "var(--antd-arrow-background-color)",
          contentRadius: tooltipBorderRadius,
          limitVerticalRadius: true
        }),
        // Pure Render
        {
          [`${componentCls}-pure`]: {
            position: "relative",
            maxWidth: "none",
            margin: token2.sizePopupArrow
          }
        }
      ];
    };
    const useStyle$2 = (prefixCls, injectStyle) => {
      const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
        if (injectStyle === false) {
          return [];
        }
        const {
          borderRadius,
          colorTextLightSolid,
          colorBgDefault,
          borderRadiusOuter
        } = token2;
        const TooltipToken = merge$2(token2, {
          // default variables
          tooltipMaxWidth: 250,
          tooltipColor: colorTextLightSolid,
          tooltipBorderRadius: borderRadius,
          tooltipBg: colorBgDefault,
          tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
        });
        return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
      }, (_ref2) => {
        let {
          zIndexPopupBase,
          colorBgSpotlight
        } = _ref2;
        return {
          zIndexPopup: zIndexPopupBase + 70,
          colorBgDefault: colorBgSpotlight
        };
      });
      return useOriginHook(prefixCls);
    };
    const inverseColors = PresetColors.map((color) => `${color}-inverse`);
    function isPresetColor(color) {
      let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (includeInverse) {
        return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
      }
      return PresetColors.includes(color);
    }
    function parseColor(prefixCls, color) {
      const isInternalColor = isPresetColor(color);
      const className = classNames({
        [`${prefixCls}-${color}`]: color && isInternalColor
      });
      const overlayStyle = {};
      const arrowStyle = {};
      if (color && !isInternalColor) {
        overlayStyle.background = color;
        arrowStyle["--antd-arrow-background-color"] = color;
      }
      return {
        className,
        overlayStyle,
        arrowStyle
      };
    }
    function PurePanel(props) {
      const {
        prefixCls: customizePrefixCls,
        className,
        placement = "top",
        title,
        color,
        overlayInnerStyle
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle$2(prefixCls, true);
      const colorInfo = parseColor(prefixCls, color);
      const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
      const arrowContentStyle = colorInfo.arrowStyle;
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className),
        style: arrowContentStyle
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-arrow`
      }), /* @__PURE__ */ reactExports.createElement(Popup, Object.assign({}, props, {
        className: hashId,
        prefixCls,
        overlayInnerStyle: formattedOverlayInnerStyle
      }), title)));
    }
    var __rest$7 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const {
      useToken
    } = theme;
    const splitObject = (obj, keys2) => {
      const picked = {};
      const omitted = Object.assign({}, obj);
      keys2.forEach((key) => {
        if (obj && key in obj) {
          picked[key] = obj[key];
          delete omitted[key];
        }
      });
      return {
        picked,
        omitted
      };
    };
    function getDisabledCompatibleChildren(element, prefixCls) {
      const elementType = element.type;
      if ((elementType.__ANT_BUTTON === true || element.type === "button") && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
        const {
          picked,
          omitted
        } = splitObject(element.props.style, ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
        const spanStyle = Object.assign(Object.assign({
          display: "inline-block"
        }, picked), {
          cursor: "not-allowed",
          width: element.props.block ? "100%" : void 0
        });
        const buttonStyle = Object.assign(Object.assign({}, omitted), {
          pointerEvents: "none"
        });
        const child = cloneElement(element, {
          style: buttonStyle,
          className: null
        });
        return /* @__PURE__ */ reactExports.createElement("span", {
          style: spanStyle,
          className: classNames(element.props.className, `${prefixCls}-disabled-compatible-wrapper`)
        }, child);
      }
      return element;
    }
    const Tooltip = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b;
      const {
        prefixCls: customizePrefixCls,
        openClassName,
        getTooltipContainer,
        overlayClassName,
        color,
        overlayInnerStyle,
        children,
        afterOpenChange,
        afterVisibleChange,
        destroyTooltipOnHide,
        arrow = true
      } = props;
      const mergedShowArrow = !!arrow;
      const {
        token: token2
      } = useToken();
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const tooltipRef = reactExports.useRef(null);
      const forceAlign = () => {
        var _a2;
        (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
      };
      reactExports.useImperativeHandle(ref, () => ({
        forceAlign,
        forcePopupAlign: () => {
          forceAlign();
        }
      }));
      const [open, setOpen] = useMergedState(false, {
        value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
        defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
      });
      const isNoTitle = () => {
        const {
          title,
          overlay
        } = props;
        return !title && !overlay && title !== 0;
      };
      const onOpenChange = (vis) => {
        var _a2, _b2;
        setOpen(isNoTitle() ? false : vis);
        if (!isNoTitle()) {
          (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
          (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
        }
      };
      const getTooltipPlacements = () => {
        var _a2, _b2;
        const {
          builtinPlacements,
          arrowPointAtCenter = false,
          autoAdjustOverflow = true
        } = props;
        let mergedArrowPointAtCenter = arrowPointAtCenter;
        if (typeof arrow === "object") {
          mergedArrowPointAtCenter = (_b2 = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
        }
        return builtinPlacements || getPlacements({
          arrowPointAtCenter: mergedArrowPointAtCenter,
          autoAdjustOverflow,
          arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
          borderRadius: token2.borderRadius,
          offset: token2.marginXXS
        });
      };
      const onPopupAlign = (domNode, align) => {
        const placements2 = getTooltipPlacements();
        const placement2 = Object.keys(placements2).find((key) => {
          var _a2, _b2;
          return placements2[key].points[0] === ((_a2 = align.points) === null || _a2 === void 0 ? void 0 : _a2[0]) && placements2[key].points[1] === ((_b2 = align.points) === null || _b2 === void 0 ? void 0 : _b2[1]);
        });
        if (placement2) {
          const rect = domNode.getBoundingClientRect();
          const transformOrigin = {
            top: "50%",
            left: "50%"
          };
          if (/top|Bottom/.test(placement2)) {
            transformOrigin.top = `${rect.height - align.offset[1]}px`;
          } else if (/Top|bottom/.test(placement2)) {
            transformOrigin.top = `${-align.offset[1]}px`;
          }
          if (/left|Right/.test(placement2)) {
            transformOrigin.left = `${rect.width - align.offset[0]}px`;
          } else if (/right|Left/.test(placement2)) {
            transformOrigin.left = `${-align.offset[0]}px`;
          }
          domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
        }
      };
      const getOverlay = () => {
        const {
          title,
          overlay
        } = props;
        if (title === 0) {
          return title;
        }
        return overlay || title || "";
      };
      const {
        getPopupContainer,
        placement = "top",
        mouseEnterDelay = 0.1,
        mouseLeaveDelay = 0.1,
        overlayStyle,
        rootClassName
      } = props, otherProps = __rest$7(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
      const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const injectFromPopover = props["data-popover-inject"];
      let tempOpen = open;
      if (!("open" in props) && !("visible" in props) && isNoTitle()) {
        tempOpen = false;
      }
      const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ reactExports.createElement("span", null, children), prefixCls);
      const childProps = child.props;
      const childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, {
        [openClassName || `${prefixCls}-open`]: true
      }) : childProps.className;
      const [wrapSSR, hashId] = useStyle$2(prefixCls, !injectFromPopover);
      const colorInfo = parseColor(prefixCls, color);
      const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
      const arrowContentStyle = colorInfo.arrowStyle;
      const customOverlayClassName = classNames(overlayClassName, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, colorInfo.className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(Tooltip$3, Object.assign({}, otherProps, {
        showArrow: mergedShowArrow,
        placement,
        mouseEnterDelay,
        mouseLeaveDelay,
        prefixCls,
        overlayClassName: customOverlayClassName,
        overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
        getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
        ref: tooltipRef,
        builtinPlacements: getTooltipPlacements(),
        overlay: getOverlay(),
        visible: tempOpen,
        onVisibleChange: onOpenChange,
        afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
        onPopupAlign,
        overlayInnerStyle: formattedOverlayInnerStyle,
        arrowContent: /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-arrow-content`
        }),
        motion: {
          motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
          motionDeadline: 1e3
        },
        destroyTooltipOnHide: !!destroyTooltipOnHide
      }), tempOpen ? cloneElement(child, {
        className: childCls
      }) : child));
    });
    Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
    const Tooltip$1 = Tooltip;
    const genPlaceholderStyle = (color) => ({
      // Firefox
      "&::-moz-placeholder": {
        opacity: 1
      },
      "&::placeholder": {
        color,
        userSelect: "none"
        // https://github.com/ant-design/ant-design/pull/32639
      },
      "&:placeholder-shown": {
        textOverflow: "ellipsis"
      }
    });
    const genHoverStyle = (token2) => ({
      borderColor: token2.inputBorderHoverColor,
      borderInlineEndWidth: token2.lineWidth
    });
    const genActiveStyle = (token2) => ({
      borderColor: token2.inputBorderHoverColor,
      boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
      borderInlineEndWidth: token2.lineWidth,
      outline: 0
    });
    const genDisabledStyle = (token2) => ({
      color: token2.colorTextDisabled,
      backgroundColor: token2.colorBgContainerDisabled,
      borderColor: token2.colorBorder,
      boxShadow: "none",
      cursor: "not-allowed",
      opacity: 1,
      "&:hover": Object.assign({}, genHoverStyle(merge$2(token2, {
        inputBorderHoverColor: token2.colorBorder
      })))
    });
    const genInputLargeStyle = (token2) => {
      const {
        inputPaddingVerticalLG,
        fontSizeLG,
        lineHeightLG,
        borderRadiusLG,
        inputPaddingHorizontalLG
      } = token2;
      return {
        padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderRadius: borderRadiusLG
      };
    };
    const genInputSmallStyle = (token2) => ({
      padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
      borderRadius: token2.borderRadiusSM
    });
    const genStatusStyle = (token2, parentCls) => {
      const {
        componentCls,
        colorError,
        colorWarning,
        colorErrorOutline,
        colorWarningOutline,
        colorErrorBorderHover,
        colorWarningBorderHover
      } = token2;
      return {
        [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
          borderColor: colorError,
          "&:hover": {
            borderColor: colorErrorBorderHover
          },
          "&:focus, &-focused": Object.assign({}, genActiveStyle(merge$2(token2, {
            inputBorderActiveColor: colorError,
            inputBorderHoverColor: colorError,
            controlOutline: colorErrorOutline
          }))),
          [`${componentCls}-prefix, ${componentCls}-suffix`]: {
            color: colorError
          }
        },
        [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
          borderColor: colorWarning,
          "&:hover": {
            borderColor: colorWarningBorderHover
          },
          "&:focus, &-focused": Object.assign({}, genActiveStyle(merge$2(token2, {
            inputBorderActiveColor: colorWarning,
            inputBorderHoverColor: colorWarning,
            controlOutline: colorWarningOutline
          }))),
          [`${componentCls}-prefix, ${componentCls}-suffix`]: {
            color: colorWarning
          }
        }
      };
    };
    const genBasicInputStyle = (token2) => Object.assign(Object.assign({
      position: "relative",
      display: "inline-block",
      width: "100%",
      minWidth: 0,
      padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
      color: token2.colorText,
      fontSize: token2.fontSize,
      lineHeight: token2.lineHeight,
      backgroundColor: token2.colorBgContainer,
      backgroundImage: "none",
      borderWidth: token2.lineWidth,
      borderStyle: token2.lineType,
      borderColor: token2.colorBorder,
      borderRadius: token2.borderRadius,
      transition: `all ${token2.motionDurationMid}`
    }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
      "&:hover": Object.assign({}, genHoverStyle(token2)),
      "&:focus, &-focused": Object.assign({}, genActiveStyle(token2)),
      "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle(token2)),
      "&-borderless": {
        "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
          backgroundColor: "transparent",
          border: "none",
          boxShadow: "none"
        }
      },
      // Reset height for `textarea`s
      "textarea&": {
        maxWidth: "100%",
        height: "auto",
        minHeight: token2.controlHeight,
        lineHeight: token2.lineHeight,
        verticalAlign: "bottom",
        transition: `all ${token2.motionDurationSlow}, height 0s`,
        resize: "vertical"
      },
      // Size
      "&-lg": Object.assign({}, genInputLargeStyle(token2)),
      "&-sm": Object.assign({}, genInputSmallStyle(token2)),
      // RTL
      "&-rtl": {
        direction: "rtl"
      },
      "&-textarea-rtl": {
        direction: "rtl"
      }
    });
    const genInputGroupStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return {
        position: "relative",
        display: "table",
        width: "100%",
        borderCollapse: "separate",
        borderSpacing: 0,
        // Undo padding and float of grid classes
        [`&[class*='col-']`]: {
          paddingInlineEnd: token2.paddingXS,
          "&:last-child": {
            paddingInlineEnd: 0
          }
        },
        // Sizing options
        [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
        [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
        // Fix https://github.com/ant-design/ant-design/issues/5754
        [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token2.controlHeightLG
        },
        [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token2.controlHeightSM
        },
        [`> ${componentCls}`]: {
          display: "table-cell",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        [`${componentCls}-group`]: {
          [`&-addon, &-wrap`]: {
            display: "table-cell",
            width: 1,
            whiteSpace: "nowrap",
            verticalAlign: "middle",
            "&:not(:first-child):not(:last-child)": {
              borderRadius: 0
            }
          },
          "&-wrap > *": {
            display: "block !important"
          },
          "&-addon": {
            position: "relative",
            padding: `0 ${token2.inputPaddingHorizontal}px`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.fontSize,
            textAlign: "center",
            backgroundColor: token2.colorFillAlter,
            border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadius,
            transition: `all ${token2.motionDurationSlow}`,
            lineHeight: 1,
            // Reset Select's style in addon
            [`${antCls}-select`]: {
              margin: `-${token2.inputPaddingVertical + 1}px -${token2.inputPaddingHorizontal}px`,
              [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
                [`${antCls}-select-selector`]: {
                  backgroundColor: "inherit",
                  border: `${token2.lineWidth}px ${token2.lineType} transparent`,
                  boxShadow: "none"
                }
              },
              "&-open, &-focused": {
                [`${antCls}-select-selector`]: {
                  color: token2.colorPrimary
                }
              }
            },
            // https://github.com/ant-design/ant-design/issues/31333
            [`${antCls}-cascader-picker`]: {
              margin: `-9px -${token2.inputPaddingHorizontal}px`,
              backgroundColor: "transparent",
              [`${antCls}-cascader-input`]: {
                textAlign: "start",
                border: 0,
                boxShadow: "none"
              }
            }
          },
          "&-addon:first-child": {
            borderInlineEnd: 0
          },
          "&-addon:last-child": {
            borderInlineStart: 0
          }
        },
        [`${componentCls}`]: {
          width: "100%",
          marginBottom: 0,
          textAlign: "inherit",
          "&:focus": {
            zIndex: 1,
            borderInlineEndWidth: 1
          },
          "&:hover": {
            zIndex: 1,
            borderInlineEndWidth: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          }
        },
        // Reset rounded corners
        [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}-affix-wrapper`]: {
          [`&:not(:first-child) ${componentCls}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          },
          [`&:not(:last-child) ${componentCls}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          "&:not(:last-child)": {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            [`${componentCls}-search &`]: {
              borderStartStartRadius: token2.borderRadius,
              borderEndStartRadius: token2.borderRadius
            }
          },
          [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
          display: "block"
        }, clearFix()), {
          [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
            "&:not(:first-child):not(:last-child)": {
              borderInlineEndWidth: token2.lineWidth,
              "&:hover": {
                zIndex: 1
              },
              "&:focus": {
                zIndex: 1
              }
            }
          },
          "& > *": {
            display: "inline-block",
            float: "none",
            verticalAlign: "top",
            borderRadius: 0
          },
          [`& > ${componentCls}-affix-wrapper`]: {
            display: "inline-flex"
          },
          [`& > ${antCls}-picker-range`]: {
            display: "inline-flex"
          },
          "& > *:not(:last-child)": {
            marginInlineEnd: -token2.lineWidth,
            borderInlineEndWidth: token2.lineWidth
          },
          // Undo float for .ant-input-group .ant-input
          [`${componentCls}`]: {
            float: "none"
          },
          // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
          [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
            borderInlineEndWidth: token2.lineWidth,
            borderRadius: 0,
            "&:hover": {
              zIndex: 1
            },
            "&:focus": {
              zIndex: 1
            }
          },
          [`& > ${antCls}-select-focused`]: {
            zIndex: 1
          },
          // update z-index for arrow icon
          [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
            zIndex: 1
            // https://github.com/ant-design/ant-design/issues/20371
          },
          [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderEndStartRadius: token2.borderRadius
          },
          [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
            borderInlineEndWidth: token2.lineWidth,
            borderStartEndRadius: token2.borderRadius,
            borderEndEndRadius: token2.borderRadius
          },
          // https://github.com/ant-design/ant-design/issues/12493
          [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
            verticalAlign: "top"
          },
          [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
            marginInlineStart: -token2.lineWidth,
            [`${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`${componentCls}-group-wrapper:not(:last-child)`]: {
            [`&${componentCls}-search > ${componentCls}-group`]: {
              [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
                borderRadius: 0
              },
              [`& > ${componentCls}`]: {
                borderStartStartRadius: token2.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: token2.borderRadius
              }
            }
          }
        })
      };
    };
    const genInputStyle = (token2) => {
      const {
        componentCls,
        controlHeightSM,
        lineWidth
      } = token2;
      const FIXED_CHROME_COLOR_HEIGHT = 16;
      const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
          '&[type="color"]': {
            height: token2.controlHeight,
            [`&${componentCls}-lg`]: {
              height: token2.controlHeightLG
            },
            [`&${componentCls}-sm`]: {
              height: controlHeightSM,
              paddingTop: colorSmallPadding,
              paddingBottom: colorSmallPadding
            }
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
            "-webkit-appearance": "none"
          }
        })
      };
    };
    const genAllowClearStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // ========================= Input =========================
        [`${componentCls}-clear-icon`]: {
          margin: 0,
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          verticalAlign: -1,
          // https://github.com/ant-design/ant-design/pull/18151
          // https://codesandbox.io/s/wizardly-sun-u10br
          cursor: "pointer",
          transition: `color ${token2.motionDurationSlow}`,
          "&:hover": {
            color: token2.colorTextTertiary
          },
          "&:active": {
            color: token2.colorText
          },
          "&-hidden": {
            visibility: "hidden"
          },
          "&-has-suffix": {
            margin: `0 ${token2.inputAffixPadding}px`
          }
        }
      };
    };
    const genAffixStyle = (token2) => {
      const {
        componentCls,
        inputAffixPadding,
        colorTextDescription,
        motionDurationSlow,
        colorIcon,
        colorIconHover,
        iconCls
      } = token2;
      return {
        [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
          display: "inline-flex",
          [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: Object.assign(Object.assign({}, genHoverStyle(token2)), {
            zIndex: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          }),
          "&-focused, &:focus": {
            zIndex: 1
          },
          "&-disabled": {
            [`${componentCls}[disabled]`]: {
              background: "transparent"
            }
          },
          [`> input${componentCls}`]: {
            padding: 0,
            fontSize: "inherit",
            border: "none",
            borderRadius: 0,
            outline: "none",
            "&:focus": {
              boxShadow: "none !important"
            }
          },
          "&::before": {
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          },
          [`${componentCls}`]: {
            "&-prefix, &-suffix": {
              display: "flex",
              flex: "none",
              alignItems: "center",
              "> *:not(:last-child)": {
                marginInlineEnd: token2.paddingXS
              }
            },
            "&-show-count-suffix": {
              color: colorTextDescription
            },
            "&-show-count-has-suffix": {
              marginInlineEnd: token2.paddingXXS
            },
            "&-prefix": {
              marginInlineEnd: inputAffixPadding
            },
            "&-suffix": {
              marginInlineStart: inputAffixPadding
            }
          }
        }), genAllowClearStyle(token2)), {
          // password
          [`${iconCls}${componentCls}-password-icon`]: {
            color: colorIcon,
            cursor: "pointer",
            transition: `all ${motionDurationSlow}`,
            "&:hover": {
              color: colorIconHover
            }
          }
        }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
      };
    };
    const genGroupStyle = (token2) => {
      const {
        componentCls,
        colorError,
        colorWarning,
        borderRadiusLG,
        borderRadiusSM
      } = token2;
      return {
        [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
          "&-rtl": {
            direction: "rtl"
          },
          "&-wrapper": {
            display: "inline-block",
            width: "100%",
            textAlign: "start",
            verticalAlign: "top",
            "&-rtl": {
              direction: "rtl"
            },
            // Size
            "&-lg": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG
              }
            },
            "&-sm": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            },
            // Status
            "&-status-error": {
              [`${componentCls}-group-addon`]: {
                color: colorError,
                borderColor: colorError
              }
            },
            "&-status-warning": {
              [`${componentCls}-group-addon`]: {
                color: colorWarning,
                borderColor: colorWarning
              }
            },
            "&-disabled": {
              [`${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
            }
          }
        })
      };
    };
    const genSearchInputStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      const searchPrefixCls = `${componentCls}-search`;
      return {
        [searchPrefixCls]: {
          [`${componentCls}`]: {
            "&:hover, &:focus": {
              borderColor: token2.colorPrimaryHover,
              [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                borderInlineStartColor: token2.colorPrimaryHover
              }
            }
          },
          [`${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          },
          // fix slight height diff in Firefox:
          // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
          [`${componentCls}-lg`]: {
            lineHeight: token2.lineHeightLG - 2e-4
          },
          [`> ${componentCls}-group`]: {
            [`> ${componentCls}-group-addon:last-child`]: {
              insetInlineStart: -1,
              padding: 0,
              border: 0,
              [`${searchPrefixCls}-button`]: {
                paddingTop: 0,
                paddingBottom: 0,
                borderStartStartRadius: 0,
                borderStartEndRadius: token2.borderRadius,
                borderEndEndRadius: token2.borderRadius,
                borderEndStartRadius: 0
              },
              [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                color: token2.colorTextDescription,
                "&:hover": {
                  color: token2.colorPrimaryHover
                },
                "&:active": {
                  color: token2.colorPrimaryActive
                },
                [`&${antCls}-btn-loading::before`]: {
                  insetInlineStart: 0,
                  insetInlineEnd: 0,
                  insetBlockStart: 0,
                  insetBlockEnd: 0
                }
              }
            }
          },
          [`${searchPrefixCls}-button`]: {
            height: token2.controlHeight,
            "&:hover, &:focus": {
              zIndex: 1
            }
          },
          [`&-large ${searchPrefixCls}-button`]: {
            height: token2.controlHeightLG
          },
          [`&-small ${searchPrefixCls}-button`]: {
            height: token2.controlHeightSM
          },
          "&-rtl": {
            direction: "rtl"
          },
          // ===================== Compact Item Customized Styles =====================
          [`&${componentCls}-compact-item`]: {
            [`&:not(${componentCls}-compact-last-item)`]: {
              [`${componentCls}-group-addon`]: {
                [`${componentCls}-search-button`]: {
                  marginInlineEnd: -token2.lineWidth,
                  borderRadius: 0
                }
              }
            },
            [`&:not(${componentCls}-compact-first-item)`]: {
              [`${componentCls},${componentCls}-affix-wrapper`]: {
                borderRadius: 0
              }
            },
            [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
              "&:hover,&:focus,&:active": {
                zIndex: 2
              }
            },
            [`> ${componentCls}-affix-wrapper-focused`]: {
              zIndex: 2
            }
          }
        }
      };
    };
    function initInputToken(token2) {
      return merge$2(token2, {
        inputAffixPadding: token2.paddingXXS,
        inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
        inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
        inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
        inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
        inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
        inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
        inputBorderHoverColor: token2.colorPrimaryHover,
        inputBorderActiveColor: token2.colorPrimaryHover
      });
    }
    const genTextAreaStyle = (token2) => {
      const {
        componentCls,
        paddingLG
      } = token2;
      const textareaPrefixCls = `${componentCls}-textarea`;
      return {
        [textareaPrefixCls]: {
          position: "relative",
          "&-show-count": {
            // https://github.com/ant-design/ant-design/issues/33049
            [`> ${componentCls}`]: {
              height: "100%"
            },
            [`${componentCls}-data-count`]: {
              color: token2.colorTextDescription,
              whiteSpace: "nowrap",
              pointerEvents: "none",
              float: "right",
              marginBottom: -token2.fontSize * token2.lineHeight
            },
            "&-rtl": {
              [`${componentCls}-data-count`]: {
                float: "left"
              }
            }
          },
          [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
            [`${componentCls}`]: {
              paddingInlineEnd: paddingLG
            }
          },
          [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
            padding: 0,
            [`> textarea${componentCls}`]: {
              fontSize: "inherit",
              border: "none",
              outline: "none",
              "&:focus": {
                boxShadow: "none !important"
              }
            },
            [`${componentCls}-suffix`]: {
              margin: 0,
              "> *:not(:last-child)": {
                marginInline: 0
              },
              // Clear Icon
              [`${componentCls}-clear-icon`]: {
                position: "absolute",
                insetInlineEnd: token2.paddingXS,
                insetBlockStart: token2.paddingXS
              },
              // Feedback Icon
              [`${textareaPrefixCls}-suffix`]: {
                position: "absolute",
                top: 0,
                insetInlineEnd: token2.inputPaddingHorizontal,
                bottom: 0,
                zIndex: 1,
                display: "inline-flex",
                alignItems: "center",
                margin: "auto",
                pointerEvents: "none"
              }
            }
          }
        }
      };
    };
    const useStyle$1 = genComponentStyleHook("Input", (token2) => {
      const inputToken = initInputToken(token2);
      return [
        genInputStyle(inputToken),
        genTextAreaStyle(inputToken),
        genAffixStyle(inputToken),
        genGroupStyle(inputToken),
        genSearchInputStyle(inputToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(inputToken)
      ];
    });
    function hasAddon(props) {
      return !!(props.addonBefore || props.addonAfter);
    }
    function hasPrefixSuffix(props) {
      return !!(props.prefix || props.suffix || props.allowClear);
    }
    function resolveOnChange(target, e2, onChange, targetValue) {
      if (!onChange) {
        return;
      }
      var event = e2;
      if (e2.type === "click") {
        var currentTarget = target.cloneNode(true);
        event = Object.create(e2, {
          target: {
            value: currentTarget
          },
          currentTarget: {
            value: currentTarget
          }
        });
        currentTarget.value = "";
        onChange(event);
        return;
      }
      if (targetValue !== void 0) {
        event = Object.create(e2, {
          target: {
            value: target
          },
          currentTarget: {
            value: target
          }
        });
        target.value = targetValue;
        onChange(event);
        return;
      }
      onChange(event);
    }
    function fixControlledValue(value) {
      if (typeof value === "undefined" || value === null) {
        return "";
      }
      return String(value);
    }
    var BaseInput = function BaseInput2(props) {
      var _inputElement$props;
      var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, affixWrapperClassName = props.affixWrapperClassName, groupClassName = props.groupClassName, wrapperClassName = props.wrapperClassName, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, inputStyle = props.inputStyle, classes = props.classes;
      var containerRef = reactExports.useRef(null);
      var onInputClick = function onInputClick2(e2) {
        var _containerRef$current;
        if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target)) {
          triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
        }
      };
      var getClearIcon = function getClearIcon2() {
        var _classNames;
        if (!allowClear) {
          return null;
        }
        var needClear = !disabled && !readOnly && value;
        var clearIconCls = "".concat(prefixCls, "-clear-icon");
        var iconNode = _typeof$1(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "";
        return /* @__PURE__ */ React$1.createElement("span", {
          onClick: handleReset,
          onMouseDown: function onMouseDown(e2) {
            return e2.preventDefault();
          },
          className: classNames(clearIconCls, (_classNames = {}, _defineProperty$2(_classNames, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$2(_classNames, "".concat(clearIconCls, "-has-suffix"), !!suffix), _classNames)),
          role: "button",
          tabIndex: -1
        }, iconNode);
      };
      var element = /* @__PURE__ */ reactExports.cloneElement(inputElement, {
        value,
        hidden,
        style: _objectSpread2(_objectSpread2({}, (_inputElement$props = inputElement.props) === null || _inputElement$props === void 0 ? void 0 : _inputElement$props.style), inputStyle)
      });
      if (hasPrefixSuffix(props)) {
        var _classNames2;
        var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
        var affixWrapperCls = classNames(affixWrapperPrefixCls, (_classNames2 = {}, _defineProperty$2(_classNames2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$2(_classNames2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$2(_classNames2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty$2(_classNames2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _classNames2), !hasAddon(props) && className, affixWrapperClassName, classes === null || classes === void 0 ? void 0 : classes.affixWrapper);
        var suffixNode = (suffix || allowClear) && /* @__PURE__ */ React$1.createElement("span", {
          className: "".concat(prefixCls, "-suffix")
        }, getClearIcon(), suffix);
        element = /* @__PURE__ */ React$1.createElement("span", {
          className: affixWrapperCls,
          style: style2,
          hidden: !hasAddon(props) && hidden,
          onClick: onInputClick,
          ref: containerRef
        }, prefix && /* @__PURE__ */ React$1.createElement("span", {
          className: "".concat(prefixCls, "-prefix")
        }, prefix), /* @__PURE__ */ reactExports.cloneElement(inputElement, {
          style: inputStyle !== null && inputStyle !== void 0 ? inputStyle : null,
          value,
          hidden: null
        }), suffixNode);
      }
      if (hasAddon(props)) {
        var wrapperCls = "".concat(prefixCls, "-group");
        var addonCls = "".concat(wrapperCls, "-addon");
        var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, wrapperClassName, classes === null || classes === void 0 ? void 0 : classes.wrapper);
        var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), className, groupClassName, classes === null || classes === void 0 ? void 0 : classes.group);
        return /* @__PURE__ */ React$1.createElement("span", {
          className: mergedGroupClassName,
          style: style2,
          hidden
        }, /* @__PURE__ */ React$1.createElement("span", {
          className: mergedWrapperClassName
        }, addonBefore && /* @__PURE__ */ React$1.createElement("span", {
          className: addonCls
        }, addonBefore), /* @__PURE__ */ reactExports.cloneElement(element, {
          style: inputStyle !== null && inputStyle !== void 0 ? inputStyle : null,
          hidden: null
        }), addonAfter && /* @__PURE__ */ React$1.createElement("span", {
          className: addonCls
        }, addonAfter)));
      }
      return element;
    };
    globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function triggerFocus(element, option) {
      if (!element) {
        return;
      }
      element.focus(option);
      const {
        cursor
      } = option || {};
      if (cursor) {
        const len2 = element.value.length;
        switch (cursor) {
          case "start":
            element.setSelectionRange(0, 0);
            break;
          case "end":
            element.setSelectionRange(len2, len2);
            break;
          default:
            element.setSelectionRange(0, len2);
            break;
        }
      }
    }
    var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
    var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
    var computedStyleCache = {};
    var hiddenTextarea;
    function calculateNodeStyling(node2) {
      var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
      if (useCache && computedStyleCache[nodeRef]) {
        return computedStyleCache[nodeRef];
      }
      var style2 = window.getComputedStyle(node2);
      var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
      var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
      var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
      var sizingStyle = SIZING_STYLE.map(function(name) {
        return "".concat(name, ":").concat(style2.getPropertyValue(name));
      }).join(";");
      var nodeInfo = {
        sizingStyle,
        paddingSize,
        borderSize,
        boxSizing
      };
      if (useCache && nodeRef) {
        computedStyleCache[nodeRef] = nodeInfo;
      }
      return nodeInfo;
    }
    function calculateAutoSizeStyle(uiTextNode) {
      var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        hiddenTextarea.setAttribute("tab-index", "-1");
        hiddenTextarea.setAttribute("aria-hidden", "true");
        document.body.appendChild(hiddenTextarea);
      }
      if (uiTextNode.getAttribute("wrap")) {
        hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
      } else {
        hiddenTextarea.removeAttribute("wrap");
      }
      var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
      hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
      hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
      var minHeight = void 0;
      var maxHeight = void 0;
      var overflowY;
      var height = hiddenTextarea.scrollHeight;
      if (boxSizing === "border-box") {
        height += borderSize;
      } else if (boxSizing === "content-box") {
        height -= paddingSize;
      }
      if (minRows !== null || maxRows !== null) {
        hiddenTextarea.value = " ";
        var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (minRows !== null) {
          minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
        }
        if (maxRows !== null) {
          maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          overflowY = height > maxHeight ? "" : "hidden";
          height = Math.min(maxHeight, height);
        }
      }
      var style2 = {
        height,
        overflowY,
        resize: "none"
      };
      if (minHeight) {
        style2.minHeight = minHeight;
      }
      if (maxHeight) {
        style2.maxHeight = maxHeight;
      }
      return style2;
    }
    var _excluded$1 = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
    var RESIZE_START = 0;
    var RESIZE_MEASURING = 1;
    var RESIZE_STABLE = 2;
    var ResizableTextArea = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _ref = props, prefixCls = _ref.prefixCls;
      _ref.onPressEnter;
      var defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange;
      _ref.onInternalAutoSize;
      var restProps = _objectWithoutProperties$2(_ref, _excluded$1);
      var _useMergedState = useMergedState(defaultValue, {
        value,
        postState: function postState(val) {
          return val !== null && val !== void 0 ? val : "";
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
      var onInternalChange = function onInternalChange2(event) {
        setMergedValue(event.target.value);
        onChange === null || onChange === void 0 ? void 0 : onChange(event);
      };
      var textareaRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          textArea: textareaRef.current
        };
      });
      var _React$useMemo = reactExports.useMemo(function() {
        if (autoSize && _typeof$1(autoSize) === "object") {
          return [autoSize.minRows, autoSize.maxRows];
        }
        return [];
      }, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
      var needAutoSize = !!autoSize;
      var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
        try {
          if (document.activeElement === textareaRef.current) {
            var _textareaRef$current = textareaRef.current, selectionStart = _textareaRef$current.selectionStart, selectionEnd = _textareaRef$current.selectionEnd, scrollTop = _textareaRef$current.scrollTop;
            textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
            textareaRef.current.scrollTop = scrollTop;
          }
        } catch (e2) {
        }
      };
      var _React$useState = reactExports.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
      var _React$useState3 = reactExports.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
      var startResize = function startResize2() {
        setResizeState(RESIZE_START);
      };
      useLayoutEffect(function() {
        if (needAutoSize) {
          startResize();
        }
      }, [value, minRows, maxRows, needAutoSize]);
      useLayoutEffect(function() {
        if (resizeState === RESIZE_START) {
          setResizeState(RESIZE_MEASURING);
        } else if (resizeState === RESIZE_MEASURING) {
          var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
          setResizeState(RESIZE_STABLE);
          setAutoSizeStyle(textareaStyles);
        } else {
          fixFirefoxAutoScroll();
        }
      }, [resizeState]);
      var resizeRafRef = reactExports.useRef();
      var cleanRaf = function cleanRaf2() {
        wrapperRaf.cancel(resizeRafRef.current);
      };
      var onInternalResize = function onInternalResize2(size) {
        if (resizeState === RESIZE_STABLE) {
          onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
          if (autoSize) {
            cleanRaf();
            resizeRafRef.current = wrapperRaf(function() {
              startResize();
            });
          }
        }
      };
      reactExports.useEffect(function() {
        return cleanRaf;
      }, []);
      var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
      var mergedStyle = _objectSpread2(_objectSpread2({}, style2), mergedAutoSizeStyle);
      if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
        mergedStyle.overflowY = "hidden";
        mergedStyle.overflowX = "hidden";
      }
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onInternalResize,
        disabled: !(autoSize || onResize2)
      }, /* @__PURE__ */ reactExports.createElement("textarea", _extends$g({}, restProps, {
        ref: textareaRef,
        style: mergedStyle,
        className: classNames(prefixCls, className, _defineProperty$2({}, "".concat(prefixCls, "-disabled"), disabled)),
        disabled,
        value: mergedValue,
        onChange: onInternalChange
      })));
    });
    var _excluded = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "classes", "showCount", "className", "style", "disabled"];
    function fixEmojiLength(value, maxLength) {
      return _toConsumableArray(value || "").slice(0, maxLength).join("");
    }
    function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
      var newTriggerValue = triggerValue;
      if (isCursorInEnd) {
        newTriggerValue = fixEmojiLength(triggerValue, maxLength);
      } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
        newTriggerValue = preValue;
      }
      return newTriggerValue;
    }
    var TextArea$2 = /* @__PURE__ */ React$1.forwardRef(function(_ref, ref) {
      var defaultValue = _ref.defaultValue, customValue = _ref.value, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, classes = _ref.classes, showCount = _ref.showCount, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, rest = _objectWithoutProperties$2(_ref, _excluded);
      var _useMergedState = useMergedState(defaultValue, {
        value: customValue,
        defaultValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue2 = _useMergedState2[1];
      var resizableTextAreaRef = reactExports.useRef(null);
      var _React$useState = React$1.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
      var _React$useState3 = React$1.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), compositing = _React$useState4[0], setCompositing = _React$useState4[1];
      var oldCompositionValueRef = React$1.useRef();
      var oldSelectionStartRef = React$1.useRef(0);
      var focus = function focus2() {
        resizableTextAreaRef.current.textArea.focus();
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          resizableTextArea: resizableTextAreaRef.current,
          focus,
          blur: function blur() {
            resizableTextAreaRef.current.textArea.blur();
          }
        };
      });
      reactExports.useEffect(function() {
        setFocused(function(prev2) {
          return !disabled && prev2;
        });
      }, [disabled]);
      var hasMaxLength = Number(maxLength) > 0;
      var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
        setCompositing(true);
        oldCompositionValueRef.current = value;
        oldSelectionStartRef.current = e2.currentTarget.selectionStart;
        onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
      };
      var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
        setCompositing(false);
        var triggerValue = e2.currentTarget.value;
        if (hasMaxLength) {
          var _oldCompositionValueR;
          var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_oldCompositionValueR = oldCompositionValueRef.current) === null || _oldCompositionValueR === void 0 ? void 0 : _oldCompositionValueR.length);
          triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);
        }
        if (triggerValue !== value) {
          setValue2(triggerValue);
          resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);
        }
        onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
      };
      var handleChange = function handleChange2(e2) {
        var triggerValue = e2.target.value;
        if (!compositing && hasMaxLength) {
          var isCursorInEnd = e2.target.selectionStart >= maxLength + 1 || e2.target.selectionStart === triggerValue.length || !e2.target.selectionStart;
          triggerValue = setTriggerValue(isCursorInEnd, value, triggerValue, maxLength);
        }
        setValue2(triggerValue);
        resolveOnChange(e2.currentTarget, e2, onChange, triggerValue);
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        var onPressEnter = rest.onPressEnter, onKeyDown = rest.onKeyDown;
        if (e2.key === "Enter" && onPressEnter) {
          onPressEnter(e2);
        }
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
      };
      var handleFocus2 = function handleFocus3(e2) {
        setFocused(true);
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
      };
      var handleBlur = function handleBlur2(e2) {
        setFocused(false);
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
      };
      var handleReset = function handleReset2(e2) {
        setValue2("");
        focus();
        resolveOnChange(resizableTextAreaRef.current.textArea, e2, onChange);
      };
      var val = fixControlledValue(value);
      if (!compositing && hasMaxLength && (customValue === null || customValue === void 0)) {
        val = fixEmojiLength(val, maxLength);
      }
      var textarea = /* @__PURE__ */ React$1.createElement(BaseInput, {
        value: val,
        allowClear,
        handleReset,
        suffix,
        prefixCls,
        classes: {
          affixWrapper: classes === null || classes === void 0 ? void 0 : classes.affixWrapper
        },
        disabled,
        focused,
        style: style2,
        inputStyle: {
          resize: style2 === null || style2 === void 0 ? void 0 : style2.resize
        },
        inputElement: /* @__PURE__ */ React$1.createElement(ResizableTextArea, _extends$g({}, rest, {
          onKeyDown: handleKeyDown,
          onChange: handleChange,
          onFocus: handleFocus2,
          onBlur: handleBlur,
          onCompositionStart: onInternalCompositionStart,
          onCompositionEnd: onInternalCompositionEnd,
          className: classNames(showCount ? "" : className, classes === null || classes === void 0 ? void 0 : classes.textarea),
          style: !showCount && style2,
          disabled,
          prefixCls,
          ref: resizableTextAreaRef
        }))
      });
      if (showCount) {
        var valueLength = _toConsumableArray(val).length;
        var dataCount;
        if (_typeof$1(showCount) === "object") {
          dataCount = showCount.formatter({
            value: val,
            count: valueLength,
            maxLength
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
        }
        return /* @__PURE__ */ React$1.createElement("div", {
          hidden: rest.hidden,
          className: classNames("".concat(prefixCls, "-show-count"), className, classes === null || classes === void 0 ? void 0 : classes.countWrapper),
          style: style2,
          "data-count": dataCount
        }, textarea, /* @__PURE__ */ React$1.createElement("span", {
          className: "".concat(prefixCls, "-data-count")
        }, dataCount));
      }
      return textarea;
    });
    var __rest$6 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const TextArea = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        prefixCls: customizePrefixCls,
        bordered = true,
        size: customizeSize,
        disabled: customDisabled,
        status: customStatus,
        allowClear
      } = _a, rest = __rest$6(_a, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const size = reactExports.useContext(SizeContext$1);
      const mergedSize = customizeSize || size;
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const innerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => {
        var _a2;
        return {
          resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
          focus: (option) => {
            var _a3, _b;
            triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
          },
          blur: () => {
            var _a3;
            return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
          }
        };
      });
      const prefixCls = getPrefixCls("input", customizePrefixCls);
      let mergedAllowClear;
      if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
      } else if (allowClear) {
        mergedAllowClear = {
          clearIcon: /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null)
        };
      }
      const [wrapSSR, hashId] = useStyle$1(prefixCls);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement(TextArea$2, Object.assign({}, rest, {
        disabled: mergedDisabled,
        allowClear: mergedAllowClear,
        classes: {
          affixWrapper: classNames(`${prefixCls}-textarea-affix-wrapper`, {
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large"
          }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus), hashId),
          countWrapper: classNames(`${prefixCls}-textarea`, `${prefixCls}-textarea-show-count`, {
            [`${prefixCls}-textarea-show-count-rtl`]: direction === "rtl"
          }, hashId),
          textarea: classNames({
            [`${prefixCls}-borderless`]: !bordered,
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large"
          }, getStatusClassNames(prefixCls, mergedStatus), hashId)
        },
        prefixCls,
        suffix: hasFeedback && /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-textarea-suffix`
        }, feedbackIcon),
        ref: innerRef
      })));
    });
    const TextArea$1 = TextArea;
    var CopyOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
    const CopyOutlinedSvg = CopyOutlined$2;
    var CopyOutlined = function CopyOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _objectSpread2(_objectSpread2({}, props), {}, {
        ref,
        icon: CopyOutlinedSvg
      }));
    };
    CopyOutlined.displayName = "CopyOutlined";
    const CopyOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CopyOutlined);
    var EditOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
    const EditOutlinedSvg = EditOutlined$2;
    var EditOutlined = function EditOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _objectSpread2(_objectSpread2({}, props), {}, {
        ref,
        icon: EditOutlinedSvg
      }));
    };
    EditOutlined.displayName = "EditOutlined";
    const EditOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EditOutlined);
    var EnterOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
    const EnterOutlinedSvg = EnterOutlined$2;
    var EnterOutlined = function EnterOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _objectSpread2(_objectSpread2({}, props), {}, {
        ref,
        icon: EnterOutlinedSvg
      }));
    };
    EnterOutlined.displayName = "EnterOutlined";
    const EnterOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EnterOutlined);
    var __rest$5 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const inlineStyle = {
      border: 0,
      background: "transparent",
      padding: 0,
      lineHeight: "inherit",
      display: "inline-block"
    };
    const TransButton = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const onKeyDown = (event) => {
        const {
          keyCode
        } = event;
        if (keyCode === KeyCode.ENTER) {
          event.preventDefault();
        }
      };
      const onKeyUp = (event) => {
        const {
          keyCode
        } = event;
        const {
          onClick
        } = props;
        if (keyCode === KeyCode.ENTER && onClick) {
          onClick();
        }
      };
      const {
        style: style2,
        noStyle,
        disabled
      } = props, restProps = __rest$5(props, ["style", "noStyle", "disabled"]);
      let mergedStyle = {};
      if (!noStyle) {
        mergedStyle = Object.assign({}, inlineStyle);
      }
      if (disabled) {
        mergedStyle.pointerEvents = "none";
      }
      mergedStyle = Object.assign(Object.assign({}, mergedStyle), style2);
      return /* @__PURE__ */ reactExports.createElement("div", Object.assign({
        role: "button",
        tabIndex: 0,
        ref
      }, restProps, {
        onKeyDown,
        onKeyUp,
        style: mergedStyle
      }));
    });
    const TransButton$1 = TransButton;
    var toggleSelection = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active2 = document.activeElement;
      var ranges = [];
      for (var i2 = 0; i2 < selection.rangeCount; i2++) {
        ranges.push(selection.getRangeAt(i2));
      }
      switch (active2.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active2.blur();
          break;
        default:
          active2 = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range2) {
            selection.addRange(range2);
          });
        }
        active2 && active2.focus();
      };
    };
    var deselectCurrent = toggleSelection;
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range2, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range2 = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range2.selectNodeContents(mark);
        selection.addRange(range2);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range2);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    var copyToClipboard = copy;
    const getTitleStyle = (fontSize, lineHeight, color, token2) => {
      const {
        sizeMarginHeadingVerticalEnd,
        fontWeightStrong
      } = token2;
      return {
        marginBottom: sizeMarginHeadingVerticalEnd,
        color,
        fontWeight: fontWeightStrong,
        fontSize,
        lineHeight
      };
    };
    const getTitleStyles = (token2) => {
      const headings = [1, 2, 3, 4, 5];
      const styles = {};
      headings.forEach((headingLevel) => {
        styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token2[`fontSizeHeading${headingLevel}`], token2[`lineHeightHeading${headingLevel}`], token2.colorTextHeading, token2);
      });
      return styles;
    };
    const getLinkStyles = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        "a&, a": Object.assign(Object.assign({}, operationUnit(token2)), {
          textDecoration: token2.linkDecoration,
          "&:active, &:hover": {
            textDecoration: token2.linkHoverDecoration
          },
          [`&[disabled], &${componentCls}-disabled`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:active, &:hover": {
              color: token2.colorTextDisabled
            },
            "&:active": {
              pointerEvents: "none"
            }
          }
        })
      };
    };
    const getResetStyles = (token2) => ({
      code: {
        margin: "0 0.2em",
        paddingInline: "0.4em",
        paddingBlock: "0.2em 0.1em",
        fontSize: "85%",
        fontFamily: token2.fontFamilyCode,
        background: "rgba(150, 150, 150, 0.1)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderRadius: 3
      },
      kbd: {
        margin: "0 0.2em",
        paddingInline: "0.4em",
        paddingBlock: "0.15em 0.1em",
        fontSize: "90%",
        fontFamily: token2.fontFamilyCode,
        background: "rgba(150, 150, 150, 0.06)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderBottomWidth: 2,
        borderRadius: 3
      },
      mark: {
        padding: 0,
        // FIXME hardcode in v4
        backgroundColor: gold[2]
      },
      "u, ins": {
        textDecoration: "underline",
        textDecorationSkipInk: "auto"
      },
      "s, del": {
        textDecoration: "line-through"
      },
      strong: {
        fontWeight: 600
      },
      // list
      "ul, ol": {
        marginInline: 0,
        marginBlock: "0 1em",
        padding: 0,
        li: {
          marginInline: "20px 0",
          marginBlock: 0,
          paddingInline: "4px 0",
          paddingBlock: 0
        }
      },
      ul: {
        listStyleType: "circle",
        ul: {
          listStyleType: "disc"
        }
      },
      ol: {
        listStyleType: "decimal"
      },
      // pre & block
      "pre, blockquote": {
        margin: "1em 0"
      },
      pre: {
        padding: "0.4em 0.6em",
        whiteSpace: "pre-wrap",
        wordWrap: "break-word",
        background: "rgba(150, 150, 150, 0.1)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderRadius: 3,
        fontFamily: token2.fontFamilyCode,
        // Compatible for marked
        code: {
          display: "inline",
          margin: 0,
          padding: 0,
          fontSize: "inherit",
          fontFamily: "inherit",
          background: "transparent",
          border: 0
        }
      },
      blockquote: {
        paddingInline: "0.6em 0",
        paddingBlock: 0,
        borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
        opacity: 0.85
      }
    });
    const getEditableStyles = (token2) => {
      const {
        componentCls
      } = token2;
      const inputToken = initInputToken(token2);
      const inputShift = inputToken.inputPaddingVertical + 1;
      return {
        "&-edit-content": {
          position: "relative",
          "div&": {
            insetInlineStart: -token2.paddingSM,
            marginTop: -inputShift,
            marginBottom: `calc(1em - ${inputShift}px)`
          },
          [`${componentCls}-edit-content-confirm`]: {
            position: "absolute",
            insetInlineEnd: token2.marginXS + 2,
            insetBlockEnd: token2.marginXS,
            color: token2.colorTextDescription,
            // default style
            fontWeight: "normal",
            fontSize: token2.fontSize,
            fontStyle: "normal",
            pointerEvents: "none"
          },
          textarea: {
            margin: "0!important",
            // Fix Editable Textarea flash in Firefox
            MozTransition: "none",
            height: "1em"
          }
        }
      };
    };
    const getCopyableStyles = (token2) => ({
      "&-copy-success": {
        [`
    &,
    &:hover,
    &:focus`]: {
          color: token2.colorSuccess
        }
      }
    });
    const getEllipsisStyles = () => ({
      [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
        display: "inline-block",
        maxWidth: "100%"
      },
      "&-single-line": {
        whiteSpace: "nowrap"
      },
      "&-ellipsis-single-line": {
        overflow: "hidden",
        textOverflow: "ellipsis",
        // https://blog.csdn.net/iefreer/article/details/50421025
        "a&, span&": {
          verticalAlign: "bottom"
        }
      },
      "&-ellipsis-multiple-line": {
        display: "-webkit-box",
        overflow: "hidden",
        WebkitLineClamp: 3,
        WebkitBoxOrient: "vertical"
      }
    });
    const genTypographyStyle = (token2) => {
      const {
        componentCls,
        sizeMarginHeadingVerticalStart
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
          color: token2.colorText,
          wordBreak: "break-word",
          lineHeight: token2.lineHeight,
          [`&${componentCls}-secondary`]: {
            color: token2.colorTextDescription
          },
          [`&${componentCls}-success`]: {
            color: token2.colorSuccess
          },
          [`&${componentCls}-warning`]: {
            color: token2.colorWarning
          },
          [`&${componentCls}-danger`]: {
            color: token2.colorError,
            "a&:active, a&:focus": {
              color: token2.colorErrorActive
            },
            "a&:hover": {
              color: token2.colorErrorHover
            }
          },
          [`&${componentCls}-disabled`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            userSelect: "none"
          },
          [`
        div&,
        p
      `]: {
            marginBottom: "1em"
          }
        }, getTitleStyles(token2)), {
          [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
            marginTop: sizeMarginHeadingVerticalStart
          },
          [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
            [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
              marginTop: sizeMarginHeadingVerticalStart
            }
          }
        }), getResetStyles(token2)), getLinkStyles(token2)), {
          // Operation
          [`
        ${componentCls}-expand,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: Object.assign(Object.assign({}, operationUnit(token2)), {
            marginInlineStart: token2.marginXXS
          })
        }), getEditableStyles(token2)), getCopyableStyles(token2)), getEllipsisStyles()), {
          "&-rtl": {
            direction: "rtl"
          }
        })
      };
    };
    const useStyle = genComponentStyleHook("Typography", (token2) => [genTypographyStyle(token2)], {
      sizeMarginHeadingVerticalStart: "1.2em",
      sizeMarginHeadingVerticalEnd: "0.5em"
    });
    const Editable = (_ref) => {
      let {
        prefixCls,
        "aria-label": ariaLabel,
        className,
        style: style2,
        direction,
        maxLength,
        autoSize = true,
        value,
        onSave,
        onCancel,
        onEnd,
        component,
        enterIcon = /* @__PURE__ */ reactExports.createElement(EnterOutlined$1, null)
      } = _ref;
      const ref = reactExports.useRef(null);
      const inComposition = reactExports.useRef(false);
      const lastKeyCode = reactExports.useRef();
      const [current, setCurrent] = reactExports.useState(value);
      reactExports.useEffect(() => {
        setCurrent(value);
      }, [value]);
      reactExports.useEffect(() => {
        if (ref.current && ref.current.resizableTextArea) {
          const {
            textArea
          } = ref.current.resizableTextArea;
          textArea.focus();
          const {
            length: length2
          } = textArea.value;
          textArea.setSelectionRange(length2, length2);
        }
      }, []);
      const onChange = (_ref2) => {
        let {
          target
        } = _ref2;
        setCurrent(target.value.replace(/[\n\r]/g, ""));
      };
      const onCompositionStart = () => {
        inComposition.current = true;
      };
      const onCompositionEnd = () => {
        inComposition.current = false;
      };
      const onKeyDown = (_ref3) => {
        let {
          keyCode
        } = _ref3;
        if (inComposition.current)
          return;
        lastKeyCode.current = keyCode;
      };
      const confirmChange = () => {
        onSave(current.trim());
      };
      const onKeyUp = (_ref4) => {
        let {
          keyCode,
          ctrlKey,
          altKey,
          metaKey,
          shiftKey
        } = _ref4;
        if (lastKeyCode.current === keyCode && !inComposition.current && !ctrlKey && !altKey && !metaKey && !shiftKey) {
          if (keyCode === KeyCode.ENTER) {
            confirmChange();
            onEnd === null || onEnd === void 0 ? void 0 : onEnd();
          } else if (keyCode === KeyCode.ESC) {
            onCancel();
          }
        }
      };
      const onBlur = () => {
        confirmChange();
      };
      const textClassName = component ? `${prefixCls}-${component}` : "";
      const [wrapSSR, hashId] = useStyle(prefixCls);
      const textAreaClassName = classNames(prefixCls, `${prefixCls}-edit-content`, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, textClassName, hashId);
      return wrapSSR(/* @__PURE__ */ reactExports.createElement("div", {
        className: textAreaClassName,
        style: style2
      }, /* @__PURE__ */ reactExports.createElement(TextArea$1, {
        ref,
        maxLength,
        value: current,
        onChange,
        onKeyDown,
        onKeyUp,
        onCompositionStart,
        onCompositionEnd,
        onBlur,
        "aria-label": ariaLabel,
        rows: 1,
        autoSize
      }), enterIcon !== null ? cloneElement(enterIcon, {
        className: `${prefixCls}-edit-content-confirm`
      }) : null));
    };
    const Editable$1 = Editable;
    function useMergedConfig(propConfig, templateConfig) {
      return reactExports.useMemo(() => {
        const support = !!propConfig;
        return [support, Object.assign(Object.assign({}, templateConfig), support && typeof propConfig === "object" ? propConfig : null)];
      }, [propConfig]);
    }
    const useUpdatedEffect = (callback, conditions) => {
      const mountRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        if (mountRef.current) {
          callback();
        } else {
          mountRef.current = true;
        }
      }, conditions);
    };
    const useUpdatedEffect$1 = useUpdatedEffect;
    var __rest$4 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Typography$2 = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        prefixCls: customizePrefixCls,
        component: Component = "article",
        className,
        rootClassName,
        setContentRef,
        children,
        direction: typographyDirection
      } = _a, restProps = __rest$4(_a, ["prefixCls", "component", "className", "rootClassName", "setContentRef", "children", "direction"]);
      const {
        getPrefixCls,
        direction: contextDirection
      } = reactExports.useContext(ConfigContext);
      const direction = typographyDirection !== null && typographyDirection !== void 0 ? typographyDirection : contextDirection;
      let mergedRef = ref;
      if (setContentRef) {
        mergedRef = composeRef(ref, setContentRef);
      }
      const prefixCls = getPrefixCls("typography", customizePrefixCls);
      const [wrapSSR, hashId] = useStyle(prefixCls);
      const componentClassName = classNames(prefixCls, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      return wrapSSR(
        // @ts-expect-error: Expression produces a union type that is too complex to represent.
        /* @__PURE__ */ reactExports.createElement(Component, Object.assign({
          className: componentClassName,
          ref: mergedRef
        }, restProps), children)
      );
    });
    const OriginTypography = Typography$2;
    function cuttable(node2) {
      const type2 = typeof node2;
      return type2 === "string" || type2 === "number";
    }
    function getNodesLen(nodeList) {
      let totalLen = 0;
      nodeList.forEach((node2) => {
        if (cuttable(node2)) {
          totalLen += String(node2).length;
        } else {
          totalLen += 1;
        }
      });
      return totalLen;
    }
    function sliceNodes(nodeList, len2) {
      let currLen = 0;
      const currentNodeList = [];
      for (let i2 = 0; i2 < nodeList.length; i2 += 1) {
        if (currLen === len2) {
          return currentNodeList;
        }
        const node2 = nodeList[i2];
        const canCut = cuttable(node2);
        const nodeLen = canCut ? String(node2).length : 1;
        const nextLen = currLen + nodeLen;
        if (nextLen > len2) {
          const restLen = len2 - currLen;
          currentNodeList.push(String(node2).slice(0, restLen));
          return currentNodeList;
        }
        currentNodeList.push(node2);
        currLen = nextLen;
      }
      return nodeList;
    }
    const NONE = 0;
    const PREPARE = 1;
    const WALKING = 2;
    const DONE_WITH_ELLIPSIS = 3;
    const DONE_WITHOUT_ELLIPSIS = 4;
    const Ellipsis = (_ref) => {
      let {
        enabledMeasure,
        children,
        text,
        width,
        fontSize,
        rows,
        onEllipsis
      } = _ref;
      const [[startLen, midLen, endLen], setCutLength] = reactExports.useState([0, 0, 0]);
      const [walkingState, setWalkingState] = reactExports.useState(NONE);
      const [singleRowHeight, setSingleRowHeight] = reactExports.useState(0);
      const singleRowRef = reactExports.useRef(null);
      const midRowRef = reactExports.useRef(null);
      const nodeList = reactExports.useMemo(() => toArray$2(text), [text]);
      const totalLen = reactExports.useMemo(() => getNodesLen(nodeList), [nodeList]);
      const mergedChildren = reactExports.useMemo(() => {
        if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {
          return children(nodeList, false);
        }
        return children(sliceNodes(nodeList, midLen), midLen < totalLen);
      }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]);
      useLayoutEffect(() => {
        if (enabledMeasure && width && fontSize && totalLen) {
          setWalkingState(PREPARE);
          setCutLength([0, Math.ceil(totalLen / 2), totalLen]);
        }
      }, [enabledMeasure, width, fontSize, text, totalLen, rows]);
      useLayoutEffect(() => {
        var _a;
        if (walkingState === PREPARE) {
          setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);
        }
      }, [walkingState]);
      useLayoutEffect(() => {
        var _a, _b;
        if (singleRowHeight) {
          if (walkingState === PREPARE) {
            const midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
            const maxHeight = rows * singleRowHeight;
            if (midHeight <= maxHeight) {
              setWalkingState(DONE_WITHOUT_ELLIPSIS);
              onEllipsis(false);
            } else {
              setWalkingState(WALKING);
            }
          } else if (walkingState === WALKING) {
            if (startLen !== endLen) {
              const midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
              const maxHeight = rows * singleRowHeight;
              let nextStartLen = startLen;
              let nextEndLen = endLen;
              if (startLen === endLen - 1) {
                nextEndLen = startLen;
              } else if (midHeight <= maxHeight) {
                nextStartLen = midLen;
              } else {
                nextEndLen = midLen;
              }
              const nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);
              setCutLength([nextStartLen, nextMidLen, nextEndLen]);
            } else {
              setWalkingState(DONE_WITH_ELLIPSIS);
              onEllipsis(true);
            }
          }
        }
      }, [walkingState, startLen, endLen, rows, singleRowHeight]);
      const measureStyle = {
        width,
        whiteSpace: "normal",
        margin: 0,
        padding: 0
      };
      const renderMeasure = (content, ref, style2) => /* @__PURE__ */ reactExports.createElement("span", {
        "aria-hidden": true,
        ref,
        style: Object.assign({
          position: "fixed",
          display: "block",
          left: 0,
          top: 0,
          zIndex: -9999,
          visibility: "hidden",
          pointerEvents: "none",
          fontSize: Math.floor(fontSize / 2) * 2
        }, style2)
      }, content);
      const renderMeasureSlice = (len2, ref) => {
        const sliceNodeList = sliceNodes(nodeList, len2);
        return renderMeasure(children(sliceNodeList, true), ref, measureStyle);
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, renderMeasure("lg", singleRowRef, {
        wordBreak: "keep-all",
        whiteSpace: "nowrap"
      }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)));
    };
    const Ellipsis$1 = Ellipsis;
    const EllipsisTooltip = (_ref) => {
      let {
        enabledEllipsis,
        isEllipsis,
        children,
        tooltipProps
      } = _ref;
      if (!(tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.title) || !enabledEllipsis) {
        return children;
      }
      return /* @__PURE__ */ reactExports.createElement(Tooltip$1, Object.assign({
        open: isEllipsis ? void 0 : false
      }, tooltipProps), children);
    };
    const EllipsisTooltip$1 = EllipsisTooltip;
    var __rest$3 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    function wrapperDecorations(_ref, content) {
      let {
        mark,
        code: code2,
        underline,
        delete: del,
        strong,
        keyboard,
        italic
      } = _ref;
      let currentContent = content;
      function wrap(tag, needed) {
        if (!needed) {
          return;
        }
        currentContent = /* @__PURE__ */ reactExports.createElement(tag, {}, currentContent);
      }
      wrap("strong", strong);
      wrap("u", underline);
      wrap("del", del);
      wrap("code", code2);
      wrap("mark", mark);
      wrap("kbd", keyboard);
      wrap("i", italic);
      return currentContent;
    }
    function getNode(dom, defaultNode, needDom) {
      if (dom === true || dom === void 0) {
        return defaultNode;
      }
      return dom || needDom && defaultNode;
    }
    function toList(val) {
      if (val === false) {
        return [false, false];
      }
      return Array.isArray(val) ? val : [val];
    }
    const ELLIPSIS_STR = "...";
    const Base = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b, _c;
      const {
        prefixCls: customizePrefixCls,
        className,
        style: style2,
        type: type2,
        disabled,
        children,
        ellipsis,
        editable,
        copyable,
        component,
        title
      } = props, restProps = __rest$3(props, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [textLocale] = useLocale$1("Text");
      const typographyRef = reactExports.useRef(null);
      const editIconRef = reactExports.useRef(null);
      const prefixCls = getPrefixCls("typography", customizePrefixCls);
      const textProps = omit(restProps, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]);
      const [enableEdit, editConfig] = useMergedConfig(editable);
      const [editing, setEditing] = useMergedState(false, {
        value: editConfig.editing
      });
      const {
        triggerType = ["icon"]
      } = editConfig;
      const triggerEdit = (edit) => {
        var _a2;
        if (edit) {
          (_a2 = editConfig.onStart) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig);
        }
        setEditing(edit);
      };
      useUpdatedEffect$1(() => {
        var _a2;
        if (!editing) {
          (_a2 = editIconRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
        }
      }, [editing]);
      const onEditClick = (e2) => {
        e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
        triggerEdit(true);
      };
      const onEditChange = (value) => {
        var _a2;
        (_a2 = editConfig.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig, value);
        triggerEdit(false);
      };
      const onEditCancel = () => {
        var _a2;
        (_a2 = editConfig.onCancel) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig);
        triggerEdit(false);
      };
      const [enableCopy, copyConfig] = useMergedConfig(copyable);
      const [copied, setCopied] = reactExports.useState(false);
      const copyIdRef = reactExports.useRef();
      const copyOptions = {};
      if (copyConfig.format) {
        copyOptions.format = copyConfig.format;
      }
      const cleanCopyId = () => {
        window.clearTimeout(copyIdRef.current);
      };
      const onCopyClick = (e2) => {
        var _a2;
        e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
        e2 === null || e2 === void 0 ? void 0 : e2.stopPropagation();
        copyToClipboard(copyConfig.text || String(children) || "", copyOptions);
        setCopied(true);
        cleanCopyId();
        copyIdRef.current = window.setTimeout(() => {
          setCopied(false);
        }, 3e3);
        (_a2 = copyConfig.onCopy) === null || _a2 === void 0 ? void 0 : _a2.call(copyConfig, e2);
      };
      reactExports.useEffect(() => cleanCopyId, []);
      const [isLineClampSupport, setIsLineClampSupport] = reactExports.useState(false);
      const [isTextOverflowSupport, setIsTextOverflowSupport] = reactExports.useState(false);
      const [expanded, setExpanded] = reactExports.useState(false);
      const [isJsEllipsis, setIsJsEllipsis] = reactExports.useState(false);
      const [isNativeEllipsis, setIsNativeEllipsis] = reactExports.useState(false);
      const [isNativeVisible, setIsNativeVisible] = reactExports.useState(true);
      const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
        expandable: false
      });
      const mergedEnableEllipsis = enableEllipsis && !expanded;
      const {
        rows = 1
      } = ellipsisConfig;
      const needMeasureEllipsis = reactExports.useMemo(() => (
        // Disable ellipsis
        !mergedEnableEllipsis || // Provide suffix
        ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
        ellipsisConfig.expandable || enableEdit || enableCopy
      ), [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
      useLayoutEffect(() => {
        if (enableEllipsis && !needMeasureEllipsis) {
          setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
          setIsTextOverflowSupport(isStyleSupport("textOverflow"));
        }
      }, [needMeasureEllipsis, enableEllipsis]);
      const cssEllipsis = reactExports.useMemo(() => {
        if (needMeasureEllipsis) {
          return false;
        }
        if (rows === 1) {
          return isTextOverflowSupport;
        }
        return isLineClampSupport;
      }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
      const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
      const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
      const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
      const onExpandClick = (e2) => {
        var _a2;
        setExpanded(true);
        (_a2 = ellipsisConfig.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(ellipsisConfig, e2);
      };
      const [ellipsisWidth, setEllipsisWidth] = reactExports.useState(0);
      const [ellipsisFontSize, setEllipsisFontSize] = reactExports.useState(0);
      const onResize2 = (_ref2, element) => {
        let {
          offsetWidth
        } = _ref2;
        var _a2;
        setEllipsisWidth(offsetWidth);
        setEllipsisFontSize(parseInt((_a2 = window.getComputedStyle) === null || _a2 === void 0 ? void 0 : _a2.call(window, element).fontSize, 10) || 0);
      };
      const onJsEllipsis = (jsEllipsis) => {
        var _a2;
        setIsJsEllipsis(jsEllipsis);
        if (isJsEllipsis !== jsEllipsis) {
          (_a2 = ellipsisConfig.onEllipsis) === null || _a2 === void 0 ? void 0 : _a2.call(ellipsisConfig, jsEllipsis);
        }
      };
      reactExports.useEffect(() => {
        const textEle = typographyRef.current;
        if (enableEllipsis && cssEllipsis && textEle) {
          const currentEllipsis = cssLineClamp ? textEle.offsetHeight < textEle.scrollHeight : textEle.offsetWidth < textEle.scrollWidth;
          if (isNativeEllipsis !== currentEllipsis) {
            setIsNativeEllipsis(currentEllipsis);
          }
        }
      }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible]);
      reactExports.useEffect(() => {
        const textEle = typographyRef.current;
        if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
          return;
        }
        const observer = new IntersectionObserver(() => {
          setIsNativeVisible(!!textEle.offsetParent);
        });
        observer.observe(textEle);
        return () => {
          observer.disconnect();
        };
      }, [cssEllipsis, mergedEnableEllipsis]);
      let tooltipProps = {};
      if (ellipsisConfig.tooltip === true) {
        tooltipProps = {
          title: (_a = editConfig.text) !== null && _a !== void 0 ? _a : children
        };
      } else if (/* @__PURE__ */ reactExports.isValidElement(ellipsisConfig.tooltip)) {
        tooltipProps = {
          title: ellipsisConfig.tooltip
        };
      } else if (typeof ellipsisConfig.tooltip === "object") {
        tooltipProps = Object.assign({
          title: (_b = editConfig.text) !== null && _b !== void 0 ? _b : children
        }, ellipsisConfig.tooltip);
      } else {
        tooltipProps = {
          title: ellipsisConfig.tooltip
        };
      }
      const topAriaLabel = reactExports.useMemo(() => {
        const isValid = (val) => ["string", "number"].includes(typeof val);
        if (!enableEllipsis || cssEllipsis) {
          return void 0;
        }
        if (isValid(editConfig.text)) {
          return editConfig.text;
        }
        if (isValid(children)) {
          return children;
        }
        if (isValid(title)) {
          return title;
        }
        if (isValid(tooltipProps.title)) {
          return tooltipProps.title;
        }
        return void 0;
      }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
      if (editing) {
        return /* @__PURE__ */ reactExports.createElement(Editable$1, {
          value: (_c = editConfig.text) !== null && _c !== void 0 ? _c : typeof children === "string" ? children : "",
          onSave: onEditChange,
          onCancel: onEditCancel,
          onEnd: editConfig.onEnd,
          prefixCls,
          className,
          style: style2,
          direction,
          component,
          maxLength: editConfig.maxLength,
          autoSize: editConfig.autoSize,
          enterIcon: editConfig.enterIcon
        });
      }
      const renderExpand = () => {
        const {
          expandable,
          symbol
        } = ellipsisConfig;
        if (!expandable)
          return null;
        let expandContent;
        if (symbol) {
          expandContent = symbol;
        } else {
          expandContent = textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand;
        }
        return /* @__PURE__ */ reactExports.createElement("a", {
          key: "expand",
          className: `${prefixCls}-expand`,
          onClick: onExpandClick,
          "aria-label": textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand
        }, expandContent);
      };
      const renderEdit = () => {
        if (!enableEdit)
          return;
        const {
          icon,
          tooltip
        } = editConfig;
        const editTitle = toArray$2(tooltip)[0] || (textLocale === null || textLocale === void 0 ? void 0 : textLocale.edit);
        const ariaLabel = typeof editTitle === "string" ? editTitle : "";
        return triggerType.includes("icon") ? /* @__PURE__ */ reactExports.createElement(Tooltip$1, {
          key: "edit",
          title: tooltip === false ? "" : editTitle
        }, /* @__PURE__ */ reactExports.createElement(TransButton$1, {
          ref: editIconRef,
          className: `${prefixCls}-edit`,
          onClick: onEditClick,
          "aria-label": ariaLabel
        }, icon || /* @__PURE__ */ reactExports.createElement(EditOutlined$1, {
          role: "button"
        }))) : null;
      };
      const renderCopy = () => {
        if (!enableCopy)
          return;
        const {
          tooltips,
          icon
        } = copyConfig;
        const tooltipNodes = toList(tooltips);
        const iconNodes = toList(icon);
        const copyTitle = copied ? getNode(tooltipNodes[1], textLocale === null || textLocale === void 0 ? void 0 : textLocale.copied) : getNode(tooltipNodes[0], textLocale === null || textLocale === void 0 ? void 0 : textLocale.copy);
        const systemStr = copied ? textLocale === null || textLocale === void 0 ? void 0 : textLocale.copied : textLocale === null || textLocale === void 0 ? void 0 : textLocale.copy;
        const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
        return /* @__PURE__ */ reactExports.createElement(Tooltip$1, {
          key: "copy",
          title: copyTitle
        }, /* @__PURE__ */ reactExports.createElement(TransButton$1, {
          className: classNames(`${prefixCls}-copy`, copied && `${prefixCls}-copy-success`),
          onClick: onCopyClick,
          "aria-label": ariaLabel
        }, copied ? getNode(iconNodes[1], /* @__PURE__ */ reactExports.createElement(CheckOutlined$1, null), true) : getNode(iconNodes[0], /* @__PURE__ */ reactExports.createElement(CopyOutlined$1, null), true)));
      };
      const renderOperations = (renderExpanded) => [renderExpanded && renderExpand(), renderEdit(), renderCopy()];
      const renderEllipsis = (needEllipsis) => [needEllipsis && /* @__PURE__ */ reactExports.createElement("span", {
        "aria-hidden": true,
        key: "ellipsis"
      }, ELLIPSIS_STR), ellipsisConfig.suffix, renderOperations(needEllipsis)];
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onResize2,
        disabled: !mergedEnableEllipsis || cssEllipsis
      }, (resizeRef) => /* @__PURE__ */ reactExports.createElement(EllipsisTooltip$1, {
        tooltipProps,
        enabledEllipsis: mergedEnableEllipsis,
        isEllipsis: isMergedEllipsis
      }, /* @__PURE__ */ reactExports.createElement(OriginTypography, Object.assign({
        className: classNames({
          [`${prefixCls}-${type2}`]: type2,
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-ellipsis`]: enableEllipsis,
          [`${prefixCls}-single-line`]: mergedEnableEllipsis && rows === 1,
          [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
          [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
        }, className),
        prefixCls: customizePrefixCls,
        style: Object.assign(Object.assign({}, style2), {
          WebkitLineClamp: cssLineClamp ? rows : void 0
        }),
        component,
        ref: composeRef(resizeRef, typographyRef, ref),
        direction,
        onClick: triggerType.includes("text") ? onEditClick : void 0,
        "aria-label": topAriaLabel === null || topAriaLabel === void 0 ? void 0 : topAriaLabel.toString(),
        title
      }, textProps), /* @__PURE__ */ reactExports.createElement(Ellipsis$1, {
        enabledMeasure: mergedEnableEllipsis && !cssEllipsis,
        text: children,
        rows,
        width: ellipsisWidth,
        fontSize: ellipsisFontSize,
        onEllipsis: onJsEllipsis
      }, (node2, needEllipsis) => {
        let renderNode = node2;
        if (node2.length && needEllipsis && topAriaLabel) {
          renderNode = /* @__PURE__ */ reactExports.createElement("span", {
            key: "show-content",
            "aria-hidden": true
          }, renderNode);
        }
        const wrappedContext = wrapperDecorations(props, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, renderNode, renderEllipsis(needEllipsis)));
        return wrappedContext;
      }))));
    });
    const Base$1 = Base;
    var __rest$2 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Link = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        ellipsis,
        rel
      } = _a, restProps = __rest$2(_a, ["ellipsis", "rel"]);
      const mergedProps = Object.assign(Object.assign({}, restProps), {
        rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
      });
      delete mergedProps.navigate;
      return /* @__PURE__ */ reactExports.createElement(Base$1, Object.assign({}, mergedProps, {
        ref,
        ellipsis: !!ellipsis,
        component: "a"
      }));
    });
    const Link$1 = Link;
    const Paragraph = /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ reactExports.createElement(Base$1, Object.assign({
      ref
    }, props, {
      component: "div"
    })));
    const Paragraph$1 = Paragraph;
    var __rest$1 = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const Text$1 = (_a, ref) => {
      var {
        ellipsis
      } = _a, restProps = __rest$1(_a, ["ellipsis"]);
      const mergedEllipsis = reactExports.useMemo(() => {
        if (ellipsis && typeof ellipsis === "object") {
          return omit(ellipsis, ["expandable", "rows"]);
        }
        return ellipsis;
      }, [ellipsis]);
      return /* @__PURE__ */ reactExports.createElement(Base$1, Object.assign({
        ref
      }, restProps, {
        ellipsis: mergedEllipsis,
        component: "span"
      }));
    };
    const Text$2 = /* @__PURE__ */ reactExports.forwardRef(Text$1);
    var __rest = globalThis && globalThis.__rest || function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
            t2[p2[i2]] = s[p2[i2]];
        }
      return t2;
    };
    const TITLE_ELE_LIST = [1, 2, 3, 4, 5];
    const Title = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        level = 1
      } = props, restProps = __rest(props, ["level"]);
      let component;
      if (TITLE_ELE_LIST.includes(level)) {
        component = `h${level}`;
      } else {
        component = "h1";
      }
      return /* @__PURE__ */ reactExports.createElement(Base$1, Object.assign({
        ref
      }, restProps, {
        component
      }));
    });
    const Title$1 = Title;
    const Typography = OriginTypography;
    Typography.Text = Text$2;
    Typography.Link = Link$1;
    Typography.Title = Title$1;
    Typography.Paragraph = Paragraph$1;
    const Typography$1 = Typography;
    var lib = {};
    var flattenNames$1 = {};
    var freeGlobal$3 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var _freeGlobal = freeGlobal$3;
    var freeGlobal$2 = _freeGlobal;
    var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
    var root$a = freeGlobal$2 || freeSelf$1 || Function("return this")();
    var _root = root$a;
    var root$9 = _root;
    var Symbol$8 = root$9.Symbol;
    var _Symbol = Symbol$8;
    var Symbol$7 = _Symbol;
    var objectProto$u = Object.prototype;
    var hasOwnProperty$o = objectProto$u.hasOwnProperty;
    var nativeObjectToString$3 = objectProto$u.toString;
    var symToStringTag$3 = Symbol$7 ? Symbol$7.toStringTag : void 0;
    function getRawTag$2(value) {
      var isOwn = hasOwnProperty$o.call(value, symToStringTag$3), tag = value[symToStringTag$3];
      try {
        value[symToStringTag$3] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$3.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$3] = tag;
        } else {
          delete value[symToStringTag$3];
        }
      }
      return result;
    }
    var _getRawTag = getRawTag$2;
    var objectProto$t = Object.prototype;
    var nativeObjectToString$2 = objectProto$t.toString;
    function objectToString$2(value) {
      return nativeObjectToString$2.call(value);
    }
    var _objectToString = objectToString$2;
    var Symbol$6 = _Symbol, getRawTag$1 = _getRawTag, objectToString$1 = _objectToString;
    var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
    var symToStringTag$2 = Symbol$6 ? Symbol$6.toStringTag : void 0;
    function baseGetTag$8(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag$1 : nullTag$1;
      }
      return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
    }
    var _baseGetTag = baseGetTag$8;
    var isArray$d = Array.isArray;
    var isArray_1 = isArray$d;
    function isObjectLike$a(value) {
      return value != null && typeof value == "object";
    }
    var isObjectLike_1 = isObjectLike$a;
    var baseGetTag$7 = _baseGetTag, isArray$c = isArray_1, isObjectLike$9 = isObjectLike_1;
    var stringTag$6 = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray$c(value) && isObjectLike$9(value) && baseGetTag$7(value) == stringTag$6;
    }
    var isString_1 = isString;
    function createBaseFor$2(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    var _createBaseFor = createBaseFor$2;
    var createBaseFor$1 = _createBaseFor;
    var baseFor$3 = createBaseFor$1();
    var _baseFor = baseFor$3;
    function baseTimes$2(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var _baseTimes = baseTimes$2;
    var baseGetTag$6 = _baseGetTag, isObjectLike$8 = isObjectLike_1;
    var argsTag$6 = "[object Arguments]";
    function baseIsArguments$2(value) {
      return isObjectLike$8(value) && baseGetTag$6(value) == argsTag$6;
    }
    var _baseIsArguments = baseIsArguments$2;
    var baseIsArguments$1 = _baseIsArguments, isObjectLike$7 = isObjectLike_1;
    var objectProto$s = Object.prototype;
    var hasOwnProperty$n = objectProto$s.hasOwnProperty;
    var propertyIsEnumerable$3 = objectProto$s.propertyIsEnumerable;
    var isArguments$4 = baseIsArguments$1(function() {
      return arguments;
    }()) ? baseIsArguments$1 : function(value) {
      return isObjectLike$7(value) && hasOwnProperty$n.call(value, "callee") && !propertyIsEnumerable$3.call(value, "callee");
    };
    var isArguments_1 = isArguments$4;
    var isBufferExports = {};
    var isBuffer$5 = {
      get exports() {
        return isBufferExports;
      },
      set exports(v2) {
        isBufferExports = v2;
      }
    };
    function stubFalse$1() {
      return false;
    }
    var stubFalse_1 = stubFalse$1;
    (function(module2, exports2) {
      var root2 = _root, stubFalse2 = stubFalse_1;
      var freeExports2 = exports2 && !exports2.nodeType && exports2;
      var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
      var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
      var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
      var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer2 = nativeIsBuffer2 || stubFalse2;
      module2.exports = isBuffer2;
    })(isBuffer$5, isBufferExports);
    var MAX_SAFE_INTEGER$3 = 9007199254740991;
    var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
    function isIndex$3(value, length2) {
      var type2 = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER$3 : length2;
      return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    var _isIndex = isIndex$3;
    var MAX_SAFE_INTEGER$2 = 9007199254740991;
    function isLength$4(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
    }
    var isLength_1 = isLength$4;
    var baseGetTag$5 = _baseGetTag, isLength$3 = isLength_1, isObjectLike$6 = isObjectLike_1;
    var argsTag$5 = "[object Arguments]", arrayTag$4 = "[object Array]", boolTag$5 = "[object Boolean]", dateTag$5 = "[object Date]", errorTag$4 = "[object Error]", funcTag$4 = "[object Function]", mapTag$8 = "[object Map]", numberTag$5 = "[object Number]", objectTag$8 = "[object Object]", regexpTag$5 = "[object RegExp]", setTag$8 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$4 = "[object WeakMap]";
    var arrayBufferTag$5 = "[object ArrayBuffer]", dataViewTag$7 = "[object DataView]", float32Tag$3 = "[object Float32Array]", float64Tag$3 = "[object Float64Array]", int8Tag$3 = "[object Int8Array]", int16Tag$3 = "[object Int16Array]", int32Tag$3 = "[object Int32Array]", uint8Tag$3 = "[object Uint8Array]", uint8ClampedTag$3 = "[object Uint8ClampedArray]", uint16Tag$3 = "[object Uint16Array]", uint32Tag$3 = "[object Uint32Array]";
    var typedArrayTags$1 = {};
    typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
    typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] = typedArrayTags$1[arrayBufferTag$5] = typedArrayTags$1[boolTag$5] = typedArrayTags$1[dataViewTag$7] = typedArrayTags$1[dateTag$5] = typedArrayTags$1[errorTag$4] = typedArrayTags$1[funcTag$4] = typedArrayTags$1[mapTag$8] = typedArrayTags$1[numberTag$5] = typedArrayTags$1[objectTag$8] = typedArrayTags$1[regexpTag$5] = typedArrayTags$1[setTag$8] = typedArrayTags$1[stringTag$5] = typedArrayTags$1[weakMapTag$4] = false;
    function baseIsTypedArray$2(value) {
      return isObjectLike$6(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$5(value)];
    }
    var _baseIsTypedArray = baseIsTypedArray$2;
    function baseUnary$4(func) {
      return function(value) {
        return func(value);
      };
    }
    var _baseUnary = baseUnary$4;
    var _nodeUtilExports = {};
    var _nodeUtil = {
      get exports() {
        return _nodeUtilExports;
      },
      set exports(v2) {
        _nodeUtilExports = v2;
      }
    };
    (function(module2, exports2) {
      var freeGlobal2 = _freeGlobal;
      var freeExports2 = exports2 && !exports2.nodeType && exports2;
      var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
      var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
      var freeProcess2 = moduleExports2 && freeGlobal2.process;
      var nodeUtil2 = function() {
        try {
          var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
        } catch (e2) {
        }
      }();
      module2.exports = nodeUtil2;
    })(_nodeUtil, _nodeUtilExports);
    var baseIsTypedArray$1 = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$4 = _nodeUtilExports;
    var nodeIsTypedArray$1 = nodeUtil$4 && nodeUtil$4.isTypedArray;
    var isTypedArray$4 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$1;
    var isTypedArray_1 = isTypedArray$4;
    var baseTimes$1 = _baseTimes, isArguments$3 = isArguments_1, isArray$b = isArray_1, isBuffer$4 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$3 = isTypedArray_1;
    var objectProto$r = Object.prototype;
    var hasOwnProperty$m = objectProto$r.hasOwnProperty;
    function arrayLikeKeys$3(value, inherited) {
      var isArr = isArray$b(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$4(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$1(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$m.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex$2(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    var _arrayLikeKeys = arrayLikeKeys$3;
    var objectProto$q = Object.prototype;
    function isPrototype$4(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$q;
      return value === proto;
    }
    var _isPrototype = isPrototype$4;
    function overArg$3(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var _overArg = overArg$3;
    var overArg$2 = _overArg;
    var nativeKeys$3 = overArg$2(Object.keys, Object);
    var _nativeKeys = nativeKeys$3;
    var isPrototype$3 = _isPrototype, nativeKeys$2 = _nativeKeys;
    var objectProto$p = Object.prototype;
    var hasOwnProperty$l = objectProto$p.hasOwnProperty;
    function baseKeys$2(object2) {
      if (!isPrototype$3(object2)) {
        return nativeKeys$2(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$l.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    var _baseKeys = baseKeys$2;
    function isObject$7(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    var isObject_1 = isObject$7;
    var baseGetTag$4 = _baseGetTag, isObject$6 = isObject_1;
    var asyncTag$1 = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
    function isFunction$3(value) {
      if (!isObject$6(value)) {
        return false;
      }
      var tag = baseGetTag$4(value);
      return tag == funcTag$3 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
    }
    var isFunction_1 = isFunction$3;
    var isFunction$2 = isFunction_1, isLength$2 = isLength_1;
    function isArrayLike$5(value) {
      return value != null && isLength$2(value.length) && !isFunction$2(value);
    }
    var isArrayLike_1 = isArrayLike$5;
    var arrayLikeKeys$2 = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$4 = isArrayLike_1;
    function keys$6(object2) {
      return isArrayLike$4(object2) ? arrayLikeKeys$2(object2) : baseKeys$1(object2);
    }
    var keys_1 = keys$6;
    var baseFor$2 = _baseFor, keys$5 = keys_1;
    function baseForOwn$3(object2, iteratee) {
      return object2 && baseFor$2(object2, iteratee, keys$5);
    }
    var _baseForOwn = baseForOwn$3;
    function identity$3(value) {
      return value;
    }
    var identity_1 = identity$3;
    var identity$2 = identity_1;
    function castFunction$2(value) {
      return typeof value == "function" ? value : identity$2;
    }
    var _castFunction = castFunction$2;
    var baseForOwn$2 = _baseForOwn, castFunction$1 = _castFunction;
    function forOwn(object2, iteratee) {
      return object2 && baseForOwn$2(object2, castFunction$1(iteratee));
    }
    var forOwn_1 = forOwn;
    var overArg$1 = _overArg;
    var getPrototype$5 = overArg$1(Object.getPrototypeOf, Object);
    var _getPrototype = getPrototype$5;
    var baseGetTag$3 = _baseGetTag, getPrototype$4 = _getPrototype, isObjectLike$5 = isObjectLike_1;
    var objectTag$7 = "[object Object]";
    var funcProto$5 = Function.prototype, objectProto$o = Object.prototype;
    var funcToString$5 = funcProto$5.toString;
    var hasOwnProperty$k = objectProto$o.hasOwnProperty;
    var objectCtorString$1 = funcToString$5.call(Object);
    function isPlainObject$1(value) {
      if (!isObjectLike$5(value) || baseGetTag$3(value) != objectTag$7) {
        return false;
      }
      var proto = getPrototype$4(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$k.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$5.call(Ctor) == objectCtorString$1;
    }
    var isPlainObject_1 = isPlainObject$1;
    function arrayMap$3(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    var _arrayMap = arrayMap$3;
    function listCacheClear$2() {
      this.__data__ = [];
      this.size = 0;
    }
    var _listCacheClear = listCacheClear$2;
    function eq$4(value, other) {
      return value === other || value !== value && other !== other;
    }
    var eq_1 = eq$4;
    var eq$3 = eq_1;
    function assocIndexOf$5(array2, key) {
      var length2 = array2.length;
      while (length2--) {
        if (eq$3(array2[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    var _assocIndexOf = assocIndexOf$5;
    var assocIndexOf$4 = _assocIndexOf;
    var arrayProto$1 = Array.prototype;
    var splice$1 = arrayProto$1.splice;
    function listCacheDelete$2(key) {
      var data = this.__data__, index2 = assocIndexOf$4(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice$1.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    var _listCacheDelete = listCacheDelete$2;
    var assocIndexOf$3 = _assocIndexOf;
    function listCacheGet$2(key) {
      var data = this.__data__, index2 = assocIndexOf$3(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    var _listCacheGet = listCacheGet$2;
    var assocIndexOf$2 = _assocIndexOf;
    function listCacheHas$2(key) {
      return assocIndexOf$2(this.__data__, key) > -1;
    }
    var _listCacheHas = listCacheHas$2;
    var assocIndexOf$1 = _assocIndexOf;
    function listCacheSet$2(key, value) {
      var data = this.__data__, index2 = assocIndexOf$1(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    var _listCacheSet = listCacheSet$2;
    var listCacheClear$1 = _listCacheClear, listCacheDelete$1 = _listCacheDelete, listCacheGet$1 = _listCacheGet, listCacheHas$1 = _listCacheHas, listCacheSet$1 = _listCacheSet;
    function ListCache$5(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache$5.prototype.clear = listCacheClear$1;
    ListCache$5.prototype["delete"] = listCacheDelete$1;
    ListCache$5.prototype.get = listCacheGet$1;
    ListCache$5.prototype.has = listCacheHas$1;
    ListCache$5.prototype.set = listCacheSet$1;
    var _ListCache = ListCache$5;
    var ListCache$4 = _ListCache;
    function stackClear$2() {
      this.__data__ = new ListCache$4();
      this.size = 0;
    }
    var _stackClear = stackClear$2;
    function stackDelete$2(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    var _stackDelete = stackDelete$2;
    function stackGet$2(key) {
      return this.__data__.get(key);
    }
    var _stackGet = stackGet$2;
    function stackHas$2(key) {
      return this.__data__.has(key);
    }
    var _stackHas = stackHas$2;
    var root$8 = _root;
    var coreJsData$3 = root$8["__core-js_shared__"];
    var _coreJsData = coreJsData$3;
    var coreJsData$2 = _coreJsData;
    var maskSrcKey$1 = function() {
      var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked$2(func) {
      return !!maskSrcKey$1 && maskSrcKey$1 in func;
    }
    var _isMasked = isMasked$2;
    var funcProto$4 = Function.prototype;
    var funcToString$4 = funcProto$4.toString;
    function toSource$3(func) {
      if (func != null) {
        try {
          return funcToString$4.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var _toSource = toSource$3;
    var isFunction$1 = isFunction_1, isMasked$1 = _isMasked, isObject$5 = isObject_1, toSource$2 = _toSource;
    var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
    var funcProto$3 = Function.prototype, objectProto$n = Object.prototype;
    var funcToString$3 = funcProto$3.toString;
    var hasOwnProperty$j = objectProto$n.hasOwnProperty;
    var reIsNative$1 = RegExp(
      "^" + funcToString$3.call(hasOwnProperty$j).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative$2(value) {
      if (!isObject$5(value) || isMasked$1(value)) {
        return false;
      }
      var pattern2 = isFunction$1(value) ? reIsNative$1 : reIsHostCtor$1;
      return pattern2.test(toSource$2(value));
    }
    var _baseIsNative = baseIsNative$2;
    function getValue$2(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    var _getValue = getValue$2;
    var baseIsNative$1 = _baseIsNative, getValue$1 = _getValue;
    function getNative$8(object2, key) {
      var value = getValue$1(object2, key);
      return baseIsNative$1(value) ? value : void 0;
    }
    var _getNative = getNative$8;
    var getNative$7 = _getNative, root$7 = _root;
    var Map$6 = getNative$7(root$7, "Map");
    var _Map = Map$6;
    var getNative$6 = _getNative;
    var nativeCreate$6 = getNative$6(Object, "create");
    var _nativeCreate = nativeCreate$6;
    var nativeCreate$5 = _nativeCreate;
    function hashClear$2() {
      this.__data__ = nativeCreate$5 ? nativeCreate$5(null) : {};
      this.size = 0;
    }
    var _hashClear = hashClear$2;
    function hashDelete$2(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var _hashDelete = hashDelete$2;
    var nativeCreate$4 = _nativeCreate;
    var HASH_UNDEFINED$5 = "__lodash_hash_undefined__";
    var objectProto$m = Object.prototype;
    var hasOwnProperty$i = objectProto$m.hasOwnProperty;
    function hashGet$2(key) {
      var data = this.__data__;
      if (nativeCreate$4) {
        var result = data[key];
        return result === HASH_UNDEFINED$5 ? void 0 : result;
      }
      return hasOwnProperty$i.call(data, key) ? data[key] : void 0;
    }
    var _hashGet = hashGet$2;
    var nativeCreate$3 = _nativeCreate;
    var objectProto$l = Object.prototype;
    var hasOwnProperty$h = objectProto$l.hasOwnProperty;
    function hashHas$2(key) {
      var data = this.__data__;
      return nativeCreate$3 ? data[key] !== void 0 : hasOwnProperty$h.call(data, key);
    }
    var _hashHas = hashHas$2;
    var nativeCreate$2 = _nativeCreate;
    var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
    function hashSet$2(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$4 : value;
      return this;
    }
    var _hashSet = hashSet$2;
    var hashClear$1 = _hashClear, hashDelete$1 = _hashDelete, hashGet$1 = _hashGet, hashHas$1 = _hashHas, hashSet$1 = _hashSet;
    function Hash$2(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash$2.prototype.clear = hashClear$1;
    Hash$2.prototype["delete"] = hashDelete$1;
    Hash$2.prototype.get = hashGet$1;
    Hash$2.prototype.has = hashHas$1;
    Hash$2.prototype.set = hashSet$1;
    var _Hash = Hash$2;
    var Hash$1 = _Hash, ListCache$3 = _ListCache, Map$5 = _Map;
    function mapCacheClear$2() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash$1(),
        "map": new (Map$5 || ListCache$3)(),
        "string": new Hash$1()
      };
    }
    var _mapCacheClear = mapCacheClear$2;
    function isKeyable$2(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    var _isKeyable = isKeyable$2;
    var isKeyable$1 = _isKeyable;
    function getMapData$5(map2, key) {
      var data = map2.__data__;
      return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    var _getMapData = getMapData$5;
    var getMapData$4 = _getMapData;
    function mapCacheDelete$2(key) {
      var result = getMapData$4(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    var _mapCacheDelete = mapCacheDelete$2;
    var getMapData$3 = _getMapData;
    function mapCacheGet$2(key) {
      return getMapData$3(this, key).get(key);
    }
    var _mapCacheGet = mapCacheGet$2;
    var getMapData$2 = _getMapData;
    function mapCacheHas$2(key) {
      return getMapData$2(this, key).has(key);
    }
    var _mapCacheHas = mapCacheHas$2;
    var getMapData$1 = _getMapData;
    function mapCacheSet$2(key, value) {
      var data = getMapData$1(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    var _mapCacheSet = mapCacheSet$2;
    var mapCacheClear$1 = _mapCacheClear, mapCacheDelete$1 = _mapCacheDelete, mapCacheGet$1 = _mapCacheGet, mapCacheHas$1 = _mapCacheHas, mapCacheSet$1 = _mapCacheSet;
    function MapCache$4(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache$4.prototype.clear = mapCacheClear$1;
    MapCache$4.prototype["delete"] = mapCacheDelete$1;
    MapCache$4.prototype.get = mapCacheGet$1;
    MapCache$4.prototype.has = mapCacheHas$1;
    MapCache$4.prototype.set = mapCacheSet$1;
    var _MapCache = MapCache$4;
    var ListCache$2 = _ListCache, Map$4 = _Map, MapCache$3 = _MapCache;
    var LARGE_ARRAY_SIZE$1 = 200;
    function stackSet$2(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache$2) {
        var pairs = data.__data__;
        if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache$3(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    var _stackSet = stackSet$2;
    var ListCache$1 = _ListCache, stackClear$1 = _stackClear, stackDelete$1 = _stackDelete, stackGet$1 = _stackGet, stackHas$1 = _stackHas, stackSet$1 = _stackSet;
    function Stack$4(entries) {
      var data = this.__data__ = new ListCache$1(entries);
      this.size = data.size;
    }
    Stack$4.prototype.clear = stackClear$1;
    Stack$4.prototype["delete"] = stackDelete$1;
    Stack$4.prototype.get = stackGet$1;
    Stack$4.prototype.has = stackHas$1;
    Stack$4.prototype.set = stackSet$1;
    var _Stack = Stack$4;
    var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
    function setCacheAdd$2(value) {
      this.__data__.set(value, HASH_UNDEFINED$3);
      return this;
    }
    var _setCacheAdd = setCacheAdd$2;
    function setCacheHas$2(value) {
      return this.__data__.has(value);
    }
    var _setCacheHas = setCacheHas$2;
    var MapCache$2 = _MapCache, setCacheAdd$1 = _setCacheAdd, setCacheHas$1 = _setCacheHas;
    function SetCache$2(values) {
      var index2 = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache$2();
      while (++index2 < length2) {
        this.add(values[index2]);
      }
    }
    SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$1;
    SetCache$2.prototype.has = setCacheHas$1;
    var _SetCache = SetCache$2;
    function arraySome$2(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    var _arraySome = arraySome$2;
    function cacheHas$2(cache, key) {
      return cache.has(key);
    }
    var _cacheHas = cacheHas$2;
    var SetCache$1 = _SetCache, arraySome$1 = _arraySome, cacheHas$1 = _cacheHas;
    var COMPARE_PARTIAL_FLAG$b = 1, COMPARE_UNORDERED_FLAG$7 = 2;
    function equalArrays$3(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome$1(other, function(othValue2, othIndex) {
            if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    var _equalArrays = equalArrays$3;
    var root$6 = _root;
    var Uint8Array$5 = root$6.Uint8Array;
    var _Uint8Array = Uint8Array$5;
    function mapToArray$2(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    var _mapToArray = mapToArray$2;
    function setToArray$2(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var _setToArray = setToArray$2;
    var Symbol$5 = _Symbol, Uint8Array$4 = _Uint8Array, eq$2 = eq_1, equalArrays$2 = _equalArrays, mapToArray$1 = _mapToArray, setToArray$1 = _setToArray;
    var COMPARE_PARTIAL_FLAG$a = 1, COMPARE_UNORDERED_FLAG$6 = 2;
    var boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$3 = "[object Error]", mapTag$7 = "[object Map]", numberTag$4 = "[object Number]", regexpTag$4 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]";
    var arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$6 = "[object DataView]";
    var symbolProto$4 = Symbol$5 ? Symbol$5.prototype : void 0, symbolValueOf$2 = symbolProto$4 ? symbolProto$4.valueOf : void 0;
    function equalByTag$2(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$6:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag$4:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$4(object2), new Uint8Array$4(other))) {
            return false;
          }
          return true;
        case boolTag$4:
        case dateTag$4:
        case numberTag$4:
          return eq$2(+object2, +other);
        case errorTag$3:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag$4:
        case stringTag$4:
          return object2 == other + "";
        case mapTag$7:
          var convert = mapToArray$1;
        case setTag$7:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
          convert || (convert = setToArray$1);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$6;
          stack.set(object2, other);
          var result = equalArrays$2(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag$5:
          if (symbolValueOf$2) {
            return symbolValueOf$2.call(object2) == symbolValueOf$2.call(other);
          }
      }
      return false;
    }
    var _equalByTag = equalByTag$2;
    function arrayPush$3(array2, values) {
      var index2 = -1, length2 = values.length, offset = array2.length;
      while (++index2 < length2) {
        array2[offset + index2] = values[index2];
      }
      return array2;
    }
    var _arrayPush = arrayPush$3;
    var arrayPush$2 = _arrayPush, isArray$a = isArray_1;
    function baseGetAllKeys$3(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$a(object2) ? result : arrayPush$2(result, symbolsFunc(object2));
    }
    var _baseGetAllKeys = baseGetAllKeys$3;
    function arrayFilter$2(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    var _arrayFilter = arrayFilter$2;
    function stubArray$3() {
      return [];
    }
    var stubArray_1 = stubArray$3;
    var arrayFilter$1 = _arrayFilter, stubArray$2 = stubArray_1;
    var objectProto$k = Object.prototype;
    var propertyIsEnumerable$2 = objectProto$k.propertyIsEnumerable;
    var nativeGetSymbols$2 = Object.getOwnPropertySymbols;
    var getSymbols$5 = !nativeGetSymbols$2 ? stubArray$2 : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter$1(nativeGetSymbols$2(object2), function(symbol) {
        return propertyIsEnumerable$2.call(object2, symbol);
      });
    };
    var _getSymbols = getSymbols$5;
    var baseGetAllKeys$2 = _baseGetAllKeys, getSymbols$4 = _getSymbols, keys$4 = keys_1;
    function getAllKeys$3(object2) {
      return baseGetAllKeys$2(object2, keys$4, getSymbols$4);
    }
    var _getAllKeys = getAllKeys$3;
    var getAllKeys$2 = _getAllKeys;
    var COMPARE_PARTIAL_FLAG$9 = 1;
    var objectProto$j = Object.prototype;
    var hasOwnProperty$g = objectProto$j.hasOwnProperty;
    function equalObjects$2(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9, objProps = getAllKeys$2(object2), objLength = objProps.length, othProps = getAllKeys$2(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$g.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    var _equalObjects = equalObjects$2;
    var getNative$5 = _getNative, root$5 = _root;
    var DataView$4 = getNative$5(root$5, "DataView");
    var _DataView = DataView$4;
    var getNative$4 = _getNative, root$4 = _root;
    var Promise$4 = getNative$4(root$4, "Promise");
    var _Promise = Promise$4;
    var getNative$3 = _getNative, root$3 = _root;
    var Set$4 = getNative$3(root$3, "Set");
    var _Set = Set$4;
    var getNative$2 = _getNative, root$2 = _root;
    var WeakMap$4 = getNative$2(root$2, "WeakMap");
    var _WeakMap = WeakMap$4;
    var DataView$3 = _DataView, Map$3 = _Map, Promise$3 = _Promise, Set$3 = _Set, WeakMap$3 = _WeakMap, baseGetTag$2 = _baseGetTag, toSource$1 = _toSource;
    var mapTag$6 = "[object Map]", objectTag$6 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$6 = "[object Set]", weakMapTag$3 = "[object WeakMap]";
    var dataViewTag$5 = "[object DataView]";
    var dataViewCtorString$1 = toSource$1(DataView$3), mapCtorString$1 = toSource$1(Map$3), promiseCtorString$1 = toSource$1(Promise$3), setCtorString$1 = toSource$1(Set$3), weakMapCtorString$1 = toSource$1(WeakMap$3);
    var getTag$6 = baseGetTag$2;
    if (DataView$3 && getTag$6(new DataView$3(new ArrayBuffer(1))) != dataViewTag$5 || Map$3 && getTag$6(new Map$3()) != mapTag$6 || Promise$3 && getTag$6(Promise$3.resolve()) != promiseTag$1 || Set$3 && getTag$6(new Set$3()) != setTag$6 || WeakMap$3 && getTag$6(new WeakMap$3()) != weakMapTag$3) {
      getTag$6 = function(value) {
        var result = baseGetTag$2(value), Ctor = result == objectTag$6 ? value.constructor : void 0, ctorString = Ctor ? toSource$1(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString$1:
              return dataViewTag$5;
            case mapCtorString$1:
              return mapTag$6;
            case promiseCtorString$1:
              return promiseTag$1;
            case setCtorString$1:
              return setTag$6;
            case weakMapCtorString$1:
              return weakMapTag$3;
          }
        }
        return result;
      };
    }
    var _getTag = getTag$6;
    var Stack$3 = _Stack, equalArrays$1 = _equalArrays, equalByTag$1 = _equalByTag, equalObjects$1 = _equalObjects, getTag$5 = _getTag, isArray$9 = isArray_1, isBuffer$3 = isBufferExports, isTypedArray$2 = isTypedArray_1;
    var COMPARE_PARTIAL_FLAG$8 = 1;
    var argsTag$4 = "[object Arguments]", arrayTag$3 = "[object Array]", objectTag$5 = "[object Object]";
    var objectProto$i = Object.prototype;
    var hasOwnProperty$f = objectProto$i.hasOwnProperty;
    function baseIsEqualDeep$2(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray$9(object2), othIsArr = isArray$9(other), objTag = objIsArr ? arrayTag$3 : getTag$5(object2), othTag = othIsArr ? arrayTag$3 : getTag$5(other);
      objTag = objTag == argsTag$4 ? objectTag$5 : objTag;
      othTag = othTag == argsTag$4 ? objectTag$5 : othTag;
      var objIsObj = objTag == objectTag$5, othIsObj = othTag == objectTag$5, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$3(object2)) {
        if (!isBuffer$3(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack$3());
        return objIsArr || isTypedArray$2(object2) ? equalArrays$1(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag$1(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
        var objIsWrapped = objIsObj && hasOwnProperty$f.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$f.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack$3());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack$3());
      return equalObjects$1(object2, other, bitmask, customizer, equalFunc, stack);
    }
    var _baseIsEqualDeep = baseIsEqualDeep$2;
    var baseIsEqualDeep$1 = _baseIsEqualDeep, isObjectLike$4 = isObjectLike_1;
    function baseIsEqual$3(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep$1(value, other, bitmask, customizer, baseIsEqual$3, stack);
    }
    var _baseIsEqual = baseIsEqual$3;
    var Stack$2 = _Stack, baseIsEqual$2 = _baseIsEqual;
    var COMPARE_PARTIAL_FLAG$7 = 1, COMPARE_UNORDERED_FLAG$5 = 2;
    function baseIsMatch$2(object2, source, matchData, customizer) {
      var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
      if (object2 == null) {
        return !length2;
      }
      object2 = Object(object2);
      while (index2--) {
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length2) {
        data = matchData[index2];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack$2();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    var _baseIsMatch = baseIsMatch$2;
    var isObject$4 = isObject_1;
    function isStrictComparable$3(value) {
      return value === value && !isObject$4(value);
    }
    var _isStrictComparable = isStrictComparable$3;
    var isStrictComparable$2 = _isStrictComparable, keys$3 = keys_1;
    function getMatchData$2(object2) {
      var result = keys$3(object2), length2 = result.length;
      while (length2--) {
        var key = result[length2], value = object2[key];
        result[length2] = [key, value, isStrictComparable$2(value)];
      }
      return result;
    }
    var _getMatchData = getMatchData$2;
    function matchesStrictComparable$3(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    var _matchesStrictComparable = matchesStrictComparable$3;
    var baseIsMatch$1 = _baseIsMatch, getMatchData$1 = _getMatchData, matchesStrictComparable$2 = _matchesStrictComparable;
    function baseMatches$2(source) {
      var matchData = getMatchData$1(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable$2(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch$1(object2, source, matchData);
      };
    }
    var _baseMatches = baseMatches$2;
    var baseGetTag$1 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
    var symbolTag$4 = "[object Symbol]";
    function isSymbol$4(value) {
      return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag$1(value) == symbolTag$4;
    }
    var isSymbol_1 = isSymbol$4;
    var isArray$8 = isArray_1, isSymbol$3 = isSymbol_1;
    var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp$1 = /^\w*$/;
    function isKey$4(value, object2) {
      if (isArray$8(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$3(value)) {
        return true;
      }
      return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object2 != null && value in Object(object2);
    }
    var _isKey = isKey$4;
    var MapCache$1 = _MapCache;
    var FUNC_ERROR_TEXT$3 = "Expected a function";
    function memoize$2(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$3);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize$2.Cache || MapCache$1)();
      return memoized;
    }
    memoize$2.Cache = MapCache$1;
    var memoize_1 = memoize$2;
    var memoize$1 = memoize_1;
    var MAX_MEMOIZE_SIZE$1 = 500;
    function memoizeCapped$2(func) {
      var result = memoize$1(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE$1) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var _memoizeCapped = memoizeCapped$2;
    var memoizeCapped$1 = _memoizeCapped;
    var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar$1 = /\\(\\)?/g;
    var stringToPath$3 = memoizeCapped$1(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName$1, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar$1, "$1") : number2 || match);
      });
      return result;
    });
    var _stringToPath = stringToPath$3;
    var Symbol$4 = _Symbol, arrayMap$2 = _arrayMap, isArray$7 = isArray_1, isSymbol$2 = isSymbol_1;
    var INFINITY$3 = 1 / 0;
    var symbolProto$3 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString$1 = symbolProto$3 ? symbolProto$3.toString : void 0;
    function baseToString$2(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$7(value)) {
        return arrayMap$2(value, baseToString$2) + "";
      }
      if (isSymbol$2(value)) {
        return symbolToString$1 ? symbolToString$1.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
    }
    var _baseToString = baseToString$2;
    var baseToString$1 = _baseToString;
    function toString$2(value) {
      return value == null ? "" : baseToString$1(value);
    }
    var toString_1 = toString$2;
    var isArray$6 = isArray_1, isKey$3 = _isKey, stringToPath$2 = _stringToPath, toString$1 = toString_1;
    function castPath$3(value, object2) {
      if (isArray$6(value)) {
        return value;
      }
      return isKey$3(value, object2) ? [value] : stringToPath$2(toString$1(value));
    }
    var _castPath = castPath$3;
    var isSymbol$1 = isSymbol_1;
    var INFINITY$2 = 1 / 0;
    function toKey$5(value) {
      if (typeof value == "string" || isSymbol$1(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
    }
    var _toKey = toKey$5;
    var castPath$2 = _castPath, toKey$4 = _toKey;
    function baseGet$3(object2, path) {
      path = castPath$2(path, object2);
      var index2 = 0, length2 = path.length;
      while (object2 != null && index2 < length2) {
        object2 = object2[toKey$4(path[index2++])];
      }
      return index2 && index2 == length2 ? object2 : void 0;
    }
    var _baseGet = baseGet$3;
    var baseGet$2 = _baseGet;
    function get$3(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet$2(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    var get_1 = get$3;
    function baseHasIn$2(object2, key) {
      return object2 != null && key in Object(object2);
    }
    var _baseHasIn = baseHasIn$2;
    var castPath$1 = _castPath, isArguments$2 = isArguments_1, isArray$5 = isArray_1, isIndex$1 = _isIndex, isLength$1 = isLength_1, toKey$3 = _toKey;
    function hasPath$2(object2, path, hasFunc) {
      path = castPath$1(path, object2);
      var index2 = -1, length2 = path.length, result = false;
      while (++index2 < length2) {
        var key = toKey$3(path[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length2) {
        return result;
      }
      length2 = object2 == null ? 0 : object2.length;
      return !!length2 && isLength$1(length2) && isIndex$1(key, length2) && (isArray$5(object2) || isArguments$2(object2));
    }
    var _hasPath = hasPath$2;
    var baseHasIn$1 = _baseHasIn, hasPath$1 = _hasPath;
    function hasIn$2(object2, path) {
      return object2 != null && hasPath$1(object2, path, baseHasIn$1);
    }
    var hasIn_1 = hasIn$2;
    var baseIsEqual$1 = _baseIsEqual, get$2 = get_1, hasIn$1 = hasIn_1, isKey$2 = _isKey, isStrictComparable$1 = _isStrictComparable, matchesStrictComparable$1 = _matchesStrictComparable, toKey$2 = _toKey;
    var COMPARE_PARTIAL_FLAG$6 = 1, COMPARE_UNORDERED_FLAG$4 = 2;
    function baseMatchesProperty$2(path, srcValue) {
      if (isKey$2(path) && isStrictComparable$1(srcValue)) {
        return matchesStrictComparable$1(toKey$2(path), srcValue);
      }
      return function(object2) {
        var objValue = get$2(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn$1(object2, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
      };
    }
    var _baseMatchesProperty = baseMatchesProperty$2;
    function baseProperty$2(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var _baseProperty = baseProperty$2;
    var baseGet$1 = _baseGet;
    function basePropertyDeep$2(path) {
      return function(object2) {
        return baseGet$1(object2, path);
      };
    }
    var _basePropertyDeep = basePropertyDeep$2;
    var baseProperty$1 = _baseProperty, basePropertyDeep$1 = _basePropertyDeep, isKey$1 = _isKey, toKey$1 = _toKey;
    function property$2(path) {
      return isKey$1(path) ? baseProperty$1(toKey$1(path)) : basePropertyDeep$1(path);
    }
    var property_1 = property$2;
    var baseMatches$1 = _baseMatches, baseMatchesProperty$1 = _baseMatchesProperty, identity$1 = identity_1, isArray$4 = isArray_1, property$1 = property_1;
    function baseIteratee$2(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity$1;
      }
      if (typeof value == "object") {
        return isArray$4(value) ? baseMatchesProperty$1(value[0], value[1]) : baseMatches$1(value);
      }
      return property$1(value);
    }
    var _baseIteratee = baseIteratee$2;
    var isArrayLike$3 = isArrayLike_1;
    function createBaseEach$2(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike$3(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
        while (fromRight ? index2-- : ++index2 < length2) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var _createBaseEach = createBaseEach$2;
    var baseForOwn$1 = _baseForOwn, createBaseEach$1 = _createBaseEach;
    var baseEach$3 = createBaseEach$1(baseForOwn$1);
    var _baseEach = baseEach$3;
    var baseEach$2 = _baseEach, isArrayLike$2 = isArrayLike_1;
    function baseMap$2(collection, iteratee) {
      var index2 = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
      baseEach$2(collection, function(value, key, collection2) {
        result[++index2] = iteratee(value, key, collection2);
      });
      return result;
    }
    var _baseMap = baseMap$2;
    var arrayMap$1 = _arrayMap, baseIteratee$1 = _baseIteratee, baseMap$1 = _baseMap, isArray$3 = isArray_1;
    function map$1(collection, iteratee) {
      var func = isArray$3(collection) ? arrayMap$1 : baseMap$1;
      return func(collection, baseIteratee$1(iteratee));
    }
    var map_1 = map$1;
    Object.defineProperty(flattenNames$1, "__esModule", {
      value: true
    });
    flattenNames$1.flattenNames = void 0;
    var _isString2 = isString_1;
    var _isString3 = _interopRequireDefault$7(_isString2);
    var _forOwn2$2 = forOwn_1;
    var _forOwn3$2 = _interopRequireDefault$7(_forOwn2$2);
    var _isPlainObject2 = isPlainObject_1;
    var _isPlainObject3 = _interopRequireDefault$7(_isPlainObject2);
    var _map2 = map_1;
    var _map3 = _interopRequireDefault$7(_map2);
    function _interopRequireDefault$7(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var flattenNames = flattenNames$1.flattenNames = function flattenNames2() {
      var things = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var names2 = [];
      (0, _map3.default)(things, function(thing) {
        if (Array.isArray(thing)) {
          flattenNames2(thing).map(function(name) {
            return names2.push(name);
          });
        } else if ((0, _isPlainObject3.default)(thing)) {
          (0, _forOwn3$2.default)(thing, function(value, key) {
            value === true && names2.push(key);
            names2.push(key + "-" + value);
          });
        } else if ((0, _isString3.default)(thing)) {
          names2.push(thing);
        }
      });
      return names2;
    };
    flattenNames$1.default = flattenNames;
    var mergeClasses$1 = {};
    function arrayEach$2(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var _arrayEach = arrayEach$2;
    var getNative$1 = _getNative;
    var defineProperty$3 = function() {
      try {
        var func = getNative$1(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    var _defineProperty$1 = defineProperty$3;
    var defineProperty$2 = _defineProperty$1;
    function baseAssignValue$3(object2, key, value) {
      if (key == "__proto__" && defineProperty$2) {
        defineProperty$2(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    var _baseAssignValue = baseAssignValue$3;
    var baseAssignValue$2 = _baseAssignValue, eq$1 = eq_1;
    var objectProto$h = Object.prototype;
    var hasOwnProperty$e = objectProto$h.hasOwnProperty;
    function assignValue$3(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$e.call(object2, key) && eq$1(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue$2(object2, key, value);
      }
    }
    var _assignValue = assignValue$3;
    var assignValue$2 = _assignValue, baseAssignValue$1 = _baseAssignValue;
    function copyObject$5(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length2 = props.length;
      while (++index2 < length2) {
        var key = props[index2];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue$1(object2, key, newValue);
        } else {
          assignValue$2(object2, key, newValue);
        }
      }
      return object2;
    }
    var _copyObject = copyObject$5;
    var copyObject$4 = _copyObject, keys$2 = keys_1;
    function baseAssign$1(object2, source) {
      return object2 && copyObject$4(source, keys$2(source), object2);
    }
    var _baseAssign = baseAssign$1;
    function nativeKeysIn$2(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var _nativeKeysIn = nativeKeysIn$2;
    var isObject$3 = isObject_1, isPrototype$2 = _isPrototype, nativeKeysIn$1 = _nativeKeysIn;
    var objectProto$g = Object.prototype;
    var hasOwnProperty$d = objectProto$g.hasOwnProperty;
    function baseKeysIn$2(object2) {
      if (!isObject$3(object2)) {
        return nativeKeysIn$1(object2);
      }
      var isProto = isPrototype$2(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$d.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    var _baseKeysIn = baseKeysIn$2;
    var arrayLikeKeys$1 = _arrayLikeKeys, baseKeysIn$1 = _baseKeysIn, isArrayLike$1 = isArrayLike_1;
    function keysIn$4(object2) {
      return isArrayLike$1(object2) ? arrayLikeKeys$1(object2, true) : baseKeysIn$1(object2);
    }
    var keysIn_1 = keysIn$4;
    var copyObject$3 = _copyObject, keysIn$3 = keysIn_1;
    function baseAssignIn$1(object2, source) {
      return object2 && copyObject$3(source, keysIn$3(source), object2);
    }
    var _baseAssignIn = baseAssignIn$1;
    var _cloneBufferExports = {};
    var _cloneBuffer = {
      get exports() {
        return _cloneBufferExports;
      },
      set exports(v2) {
        _cloneBufferExports = v2;
      }
    };
    (function(module2, exports2) {
      var root2 = _root;
      var freeExports2 = exports2 && !exports2.nodeType && exports2;
      var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
      var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
      var Buffer2 = moduleExports2 ? root2.Buffer : void 0, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer2(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length2 = buffer2.length, result = allocUnsafe2 ? allocUnsafe2(length2) : new buffer2.constructor(length2);
        buffer2.copy(result);
        return result;
      }
      module2.exports = cloneBuffer2;
    })(_cloneBuffer, _cloneBufferExports);
    function copyArray$2(source, array2) {
      var index2 = -1, length2 = source.length;
      array2 || (array2 = Array(length2));
      while (++index2 < length2) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    var _copyArray = copyArray$2;
    var copyObject$2 = _copyObject, getSymbols$3 = _getSymbols;
    function copySymbols$1(source, object2) {
      return copyObject$2(source, getSymbols$3(source), object2);
    }
    var _copySymbols = copySymbols$1;
    var arrayPush$1 = _arrayPush, getPrototype$3 = _getPrototype, getSymbols$2 = _getSymbols, stubArray$1 = stubArray_1;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbolsIn$2 = !nativeGetSymbols$1 ? stubArray$1 : function(object2) {
      var result = [];
      while (object2) {
        arrayPush$1(result, getSymbols$2(object2));
        object2 = getPrototype$3(object2);
      }
      return result;
    };
    var _getSymbolsIn = getSymbolsIn$2;
    var copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
    function copySymbolsIn$1(source, object2) {
      return copyObject$1(source, getSymbolsIn$1(source), object2);
    }
    var _copySymbolsIn = copySymbolsIn$1;
    var baseGetAllKeys$1 = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$2 = keysIn_1;
    function getAllKeysIn$1(object2) {
      return baseGetAllKeys$1(object2, keysIn$2, getSymbolsIn);
    }
    var _getAllKeysIn = getAllKeysIn$1;
    var objectProto$f = Object.prototype;
    var hasOwnProperty$c = objectProto$f.hasOwnProperty;
    function initCloneArray$1(array2) {
      var length2 = array2.length, result = new array2.constructor(length2);
      if (length2 && typeof array2[0] == "string" && hasOwnProperty$c.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    var _initCloneArray = initCloneArray$1;
    var Uint8Array$3 = _Uint8Array;
    function cloneArrayBuffer$4(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$3(result).set(new Uint8Array$3(arrayBuffer));
      return result;
    }
    var _cloneArrayBuffer = cloneArrayBuffer$4;
    var cloneArrayBuffer$3 = _cloneArrayBuffer;
    function cloneDataView$1(dataView, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer$3(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
    }
    var _cloneDataView = cloneDataView$1;
    var reFlags = /\w*$/;
    function cloneRegExp$1(regexp2) {
      var result = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
      result.lastIndex = regexp2.lastIndex;
      return result;
    }
    var _cloneRegExp = cloneRegExp$1;
    var Symbol$3 = _Symbol;
    var symbolProto$2 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
    function cloneSymbol$1(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }
    var _cloneSymbol = cloneSymbol$1;
    var cloneArrayBuffer$2 = _cloneArrayBuffer;
    function cloneTypedArray$2(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    var _cloneTypedArray = cloneTypedArray$2;
    var cloneArrayBuffer$1 = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray$1 = _cloneTypedArray;
    var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    function initCloneByTag$1(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag$3:
          return cloneArrayBuffer$1(object2);
        case boolTag$3:
        case dateTag$3:
          return new Ctor(+object2);
        case dataViewTag$4:
          return cloneDataView(object2, isDeep);
        case float32Tag$2:
        case float64Tag$2:
        case int8Tag$2:
        case int16Tag$2:
        case int32Tag$2:
        case uint8Tag$2:
        case uint8ClampedTag$2:
        case uint16Tag$2:
        case uint32Tag$2:
          return cloneTypedArray$1(object2, isDeep);
        case mapTag$5:
          return new Ctor();
        case numberTag$3:
        case stringTag$3:
          return new Ctor(object2);
        case regexpTag$3:
          return cloneRegExp(object2);
        case setTag$5:
          return new Ctor();
        case symbolTag$3:
          return cloneSymbol(object2);
      }
    }
    var _initCloneByTag = initCloneByTag$1;
    var isObject$2 = isObject_1;
    var objectCreate$1 = Object.create;
    var baseCreate$3 = function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject$2(proto)) {
          return {};
        }
        if (objectCreate$1) {
          return objectCreate$1(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    var _baseCreate = baseCreate$3;
    var baseCreate$2 = _baseCreate, getPrototype$2 = _getPrototype, isPrototype$1 = _isPrototype;
    function initCloneObject$2(object2) {
      return typeof object2.constructor == "function" && !isPrototype$1(object2) ? baseCreate$2(getPrototype$2(object2)) : {};
    }
    var _initCloneObject = initCloneObject$2;
    var getTag$4 = _getTag, isObjectLike$2 = isObjectLike_1;
    var mapTag$4 = "[object Map]";
    function baseIsMap$1(value) {
      return isObjectLike$2(value) && getTag$4(value) == mapTag$4;
    }
    var _baseIsMap = baseIsMap$1;
    var baseIsMap = _baseIsMap, baseUnary$2 = _baseUnary, nodeUtil$3 = _nodeUtilExports;
    var nodeIsMap = nodeUtil$3 && nodeUtil$3.isMap;
    var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
    var isMap_1 = isMap$1;
    var getTag$3 = _getTag, isObjectLike$1 = isObjectLike_1;
    var setTag$4 = "[object Set]";
    function baseIsSet$1(value) {
      return isObjectLike$1(value) && getTag$3(value) == setTag$4;
    }
    var _baseIsSet = baseIsSet$1;
    var baseIsSet = _baseIsSet, baseUnary$1 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
    var nodeIsSet = nodeUtil$2 && nodeUtil$2.isSet;
    var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
    var isSet_1 = isSet$1;
    var Stack$1 = _Stack, arrayEach$1 = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer$1 = _cloneBufferExports, copyArray$1 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag$2 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject$1 = _initCloneObject, isArray$2 = isArray_1, isBuffer$2 = isBufferExports, isMap = isMap_1, isObject$1 = isObject_1, isSet = isSet_1, keys$1 = keys_1, keysIn$1 = keysIn_1;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
    var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] = cloneableTags[numberTag$2] = cloneableTags[objectTag$4] = cloneableTags[regexpTag$2] = cloneableTags[setTag$3] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
    cloneableTags[errorTag$2] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;
    function baseClone$1(value, bitmask, customizer, key, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
      if (customizer) {
        result = object2 ? customizer(value, key, object2, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject$1(value)) {
        return value;
      }
      var isArr = isArray$2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray$1(value, result);
        }
      } else {
        var tag = getTag$2(value), isFunc = tag == funcTag$2 || tag == genTag$1;
        if (isBuffer$2(value)) {
          return cloneBuffer$1(value, isDeep);
        }
        if (tag == objectTag$4 || tag == argsTag$3 || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject$1(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack$1());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys$1 : isFlat ? keysIn$1 : keys$1;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach$1(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue$1(result, key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    var _baseClone = baseClone$1;
    var baseClone = _baseClone;
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    var cloneDeep_1 = cloneDeep;
    Object.defineProperty(mergeClasses$1, "__esModule", {
      value: true
    });
    mergeClasses$1.mergeClasses = void 0;
    var _forOwn2$1 = forOwn_1;
    var _forOwn3$1 = _interopRequireDefault$6(_forOwn2$1);
    var _cloneDeep2 = cloneDeep_1;
    var _cloneDeep3 = _interopRequireDefault$6(_cloneDeep2);
    var _extends$e = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _interopRequireDefault$6(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var mergeClasses = mergeClasses$1.mergeClasses = function mergeClasses2(classes) {
      var activeNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
      activeNames.map(function(name) {
        var toMerge = classes[name];
        if (toMerge) {
          (0, _forOwn3$1.default)(toMerge, function(value, key) {
            if (!styles[key]) {
              styles[key] = {};
            }
            styles[key] = _extends$e({}, styles[key], toMerge[key]);
          });
        }
        return name;
      });
      return styles;
    };
    mergeClasses$1.default = mergeClasses;
    var autoprefix$1 = {};
    Object.defineProperty(autoprefix$1, "__esModule", {
      value: true
    });
    autoprefix$1.autoprefix = void 0;
    var _forOwn2 = forOwn_1;
    var _forOwn3 = _interopRequireDefault$5(_forOwn2);
    var _extends$d = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _interopRequireDefault$5(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var transforms = {
      borderRadius: function borderRadius(value) {
        return {
          msBorderRadius: value,
          MozBorderRadius: value,
          OBorderRadius: value,
          WebkitBorderRadius: value,
          borderRadius: value
        };
      },
      boxShadow: function boxShadow(value) {
        return {
          msBoxShadow: value,
          MozBoxShadow: value,
          OBoxShadow: value,
          WebkitBoxShadow: value,
          boxShadow: value
        };
      },
      userSelect: function userSelect(value) {
        return {
          WebkitTouchCallout: value,
          KhtmlUserSelect: value,
          MozUserSelect: value,
          msUserSelect: value,
          WebkitUserSelect: value,
          userSelect: value
        };
      },
      flex: function flex(value) {
        return {
          WebkitBoxFlex: value,
          MozBoxFlex: value,
          WebkitFlex: value,
          msFlex: value,
          flex: value
        };
      },
      flexBasis: function flexBasis(value) {
        return {
          WebkitFlexBasis: value,
          flexBasis: value
        };
      },
      justifyContent: function justifyContent(value) {
        return {
          WebkitJustifyContent: value,
          justifyContent: value
        };
      },
      transition: function transition(value) {
        return {
          msTransition: value,
          MozTransition: value,
          OTransition: value,
          WebkitTransition: value,
          transition: value
        };
      },
      transform: function transform(value) {
        return {
          msTransform: value,
          MozTransform: value,
          OTransform: value,
          WebkitTransform: value,
          transform: value
        };
      },
      absolute: function absolute(value) {
        var direction = value && value.split(" ");
        return {
          position: "absolute",
          top: direction && direction[0],
          right: direction && direction[1],
          bottom: direction && direction[2],
          left: direction && direction[3]
        };
      },
      extend: function extend(name, otherElementStyles) {
        var otherStyle = otherElementStyles[name];
        if (otherStyle) {
          return otherStyle;
        }
        return {
          "extend": name
        };
      }
    };
    var autoprefix = autoprefix$1.autoprefix = function autoprefix2(elements) {
      var prefixed = {};
      (0, _forOwn3.default)(elements, function(styles, element) {
        var expanded = {};
        (0, _forOwn3.default)(styles, function(value, key) {
          var transform = transforms[key];
          if (transform) {
            expanded = _extends$d({}, expanded, transform(value));
          } else {
            expanded[key] = value;
          }
        });
        prefixed[element] = expanded;
      });
      return prefixed;
    };
    autoprefix$1.default = autoprefix;
    var hover$1 = {};
    Object.defineProperty(hover$1, "__esModule", {
      value: true
    });
    hover$1.hover = void 0;
    var _extends$c = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react$3 = reactExports;
    var _react2$3 = _interopRequireDefault$4(_react$3);
    function _interopRequireDefault$4(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck$9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$9(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var hover = hover$1.hover = function hover2(Component) {
      var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function(_React$Component) {
        _inherits$9(Hover, _React$Component);
        function Hover() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck$9(this, Hover);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn$9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function() {
            return _this.setState({ hover: true });
          }, _this.handleMouseOut = function() {
            return _this.setState({ hover: false });
          }, _this.render = function() {
            return _react2$3.default.createElement(
              Span,
              { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
              _react2$3.default.createElement(Component, _extends$c({}, _this.props, _this.state))
            );
          }, _temp), _possibleConstructorReturn$9(_this, _ret);
        }
        return Hover;
      }(_react2$3.default.Component);
    };
    hover$1.default = hover;
    var active$1 = {};
    Object.defineProperty(active$1, "__esModule", {
      value: true
    });
    active$1.active = void 0;
    var _extends$b = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react$2 = reactExports;
    var _react2$2 = _interopRequireDefault$3(_react$2);
    function _interopRequireDefault$3(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck$8(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$8(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$8(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var active = active$1.active = function active2(Component) {
      var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function(_React$Component) {
        _inherits$8(Active, _React$Component);
        function Active() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck$8(this, Active);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn$8(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function() {
            return _this.setState({ active: true });
          }, _this.handleMouseUp = function() {
            return _this.setState({ active: false });
          }, _this.render = function() {
            return _react2$2.default.createElement(
              Span,
              { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
              _react2$2.default.createElement(Component, _extends$b({}, _this.props, _this.state))
            );
          }, _temp), _possibleConstructorReturn$8(_this, _ret);
        }
        return Active;
      }(_react2$2.default.Component);
    };
    active$1.default = active;
    var loop = {};
    Object.defineProperty(loop, "__esModule", {
      value: true
    });
    var loopable = function loopable2(i2, length2) {
      var props = {};
      var setProp = function setProp2(name) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        props[name] = value;
      };
      i2 === 0 && setProp("first-child");
      i2 === length2 - 1 && setProp("last-child");
      (i2 === 0 || i2 % 2 === 0) && setProp("even");
      Math.abs(i2 % 2) === 1 && setProp("odd");
      setProp("nth-child", i2);
      return props;
    };
    loop.default = loopable;
    Object.defineProperty(lib, "__esModule", {
      value: true
    });
    lib.ReactCSS = lib.loop = lib.handleActive = handleHover = lib.handleHover = lib.hover = void 0;
    var _flattenNames = flattenNames$1;
    var _flattenNames2 = _interopRequireDefault$2(_flattenNames);
    var _mergeClasses = mergeClasses$1;
    var _mergeClasses2 = _interopRequireDefault$2(_mergeClasses);
    var _autoprefix = autoprefix$1;
    var _autoprefix2 = _interopRequireDefault$2(_autoprefix);
    var _hover2 = hover$1;
    var _hover3 = _interopRequireDefault$2(_hover2);
    var _active = active$1;
    var _active2 = _interopRequireDefault$2(_active);
    var _loop2 = loop;
    var _loop3 = _interopRequireDefault$2(_loop2);
    function _interopRequireDefault$2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    lib.hover = _hover3.default;
    var handleHover = lib.handleHover = _hover3.default;
    lib.handleActive = _active2.default;
    lib.loop = _loop3.default;
    var ReactCSS = lib.ReactCSS = function ReactCSS2(classes) {
      for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        activations[_key - 1] = arguments[_key];
      }
      var activeNames = (0, _flattenNames2.default)(activations);
      var merged = (0, _mergeClasses2.default)(classes, activeNames);
      return (0, _autoprefix2.default)(merged);
    };
    var _default$2 = lib.default = ReactCSS;
    var calculateChange$2 = function calculateChange2(e2, hsl, direction, initialA, container) {
      var containerWidth = container.clientWidth;
      var containerHeight = container.clientHeight;
      var x2 = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
      var y2 = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
      var left = x2 - (container.getBoundingClientRect().left + window.pageXOffset);
      var top = y2 - (container.getBoundingClientRect().top + window.pageYOffset);
      if (direction === "vertical") {
        var a = void 0;
        if (top < 0) {
          a = 0;
        } else if (top > containerHeight) {
          a = 1;
        } else {
          a = Math.round(top * 100 / containerHeight) / 100;
        }
        if (hsl.a !== a) {
          return {
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a,
            source: "rgb"
          };
        }
      } else {
        var _a = void 0;
        if (left < 0) {
          _a = 0;
        } else if (left > containerWidth) {
          _a = 1;
        } else {
          _a = Math.round(left * 100 / containerWidth) / 100;
        }
        if (initialA !== _a) {
          return {
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a: _a,
            source: "rgb"
          };
        }
      }
      return null;
    };
    var checkboardCache = {};
    var render = function render2(c1, c2, size, serverCanvas) {
      if (typeof document === "undefined" && !serverCanvas) {
        return null;
      }
      var canvas = serverCanvas ? new serverCanvas() : document.createElement("canvas");
      canvas.width = size * 2;
      canvas.height = size * 2;
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return null;
      }
      ctx.fillStyle = c1;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = c2;
      ctx.fillRect(0, 0, size, size);
      ctx.translate(size, size);
      ctx.fillRect(0, 0, size, size);
      return canvas.toDataURL();
    };
    var get$1 = function get2(c1, c2, size, serverCanvas) {
      var key = c1 + "-" + c2 + "-" + size + (serverCanvas ? "-server" : "");
      if (checkboardCache[key]) {
        return checkboardCache[key];
      }
      var checkboard = render(c1, c2, size, serverCanvas);
      checkboardCache[key] = checkboard;
      return checkboard;
    };
    var _extends$a = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var Checkboard = function Checkboard2(_ref) {
      var white = _ref.white, grey = _ref.grey, size = _ref.size, renderers = _ref.renderers, borderRadius = _ref.borderRadius, boxShadow = _ref.boxShadow, children = _ref.children;
      var styles = _default$2({
        "default": {
          grid: {
            borderRadius,
            boxShadow,
            absolute: "0px 0px 0px 0px",
            background: "url(" + get$1(white, grey, size, renderers.canvas) + ") center left"
          }
        }
      });
      return reactExports.isValidElement(children) ? React$1.cloneElement(children, _extends$a({}, children.props, { style: _extends$a({}, children.props.style, styles.grid) })) : React$1.createElement("div", { style: styles.grid });
    };
    Checkboard.defaultProps = {
      size: 8,
      white: "transparent",
      grey: "rgba(0,0,0,.08)",
      renderers: {}
    };
    var _extends$9 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass$7 = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$7(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$7(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$7(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Alpha = function(_ref) {
      _inherits$7(Alpha2, _ref);
      function Alpha2() {
        var _ref2;
        var _temp, _this, _ret;
        _classCallCheck$7(this, Alpha2);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref2 = Alpha2.__proto__ || Object.getPrototypeOf(Alpha2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e2) {
          var change = calculateChange$2(e2, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
          change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e2);
        }, _this.handleMouseDown = function(e2) {
          _this.handleChange(e2);
          window.addEventListener("mousemove", _this.handleChange);
          window.addEventListener("mouseup", _this.handleMouseUp);
        }, _this.handleMouseUp = function() {
          _this.unbindEventListeners();
        }, _this.unbindEventListeners = function() {
          window.removeEventListener("mousemove", _this.handleChange);
          window.removeEventListener("mouseup", _this.handleMouseUp);
        }, _temp), _possibleConstructorReturn$7(_this, _ret);
      }
      _createClass$7(Alpha2, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.unbindEventListeners();
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var rgb = this.props.rgb;
          var styles = _default$2({
            "default": {
              alpha: {
                absolute: "0px 0px 0px 0px",
                borderRadius: this.props.radius
              },
              checkboard: {
                absolute: "0px 0px 0px 0px",
                overflow: "hidden",
                borderRadius: this.props.radius
              },
              gradient: {
                absolute: "0px 0px 0px 0px",
                background: "linear-gradient(to right, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)",
                boxShadow: this.props.shadow,
                borderRadius: this.props.radius
              },
              container: {
                position: "relative",
                height: "100%",
                margin: "0 3px"
              },
              pointer: {
                position: "absolute",
                left: rgb.a * 100 + "%"
              },
              slider: {
                width: "4px",
                borderRadius: "1px",
                height: "8px",
                boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
                background: "#fff",
                marginTop: "1px",
                transform: "translateX(-2px)"
              }
            },
            "vertical": {
              gradient: {
                background: "linear-gradient(to bottom, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)"
              },
              pointer: {
                left: 0,
                top: rgb.a * 100 + "%"
              }
            },
            "overwrite": _extends$9({}, this.props.style)
          }, {
            vertical: this.props.direction === "vertical",
            overwrite: true
          });
          return React$1.createElement(
            "div",
            { style: styles.alpha },
            React$1.createElement(
              "div",
              { style: styles.checkboard },
              React$1.createElement(Checkboard, { renderers: this.props.renderers })
            ),
            React$1.createElement("div", { style: styles.gradient }),
            React$1.createElement(
              "div",
              {
                style: styles.container,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              },
              React$1.createElement(
                "div",
                { style: styles.pointer },
                this.props.pointer ? React$1.createElement(this.props.pointer, this.props) : React$1.createElement("div", { style: styles.slider })
              )
            )
          );
        }
      }]);
      return Alpha2;
    }(reactExports.PureComponent || reactExports.Component);
    var _createClass$6 = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck$6(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$6(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$6(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var DEFAULT_ARROW_OFFSET = 1;
    var UP_KEY_CODE = 38;
    var DOWN_KEY_CODE = 40;
    var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
    var isValidKeyCode = function isValidKeyCode2(keyCode) {
      return VALID_KEY_CODES.indexOf(keyCode) > -1;
    };
    var getNumberValue = function getNumberValue2(value) {
      return Number(String(value).replace(/%/g, ""));
    };
    var idCounter = 1;
    var EditableInput = function(_ref) {
      _inherits$6(EditableInput2, _ref);
      function EditableInput2(props) {
        _classCallCheck$6(this, EditableInput2);
        var _this = _possibleConstructorReturn$6(this, (EditableInput2.__proto__ || Object.getPrototypeOf(EditableInput2)).call(this));
        _this.handleBlur = function() {
          if (_this.state.blurValue) {
            _this.setState({ value: _this.state.blurValue, blurValue: null });
          }
        };
        _this.handleChange = function(e2) {
          _this.setUpdatedValue(e2.target.value, e2);
        };
        _this.handleKeyDown = function(e2) {
          var value = getNumberValue(e2.target.value);
          if (!isNaN(value) && isValidKeyCode(e2.keyCode)) {
            var offset = _this.getArrowOffset();
            var updatedValue = e2.keyCode === UP_KEY_CODE ? value + offset : value - offset;
            _this.setUpdatedValue(updatedValue, e2);
          }
        };
        _this.handleDrag = function(e2) {
          if (_this.props.dragLabel) {
            var newValue = Math.round(_this.props.value + e2.movementX);
            if (newValue >= 0 && newValue <= _this.props.dragMax) {
              _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e2);
            }
          }
        };
        _this.handleMouseDown = function(e2) {
          if (_this.props.dragLabel) {
            e2.preventDefault();
            _this.handleDrag(e2);
            window.addEventListener("mousemove", _this.handleDrag);
            window.addEventListener("mouseup", _this.handleMouseUp);
          }
        };
        _this.handleMouseUp = function() {
          _this.unbindEventListeners();
        };
        _this.unbindEventListeners = function() {
          window.removeEventListener("mousemove", _this.handleDrag);
          window.removeEventListener("mouseup", _this.handleMouseUp);
        };
        _this.state = {
          value: String(props.value).toUpperCase(),
          blurValue: String(props.value).toUpperCase()
        };
        _this.inputId = "rc-editable-input-" + idCounter++;
        return _this;
      }
      _createClass$6(EditableInput2, [{
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps, prevState) {
          if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
            if (this.input === document.activeElement) {
              this.setState({ blurValue: String(this.props.value).toUpperCase() });
            } else {
              this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
            }
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.unbindEventListeners();
        }
      }, {
        key: "getValueObjectWithLabel",
        value: function getValueObjectWithLabel(value) {
          return _defineProperty({}, this.props.label, value);
        }
      }, {
        key: "getArrowOffset",
        value: function getArrowOffset2() {
          return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
        }
      }, {
        key: "setUpdatedValue",
        value: function setUpdatedValue(value, e2) {
          var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
          this.props.onChange && this.props.onChange(onChangeValue, e2);
          this.setState({ value });
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var styles = _default$2({
            "default": {
              wrap: {
                position: "relative"
              }
            },
            "user-override": {
              wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
              input: this.props.style && this.props.style.input ? this.props.style.input : {},
              label: this.props.style && this.props.style.label ? this.props.style.label : {}
            },
            "dragLabel-true": {
              label: {
                cursor: "ew-resize"
              }
            }
          }, {
            "user-override": true
          }, this.props);
          return React$1.createElement(
            "div",
            { style: styles.wrap },
            React$1.createElement("input", {
              id: this.inputId,
              style: styles.input,
              ref: function ref(input) {
                return _this2.input = input;
              },
              value: this.state.value,
              onKeyDown: this.handleKeyDown,
              onChange: this.handleChange,
              onBlur: this.handleBlur,
              placeholder: this.props.placeholder,
              spellCheck: "false"
            }),
            this.props.label && !this.props.hideLabel ? React$1.createElement(
              "label",
              {
                htmlFor: this.inputId,
                style: styles.label,
                onMouseDown: this.handleMouseDown
              },
              this.props.label
            ) : null
          );
        }
      }]);
      return EditableInput2;
    }(reactExports.PureComponent || reactExports.Component);
    var calculateChange$1 = function calculateChange2(e2, direction, hsl, container) {
      var containerWidth = container.clientWidth;
      var containerHeight = container.clientHeight;
      var x2 = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
      var y2 = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
      var left = x2 - (container.getBoundingClientRect().left + window.pageXOffset);
      var top = y2 - (container.getBoundingClientRect().top + window.pageYOffset);
      if (direction === "vertical") {
        var h2 = void 0;
        if (top < 0) {
          h2 = 359;
        } else if (top > containerHeight) {
          h2 = 0;
        } else {
          var percent = -(top * 100 / containerHeight) + 100;
          h2 = 360 * percent / 100;
        }
        if (hsl.h !== h2) {
          return {
            h: h2,
            s: hsl.s,
            l: hsl.l,
            a: hsl.a,
            source: "hsl"
          };
        }
      } else {
        var _h = void 0;
        if (left < 0) {
          _h = 0;
        } else if (left > containerWidth) {
          _h = 359;
        } else {
          var _percent = left * 100 / containerWidth;
          _h = 360 * _percent / 100;
        }
        if (hsl.h !== _h) {
          return {
            h: _h,
            s: hsl.s,
            l: hsl.l,
            a: hsl.a,
            source: "hsl"
          };
        }
      }
      return null;
    };
    var _createClass$5 = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$5(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$5(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$5(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Hue = function(_ref) {
      _inherits$5(Hue2, _ref);
      function Hue2() {
        var _ref2;
        var _temp, _this, _ret;
        _classCallCheck$5(this, Hue2);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref2 = Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e2) {
          var change = calculateChange$1(e2, _this.props.direction, _this.props.hsl, _this.container);
          change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e2);
        }, _this.handleMouseDown = function(e2) {
          _this.handleChange(e2);
          window.addEventListener("mousemove", _this.handleChange);
          window.addEventListener("mouseup", _this.handleMouseUp);
        }, _this.handleMouseUp = function() {
          _this.unbindEventListeners();
        }, _temp), _possibleConstructorReturn$5(_this, _ret);
      }
      _createClass$5(Hue2, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.unbindEventListeners();
        }
      }, {
        key: "unbindEventListeners",
        value: function unbindEventListeners() {
          window.removeEventListener("mousemove", this.handleChange);
          window.removeEventListener("mouseup", this.handleMouseUp);
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var _props$direction = this.props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
          var styles = _default$2({
            "default": {
              hue: {
                absolute: "0px 0px 0px 0px",
                borderRadius: this.props.radius,
                boxShadow: this.props.shadow
              },
              container: {
                padding: "0 2px",
                position: "relative",
                height: "100%",
                borderRadius: this.props.radius
              },
              pointer: {
                position: "absolute",
                left: this.props.hsl.h * 100 / 360 + "%"
              },
              slider: {
                marginTop: "1px",
                width: "4px",
                borderRadius: "1px",
                height: "8px",
                boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
                background: "#fff",
                transform: "translateX(-2px)"
              }
            },
            "vertical": {
              pointer: {
                left: "0px",
                top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
              }
            }
          }, { vertical: direction === "vertical" });
          return React$1.createElement(
            "div",
            { style: styles.hue },
            React$1.createElement(
              "div",
              {
                className: "hue-" + direction,
                style: styles.container,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              },
              React$1.createElement(
                "style",
                null,
                "\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          "
              ),
              React$1.createElement(
                "div",
                { style: styles.pointer },
                this.props.pointer ? React$1.createElement(this.props.pointer, this.props) : React$1.createElement("div", { style: styles.slider })
              )
            )
          );
        }
      }]);
      return Hue2;
    }(reactExports.PureComponent || reactExports.Component);
    var propTypesExports = {};
    var propTypes = {
      get exports() {
        return propTypesExports;
      },
      set exports(v2) {
        propTypesExports = v2;
      }
    };
    var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
    var ReactPropTypesSecret = ReactPropTypesSecret_1;
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    var factoryWithThrowingShims = function() {
      function shim(props, propName, componentName, location2, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    {
      propTypes.exports = factoryWithThrowingShims();
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function assocIndexOf(array2, key) {
      var length2 = array2.length;
      while (length2--) {
        if (eq(array2[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal$1 || freeSelf || Function("return this")();
    const root$1 = root;
    var Symbol$1 = root$1.Symbol;
    const Symbol$2 = Symbol$1;
    var objectProto$e = Object.prototype;
    var hasOwnProperty$b = objectProto$e.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$e.toString;
    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$d = Object.prototype;
    var nativeObjectToString = objectProto$d.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObject(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$1["__core-js_shared__"];
    const coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value));
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var Map$1 = getNative(root$1, "Map");
    const Map$2 = Map$1;
    var nativeCreate = getNative(Object, "create");
    const nativeCreate$1 = nativeCreate;
    function hashClear() {
      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$b = Object.prototype;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate$1) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
    }
    var objectProto$a = Object.prototype;
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$2 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    const defineProperty$1 = defineProperty;
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty$1) {
        defineProperty$1(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    function assignMergeValue(object2, key, value) {
      if (value !== void 0 && !eq(object2[key], value) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    var baseFor = createBaseFor();
    const baseFor$1 = baseFor;
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0, allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
      buffer2.copy(result);
      return result;
    }
    var Uint8Array$1 = root$1.Uint8Array;
    const Uint8Array$2 = Uint8Array$1;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array2) {
      var index2 = -1, length2 = source.length;
      array2 || (array2 = Array(length2));
      while (++index2 < length2) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    const baseCreate$1 = baseCreate;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    const getPrototype$1 = getPrototype;
    var objectProto$9 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
      return value === proto;
    }
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$2;
    }
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    const isArguments$1 = isArguments;
    var isArray = Array.isArray;
    const isArray$1 = isArray;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function stubFalse() {
      return false;
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    const isBuffer$1 = isBuffer;
    var objectTag$3 = "[object Object]";
    var funcProto = Function.prototype, objectProto$7 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype$1(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$6.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal$1.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    const nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    const isTypedArray$1 = isTypedArray;
    function safeGet(object2, key) {
      if (key === "constructor" && typeof object2[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object2[key];
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$5.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length2 = props.length;
      while (++index2 < length2) {
        var key = props[index2];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type2 = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object2, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray$1(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
          newValue = objValue;
          if (isArguments$1(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object2, key, newValue);
    }
    function baseMerge(object2, source, srcIndex, customizer, stack) {
      if (object2 === source) {
        return;
      }
      baseFor$1(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key, newValue);
        }
      }, keysIn);
    }
    function identity(value) {
      return value;
    }
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    var nativeMax$1 = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length2 = nativeMax$1(args.length - start, 0), array2 = Array(length2);
        while (++index2 < length2) {
          array2[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform(array2);
        return apply(func, this, otherArgs);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var baseSetToString = !defineProperty$1 ? identity : function(func, string2) {
      return defineProperty$1(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    const baseSetToString$1 = baseSetToString;
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    var setToString = shortOut(baseSetToString$1);
    const setToString$1 = setToString;
    function baseRest(func, start) {
      return setToString$1(overRest(func, start, identity), func + "");
    }
    function isIterateeCall(value, index2, object2) {
      if (!isObject(object2)) {
        return false;
      }
      var type2 = typeof index2;
      if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
        return eq(object2[index2], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object2 = Object(object2);
        while (++index2 < length2) {
          var source = sources[index2];
          if (source) {
            assigner(object2, source, index2, customizer);
          }
        }
        return object2;
      });
    }
    var merge = createAssigner(function(object2, source, srcIndex) {
      baseMerge(object2, source, srcIndex);
    });
    const merge$1 = merge;
    var Raised = function Raised2(_ref) {
      var zDepth = _ref.zDepth, radius = _ref.radius, background = _ref.background, children = _ref.children, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles;
      var styles = _default$2(merge$1({
        "default": {
          wrap: {
            position: "relative",
            display: "inline-block"
          },
          content: {
            position: "relative"
          },
          bg: {
            absolute: "0px 0px 0px 0px",
            boxShadow: "0 " + zDepth + "px " + zDepth * 4 + "px rgba(0,0,0,.24)",
            borderRadius: radius,
            background
          }
        },
        "zDepth-0": {
          bg: {
            boxShadow: "none"
          }
        },
        "zDepth-1": {
          bg: {
            boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
          }
        },
        "zDepth-2": {
          bg: {
            boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
          }
        },
        "zDepth-3": {
          bg: {
            boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
          }
        },
        "zDepth-4": {
          bg: {
            boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
          }
        },
        "zDepth-5": {
          bg: {
            boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
          }
        },
        "square": {
          bg: {
            borderRadius: "0"
          }
        },
        "circle": {
          bg: {
            borderRadius: "50%"
          }
        }
      }, passedStyles), { "zDepth-1": zDepth === 1 });
      return React$1.createElement(
        "div",
        { style: styles.wrap },
        React$1.createElement("div", { style: styles.bg }),
        React$1.createElement(
          "div",
          { style: styles.content },
          children
        )
      );
    };
    Raised.propTypes = {
      background: propTypesExports.string,
      zDepth: propTypesExports.oneOf([0, 1, 2, 3, 4, 5]),
      radius: propTypesExports.number,
      styles: propTypesExports.object
    };
    Raised.defaultProps = {
      background: "#fff",
      zDepth: 1,
      radius: 2,
      styles: {}
    };
    var now = function() {
      return root$1.Date.now();
    };
    const now$1 = now;
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    var symbolTag$1 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    var FUNC_ERROR_TEXT$2 = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now$1();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now$1());
      }
      function debounced() {
        var time = now$1(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    var calculateChange = function calculateChange2(e2, hsl, container) {
      var _container$getBoundin = container.getBoundingClientRect(), containerWidth = _container$getBoundin.width, containerHeight = _container$getBoundin.height;
      var x2 = typeof e2.pageX === "number" ? e2.pageX : e2.touches[0].pageX;
      var y2 = typeof e2.pageY === "number" ? e2.pageY : e2.touches[0].pageY;
      var left = x2 - (container.getBoundingClientRect().left + window.pageXOffset);
      var top = y2 - (container.getBoundingClientRect().top + window.pageYOffset);
      if (left < 0) {
        left = 0;
      } else if (left > containerWidth) {
        left = containerWidth;
      }
      if (top < 0) {
        top = 0;
      } else if (top > containerHeight) {
        top = containerHeight;
      }
      var saturation = left / containerWidth;
      var bright = 1 - top / containerHeight;
      return {
        h: hsl.h,
        s: saturation,
        v: bright,
        a: hsl.a,
        source: "hsv"
      };
    };
    var _createClass$4 = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$4(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$4(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$4(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Saturation = function(_ref) {
      _inherits$4(Saturation2, _ref);
      function Saturation2(props) {
        _classCallCheck$4(this, Saturation2);
        var _this = _possibleConstructorReturn$4(this, (Saturation2.__proto__ || Object.getPrototypeOf(Saturation2)).call(this, props));
        _this.handleChange = function(e2) {
          typeof _this.props.onChange === "function" && _this.throttle(_this.props.onChange, calculateChange(e2, _this.props.hsl, _this.container), e2);
        };
        _this.handleMouseDown = function(e2) {
          _this.handleChange(e2);
          var renderWindow = _this.getContainerRenderWindow();
          renderWindow.addEventListener("mousemove", _this.handleChange);
          renderWindow.addEventListener("mouseup", _this.handleMouseUp);
        };
        _this.handleMouseUp = function() {
          _this.unbindEventListeners();
        };
        _this.throttle = throttle(function(fn, data, e2) {
          fn(data, e2);
        }, 50);
        return _this;
      }
      _createClass$4(Saturation2, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.throttle.cancel();
          this.unbindEventListeners();
        }
      }, {
        key: "getContainerRenderWindow",
        value: function getContainerRenderWindow() {
          var container = this.container;
          var renderWindow = window;
          while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
            renderWindow = renderWindow.parent;
          }
          return renderWindow;
        }
      }, {
        key: "unbindEventListeners",
        value: function unbindEventListeners() {
          var renderWindow = this.getContainerRenderWindow();
          renderWindow.removeEventListener("mousemove", this.handleChange);
          renderWindow.removeEventListener("mouseup", this.handleMouseUp);
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var _ref2 = this.props.style || {}, color = _ref2.color, white = _ref2.white, black = _ref2.black, pointer = _ref2.pointer, circle = _ref2.circle;
          var styles = _default$2({
            "default": {
              color: {
                absolute: "0px 0px 0px 0px",
                background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
                borderRadius: this.props.radius
              },
              white: {
                absolute: "0px 0px 0px 0px",
                borderRadius: this.props.radius
              },
              black: {
                absolute: "0px 0px 0px 0px",
                boxShadow: this.props.shadow,
                borderRadius: this.props.radius
              },
              pointer: {
                position: "absolute",
                top: -(this.props.hsv.v * 100) + 100 + "%",
                left: this.props.hsv.s * 100 + "%",
                cursor: "default"
              },
              circle: {
                width: "4px",
                height: "4px",
                boxShadow: "0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)",
                borderRadius: "50%",
                cursor: "hand",
                transform: "translate(-2px, -2px)"
              }
            },
            "custom": {
              color,
              white,
              black,
              pointer,
              circle
            }
          }, { "custom": !!this.props.style });
          return React$1.createElement(
            "div",
            {
              style: styles.color,
              ref: function ref(container) {
                return _this2.container = container;
              },
              onMouseDown: this.handleMouseDown,
              onTouchMove: this.handleChange,
              onTouchStart: this.handleChange
            },
            React$1.createElement(
              "style",
              null,
              "\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        "
            ),
            React$1.createElement(
              "div",
              { style: styles.white, className: "saturation-white" },
              React$1.createElement("div", { style: styles.black, className: "saturation-black" }),
              React$1.createElement(
                "div",
                { style: styles.pointer },
                this.props.pointer ? React$1.createElement(this.props.pointer, this.props) : React$1.createElement("div", { style: styles.circle })
              )
            )
          );
        }
      }]);
      return Saturation2;
    }(reactExports.PureComponent || reactExports.Component);
    function arrayEach(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var nativeKeys = overArg(Object.keys, Object);
    const nativeKeys$1 = nativeKeys;
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys$1(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor$1(object2, iteratee, keys);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
        while (fromRight ? index2-- : ++index2 < length2) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var baseEach = createBaseEach(baseForOwn);
    const baseEach$1 = baseEach;
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    function forEach(collection, iteratee) {
      var func = isArray$1(collection) ? arrayEach : baseEach$1;
      return func(collection, castFunction(iteratee));
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    var trimLeft = /^\s+/;
    var trimRight = /\s+$/;
    function tinycolor(color, opts) {
      color = color ? color : "";
      opts = opts || {};
      if (color instanceof tinycolor) {
        return color;
      }
      if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1)
        this._r = Math.round(this._r);
      if (this._g < 1)
        this._g = Math.round(this._g);
      if (this._b < 1)
        this._b = Math.round(this._b);
      this._ok = rgb.ok;
    }
    tinycolor.prototype = {
      isDark: function isDark() {
        return this.getBrightness() < 128;
      },
      isLight: function isLight() {
        return !this.isDark();
      },
      isValid: function isValid() {
        return this._ok;
      },
      getOriginalInput: function getOriginalInput() {
        return this._originalInput;
      },
      getFormat: function getFormat() {
        return this._format;
      },
      getAlpha: function getAlpha() {
        return this._a;
      },
      getBrightness: function getBrightness() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function getLuminance() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R2, G2, B2;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928)
          R2 = RsRGB / 12.92;
        else
          R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        if (GsRGB <= 0.03928)
          G2 = GsRGB / 12.92;
        else
          G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        if (BsRGB <= 0.03928)
          B2 = BsRGB / 12.92;
        else
          B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      },
      setAlpha: function setAlpha(value) {
        this._a = boundAlpha(value);
        this._roundA = Math.round(100 * this._a) / 100;
        return this;
      },
      toHsv: function toHsv2() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return {
          h: hsv.h * 360,
          s: hsv.s,
          v: hsv.v,
          a: this._a
        };
      },
      toHsvString: function toHsvString() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h2 = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h2 + ", " + s + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s + "%, " + v2 + "%, " + this._roundA + ")";
      },
      toHsl: function toHsl() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return {
          h: hsl.h * 360,
          s: hsl.s,
          l: hsl.l,
          a: this._a
        };
      },
      toHslString: function toHslString() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h2 = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l2 = Math.round(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h2 + ", " + s + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s + "%, " + l2 + "%, " + this._roundA + ")";
      },
      toHex: function toHex2(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function toHexString(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function toHex8(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function toHex8String(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function toRgb() {
        return {
          r: Math.round(this._r),
          g: Math.round(this._g),
          b: Math.round(this._b),
          a: this._a
        };
      },
      toRgbString: function toRgbString() {
        return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function toPercentageRgb() {
        return {
          r: Math.round(bound01(this._r, 255) * 100) + "%",
          g: Math.round(bound01(this._g, 255) * 100) + "%",
          b: Math.round(bound01(this._b, 255) * 100) + "%",
          a: this._a
        };
      },
      toPercentageRgbString: function toPercentageRgbString() {
        return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function toName() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function toFilter(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s = tinycolor(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function toString2(format2) {
        var formatSet = !!format2;
        format2 = format2 || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function clone() {
        return tinycolor(this.toString());
      },
      _applyModification: function _applyModification(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function lighten() {
        return this._applyModification(_lighten, arguments);
      },
      brighten: function brighten() {
        return this._applyModification(_brighten, arguments);
      },
      darken: function darken() {
        return this._applyModification(_darken, arguments);
      },
      desaturate: function desaturate() {
        return this._applyModification(_desaturate, arguments);
      },
      saturate: function saturate() {
        return this._applyModification(_saturate, arguments);
      },
      greyscale: function greyscale() {
        return this._applyModification(_greyscale, arguments);
      },
      spin: function spin() {
        return this._applyModification(_spin, arguments);
      },
      _applyCombination: function _applyCombination(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function analogous() {
        return this._applyCombination(_analogous, arguments);
      },
      complement: function complement() {
        return this._applyCombination(_complement, arguments);
      },
      monochromatic: function monochromatic() {
        return this._applyCombination(_monochromatic, arguments);
      },
      splitcomplement: function splitcomplement() {
        return this._applyCombination(_splitcomplement, arguments);
      },
      // Disabled until https://github.com/bgrins/TinyColor/issues/254
      // polyad: function (number) {
      //   return this._applyCombination(polyad, [number]);
      // },
      triad: function triad() {
        return this._applyCombination(polyad, [3]);
      },
      tetrad: function tetrad() {
        return this._applyCombination(polyad, [4]);
      }
    };
    tinycolor.fromRatio = function(color, opts) {
      if (_typeof(color) == "object") {
        var newColor = {};
        for (var i2 in color) {
          if (color.hasOwnProperty(i2)) {
            if (i2 === "a") {
              newColor[i2] = color[i2];
            } else {
              newColor[i2] = convertToPercentage(color[i2]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor(color, opts);
    };
    function inputToRGB(color) {
      var rgb = {
        r: 0,
        g: 0,
        b: 0
      };
      var a = 1;
      var s = null;
      var v2 = null;
      var l2 = null;
      var ok2 = false;
      var format2 = false;
      if (typeof color == "string") {
        color = stringInputToObject(color);
      }
      if (_typeof(color) == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok2 = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v2);
          ok2 = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l2);
          ok2 = true;
          format2 = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok: ok2,
        format: color.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2);
      var h2, s, l2 = (max + min) / 2;
      if (max == min) {
        h2 = s = 0;
      } else {
        var d2 = max - min;
        s = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return {
        h: h2,
        s,
        l: l2
      };
    }
    function hslToRgb(h2, s, l2) {
      var r2, g2, b2;
      h2 = bound01(h2, 360);
      s = bound01(s, 100);
      l2 = bound01(l2, 100);
      function hue2rgb2(p3, q3, t2) {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p3 + (q3 - p3) * 6 * t2;
        if (t2 < 1 / 2)
          return q3;
        if (t2 < 2 / 3)
          return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
        return p3;
      }
      if (s === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb2(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb2(p2, q2, h2);
        b2 = hue2rgb2(p2, q2, h2 - 1 / 3);
      }
      return {
        r: r2 * 255,
        g: g2 * 255,
        b: b2 * 255
      };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2);
      var h2, s, v2 = max;
      var d2 = max - min;
      s = max === 0 ? 0 : d2 / max;
      if (max == min) {
        h2 = 0;
      } else {
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return {
        h: h2,
        s,
        v: v2
      };
    }
    function hsvToRgb(h2, s, v2) {
      h2 = bound01(h2, 360) * 6;
      s = bound01(s, 100);
      v2 = bound01(v2, 100);
      var i2 = Math.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s), q2 = v2 * (1 - f2 * s), t2 = v2 * (1 - (1 - f2) * s), mod = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod], g2 = [t2, v2, v2, q2, p2, p2][mod], b2 = [p2, p2, t2, v2, v2, q2][mod];
      return {
        r: r2 * 255,
        g: g2 * 255,
        b: b2 * 255
      };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r2, g2, b2, a, allow4Char) {
      var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a))];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r2, g2, b2, a) {
      var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
      return hex.join("");
    }
    tinycolor.equals = function(color1, color2) {
      if (!color1 || !color2)
        return false;
      return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };
    tinycolor.random = function() {
      return tinycolor.fromRatio({
        r: Math.random(),
        g: Math.random(),
        b: Math.random()
      });
    };
    function _desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }
    function _saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }
    function _greyscale(color) {
      return tinycolor(color).desaturate(100);
    }
    function _lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }
    function _brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor(color).toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return tinycolor(rgb);
    }
    function _darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }
    function _spin(color, amount) {
      var hsl = tinycolor(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor(hsl);
    }
    function _complement(color) {
      var hsl = tinycolor(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor(hsl);
    }
    function polyad(color, number2) {
      if (isNaN(number2) || number2 <= 0) {
        throw new Error("Argument to polyad must be a positive number");
      }
      var hsl = tinycolor(color).toHsl();
      var result = [tinycolor(color)];
      var step = 360 / number2;
      for (var i2 = 1; i2 < number2; i2++) {
        result.push(tinycolor({
          h: (hsl.h + i2 * step) % 360,
          s: hsl.s,
          l: hsl.l
        }));
      }
      return result;
    }
    function _splitcomplement(color) {
      var hsl = tinycolor(color).toHsl();
      var h2 = hsl.h;
      return [tinycolor(color), tinycolor({
        h: (h2 + 72) % 360,
        s: hsl.s,
        l: hsl.l
      }), tinycolor({
        h: (h2 + 216) % 360,
        s: hsl.s,
        l: hsl.l
      })];
    }
    function _analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
      }
      return ret;
    }
    function _monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor(color).toHsv();
      var h2 = hsv.h, s = hsv.s, v2 = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor({
          h: h2,
          s,
          v: v2
        }));
        v2 = (v2 + modification) % 1;
      }
      return ret;
    }
    tinycolor.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor(color1).toRgb();
      var rgb2 = tinycolor(color2).toRgb();
      var p2 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return tinycolor(rgba);
    };
    tinycolor.readability = function(color1, color2) {
      var c1 = tinycolor(color1);
      var c2 = tinycolor(color2);
      return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size = args.size;
      for (var i2 = 0; i2 < colorList.length; i2++) {
        readability = tinycolor.readability(baseColor, colorList[i2]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor(colorList[i2]);
        }
      }
      if (tinycolor.isReadable(baseColor, bestColor, {
        level,
        size
      }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor.hexNames = flip(names);
    function flip(o) {
      var flipped = {};
      for (var i2 in o) {
        if (o.hasOwnProperty(i2)) {
          flipped[o[i2]] = i2;
        }
      }
      return flipped;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function bound01(n2, max) {
      if (isOnePointZero(n2))
        n2 = "100%";
      var processPercent = isPercentage(n2);
      n2 = Math.min(max, Math.max(0, parseFloat(n2)));
      if (processPercent) {
        n2 = parseInt(n2 * max, 10) / 100;
      }
      if (Math.abs(n2 - max) < 1e-6) {
        return 1;
      }
      return n2 % max / parseFloat(max);
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n2) {
      return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") != -1;
    }
    function pad2(c2) {
      return c2.length == 1 ? "0" + c2 : "" + c2;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        n2 = n2 * 100 + "%";
      }
      return n2;
    }
    function convertDecimalToHex(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER2 = "[-\\+]?\\d+%?";
      var CSS_NUMBER2 = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT2 = "(?:" + CSS_NUMBER2 + ")|(?:" + CSS_INTEGER2 + ")";
      var PERMISSIVE_MATCH32 = "[\\s|\\(]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")\\s*\\)?";
      var PERMISSIVE_MATCH42 = "[\\s|\\(]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT2),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH32),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH42),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH32),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH42),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH32),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH42),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
    }
    function stringInputToObject(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color == "transparent") {
        return {
          r: 0,
          g: 0,
          b: 0,
          a: 0,
          format: "name"
        };
      }
      var match;
      if (match = matchers.rgb.exec(color)) {
        return {
          r: match[1],
          g: match[2],
          b: match[3]
        };
      }
      if (match = matchers.rgba.exec(color)) {
        return {
          r: match[1],
          g: match[2],
          b: match[3],
          a: match[4]
        };
      }
      if (match = matchers.hsl.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          l: match[3]
        };
      }
      if (match = matchers.hsla.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          l: match[3],
          a: match[4]
        };
      }
      if (match = matchers.hsv.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          v: match[3]
        };
      }
      if (match = matchers.hsva.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          v: match[3],
          a: match[4]
        };
      }
      if (match = matchers.hex8.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex6.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match = matchers.hex4.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          a: convertHexToDecimal(match[4] + "" + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex3.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size;
      parms = parms || {
        level: "AA",
        size: "small"
      };
      level = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size !== "small" && size !== "large") {
        size = "small";
      }
      return {
        level,
        size
      };
    }
    var simpleCheckForValidColor = function simpleCheckForValidColor2(data) {
      var keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
      var checked = 0;
      var passed = 0;
      forEach(keysToCheck, function(letter) {
        if (data[letter]) {
          checked += 1;
          if (!isNaN(data[letter])) {
            passed += 1;
          }
          if (letter === "s" || letter === "l") {
            var percentPatt = /^\d+%$/;
            if (percentPatt.test(data[letter])) {
              passed += 1;
            }
          }
        }
      });
      return checked === passed ? data : false;
    };
    var toState = function toState2(data, oldHue) {
      var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
      var hsl = color.toHsl();
      var hsv = color.toHsv();
      var rgb = color.toRgb();
      var hex = color.toHex();
      if (hsl.s === 0) {
        hsl.h = oldHue || 0;
        hsv.h = oldHue || 0;
      }
      var transparent = hex === "000000" && rgb.a === 0;
      return {
        hsl,
        hex: transparent ? "transparent" : "#" + hex,
        rgb,
        hsv,
        oldHue: data.h || oldHue || hsl.h,
        source: data.source
      };
    };
    var isValidHex = function isValidHex2(hex) {
      if (hex === "transparent") {
        return true;
      }
      var lh2 = String(hex).charAt(0) === "#" ? 1 : 0;
      return hex.length !== 4 + lh2 && hex.length < 7 + lh2 && tinycolor(hex).isValid();
    };
    var getContrastingColor = function getContrastingColor2(data) {
      if (!data) {
        return "#fff";
      }
      var col = toState(data);
      if (col.hex === "transparent") {
        return "rgba(0,0,0,0.4)";
      }
      var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1e3;
      return yiq >= 128 ? "#000" : "#fff";
    };
    var isvalidColorString = function isvalidColorString2(string2, type2) {
      var stringWithoutDegree = string2.replace("", "");
      return tinycolor(type2 + " (" + stringWithoutDegree + ")")._ok;
    };
    var _extends$8 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass$3 = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$3(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var ColorWrap = function ColorWrap2(Picker) {
      var ColorPicker = function(_ref) {
        _inherits$3(ColorPicker2, _ref);
        function ColorPicker2(props) {
          _classCallCheck$3(this, ColorPicker2);
          var _this = _possibleConstructorReturn$3(this, (ColorPicker2.__proto__ || Object.getPrototypeOf(ColorPicker2)).call(this));
          _this.handleChange = function(data, event) {
            var isValidColor = simpleCheckForValidColor(data);
            if (isValidColor) {
              var colors = toState(data, data.h || _this.state.oldHue);
              _this.setState(colors);
              _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
              _this.props.onChange && _this.props.onChange(colors, event);
            }
          };
          _this.handleSwatchHover = function(data, event) {
            var isValidColor = simpleCheckForValidColor(data);
            if (isValidColor) {
              var colors = toState(data, data.h || _this.state.oldHue);
              _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
            }
          };
          _this.state = _extends$8({}, toState(props.color, 0));
          _this.debounce = debounce(function(fn, data, event) {
            fn(data, event);
          }, 100);
          return _this;
        }
        _createClass$3(ColorPicker2, [{
          key: "render",
          value: function render2() {
            var optionalEvents = {};
            if (this.props.onSwatchHover) {
              optionalEvents.onSwatchHover = this.handleSwatchHover;
            }
            return React$1.createElement(Picker, _extends$8({}, this.props, this.state, {
              onChange: this.handleChange
            }, optionalEvents));
          }
        }], [{
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(nextProps, state) {
            return _extends$8({}, toState(nextProps.color, state.oldHue));
          }
        }]);
        return ColorPicker2;
      }(reactExports.PureComponent || reactExports.Component);
      ColorPicker.propTypes = _extends$8({}, Picker.propTypes);
      ColorPicker.defaultProps = _extends$8({}, Picker.defaultProps, {
        color: {
          h: 250,
          s: 0.5,
          l: 0.2,
          a: 1
        }
      });
      return ColorPicker;
    };
    var _extends$7 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass$2 = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$2(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var handleFocus = function handleFocus2(Component) {
      var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function(_React$Component) {
        _inherits$2(Focus, _React$Component);
        function Focus() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck$2(this, Focus);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function() {
            return _this.setState({ focus: true });
          }, _this.handleBlur = function() {
            return _this.setState({ focus: false });
          }, _temp), _possibleConstructorReturn$2(_this, _ret);
        }
        _createClass$2(Focus, [{
          key: "render",
          value: function render2() {
            return React$1.createElement(
              Span,
              { onFocus: this.handleFocus, onBlur: this.handleBlur },
              React$1.createElement(Component, _extends$7({}, this.props, this.state))
            );
          }
        }]);
        return Focus;
      }(React$1.Component);
    };
    var _extends$6 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var ENTER = 13;
    var Swatch = function Swatch2(_ref) {
      var color = _ref.color, style2 = _ref.style, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, onHover = _ref.onHover, _ref$title = _ref.title, title = _ref$title === void 0 ? color : _ref$title, children = _ref.children, focus = _ref.focus, _ref$focusStyle = _ref.focusStyle, focusStyle = _ref$focusStyle === void 0 ? {} : _ref$focusStyle;
      var transparent = color === "transparent";
      var styles = _default$2({
        default: {
          swatch: _extends$6({
            background: color,
            height: "100%",
            width: "100%",
            cursor: "pointer",
            position: "relative",
            outline: "none"
          }, style2, focus ? focusStyle : {})
        }
      });
      var handleClick = function handleClick2(e2) {
        return onClick(color, e2);
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        return e2.keyCode === ENTER && onClick(color, e2);
      };
      var handleHover2 = function handleHover3(e2) {
        return onHover(color, e2);
      };
      var optionalEvents = {};
      if (onHover) {
        optionalEvents.onMouseOver = handleHover2;
      }
      return React$1.createElement(
        "div",
        _extends$6({
          style: styles.swatch,
          onClick: handleClick,
          title,
          tabIndex: 0,
          onKeyDown: handleKeyDown
        }, optionalEvents),
        children,
        transparent && React$1.createElement(Checkboard, {
          borderRadius: styles.swatch.borderRadius,
          boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
        })
      );
    };
    const Swatch$1 = handleFocus(Swatch);
    var AlphaPointer = function AlphaPointer2(_ref) {
      var direction = _ref.direction;
      var styles = _default$2({
        "default": {
          picker: {
            width: "18px",
            height: "18px",
            borderRadius: "50%",
            transform: "translate(-9px, -1px)",
            backgroundColor: "rgb(248, 248, 248)",
            boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
          }
        },
        "vertical": {
          picker: {
            transform: "translate(-3px, -9px)"
          }
        }
      }, { vertical: direction === "vertical" });
      return React$1.createElement("div", { style: styles.picker });
    };
    var _extends$5 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var AlphaPicker = function AlphaPicker2(_ref) {
      var rgb = _ref.rgb, hsl = _ref.hsl, width = _ref.width, height = _ref.height, onChange = _ref.onChange, direction = _ref.direction, style2 = _ref.style, renderers = _ref.renderers, pointer = _ref.pointer, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2({
        "default": {
          picker: {
            position: "relative",
            width,
            height
          },
          alpha: {
            radius: "2px",
            style: style2
          }
        }
      });
      return React$1.createElement(
        "div",
        { style: styles.picker, className: "alpha-picker " + className },
        React$1.createElement(Alpha, _extends$5({}, styles.alpha, {
          rgb,
          hsl,
          pointer,
          renderers,
          onChange,
          direction
        }))
      );
    };
    AlphaPicker.defaultProps = {
      width: "316px",
      height: "16px",
      direction: "horizontal",
      pointer: AlphaPointer
    };
    ColorWrap(AlphaPicker);
    function arrayMap(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values) {
      var index2 = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length2) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$1:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag$1:
          var convert = mapToArray;
        case setTag$1:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function arrayPush(array2, values) {
      var index2 = -1, length2 = values.length, offset = array2.length;
      while (++index2 < length2) {
        array2[offset + index2] = values[index2];
      }
      return array2;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function arrayFilter(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$2 = Object.prototype;
    var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    const getSymbols$1 = getSymbols;
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols$1);
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    var DataView$1 = getNative(root$1, "DataView");
    const DataView$2 = DataView$1;
    var Promise$1 = getNative(root$1, "Promise");
    const Promise$2 = Promise$1;
    var Set$1 = getNative(root$1, "Set");
    const Set$2 = Set$1;
    var WeakMap$1 = getNative(root$1, "WeakMap");
    const WeakMap$2 = WeakMap$1;
    var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
    var getTag = baseGetTag;
    if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray$1(object2), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$1(object2)) {
        if (!isBuffer$1(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
      if (object2 == null) {
        return !length2;
      }
      object2 = Object(object2);
      while (index2--) {
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length2) {
        data = matchData[index2];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function getMatchData(object2) {
      var result = keys(object2), length2 = result.length;
      while (length2--) {
        var key = result[length2], value = object2[key];
        result[length2] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray$1(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
      });
      return result;
    });
    const stringToPath$1 = stringToPath;
    var INFINITY$1 = 1 / 0;
    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$1(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object2) {
      if (isArray$1(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath$1(toString(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index2 = 0, length2 = path.length;
      while (object2 != null && index2 < length2) {
        object2 = object2[toKey(path[index2++])];
      }
      return index2 && index2 == length2 ? object2 : void 0;
    }
    function get(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    function hasPath(object2, path, hasFunc) {
      path = castPath(path, object2);
      var index2 = -1, length2 = path.length, result = false;
      while (++index2 < length2) {
        var key = toKey(path[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length2) {
        return result;
      }
      length2 = object2 == null ? 0 : object2.length;
      return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray$1(object2) || isArguments$1(object2));
    }
    function hasIn(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object2) {
        var objValue = get(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    function basePropertyDeep(path) {
      return function(object2) {
        return baseGet(object2, path);
      };
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseMap(collection, iteratee) {
      var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach$1(collection, function(value, key, collection2) {
        result[++index2] = iteratee(value, key, collection2);
      });
      return result;
    }
    function map(collection, iteratee) {
      var func = isArray$1(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee));
    }
    var BlockSwatches = function BlockSwatches2(_ref) {
      var colors = _ref.colors, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
      var styles = _default$2({
        "default": {
          swatches: {
            marginRight: "-10px"
          },
          swatch: {
            width: "22px",
            height: "22px",
            float: "left",
            marginRight: "10px",
            marginBottom: "10px",
            borderRadius: "4px"
          },
          clear: {
            clear: "both"
          }
        }
      });
      return React$1.createElement(
        "div",
        { style: styles.swatches },
        map(colors, function(c2) {
          return React$1.createElement(Swatch$1, {
            key: c2,
            color: c2,
            style: styles.swatch,
            onClick,
            onHover: onSwatchHover,
            focusStyle: {
              boxShadow: "0 0 4px " + c2
            }
          });
        }),
        React$1.createElement("div", { style: styles.clear })
      );
    };
    var Block = function Block2(_ref) {
      var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var transparent = hex === "transparent";
      var handleChange = function handleChange2(hexCode, e2) {
        isValidHex(hexCode) && onChange({
          hex: hexCode,
          source: "hex"
        }, e2);
      };
      var styles = _default$2(merge$1({
        "default": {
          card: {
            width,
            background: "#fff",
            boxShadow: "0 1px rgba(0,0,0,.1)",
            borderRadius: "6px",
            position: "relative"
          },
          head: {
            height: "110px",
            background: hex,
            borderRadius: "6px 6px 0 0",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            position: "relative"
          },
          body: {
            padding: "10px"
          },
          label: {
            fontSize: "18px",
            color: getContrastingColor(hex),
            position: "relative"
          },
          triangle: {
            width: "0px",
            height: "0px",
            borderStyle: "solid",
            borderWidth: "0 10px 10px 10px",
            borderColor: "transparent transparent " + hex + " transparent",
            position: "absolute",
            top: "-10px",
            left: "50%",
            marginLeft: "-10px"
          },
          input: {
            width: "100%",
            fontSize: "12px",
            color: "#666",
            border: "0px",
            outline: "none",
            height: "22px",
            boxShadow: "inset 0 0 0 1px #ddd",
            borderRadius: "4px",
            padding: "0 7px",
            boxSizing: "border-box"
          }
        },
        "hide-triangle": {
          triangle: {
            display: "none"
          }
        }
      }, passedStyles), { "hide-triangle": triangle === "hide" });
      return React$1.createElement(
        "div",
        { style: styles.card, className: "block-picker " + className },
        React$1.createElement("div", { style: styles.triangle }),
        React$1.createElement(
          "div",
          { style: styles.head },
          transparent && React$1.createElement(Checkboard, { borderRadius: "6px 6px 0 0" }),
          React$1.createElement(
            "div",
            { style: styles.label },
            hex
          )
        ),
        React$1.createElement(
          "div",
          { style: styles.body },
          React$1.createElement(BlockSwatches, { colors, onClick: handleChange, onSwatchHover }),
          React$1.createElement(EditableInput, {
            style: { input: styles.input },
            value: hex,
            onChange: handleChange
          })
        )
      );
    };
    Block.propTypes = {
      width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      colors: propTypesExports.arrayOf(propTypesExports.string),
      triangle: propTypesExports.oneOf(["top", "hide"]),
      styles: propTypesExports.object
    };
    Block.defaultProps = {
      width: 170,
      colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
      triangle: "top",
      styles: {}
    };
    ColorWrap(Block);
    var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
    var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
    var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
    var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
    var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
    var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
    var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
    var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
    var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
    var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
    var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
    var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
    var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
    var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
    var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
    var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
    var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
    var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };
    var CircleSwatch = function CircleSwatch2(_ref) {
      var color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, hover2 = _ref.hover, active2 = _ref.active, circleSize = _ref.circleSize, circleSpacing = _ref.circleSpacing;
      var styles = _default$2({
        "default": {
          swatch: {
            width: circleSize,
            height: circleSize,
            marginRight: circleSpacing,
            marginBottom: circleSpacing,
            transform: "scale(1)",
            transition: "100ms transform ease"
          },
          Swatch: {
            borderRadius: "50%",
            background: "transparent",
            boxShadow: "inset 0 0 0 " + (circleSize / 2 + 1) + "px " + color,
            transition: "100ms box-shadow ease"
          }
        },
        "hover": {
          swatch: {
            transform: "scale(1.2)"
          }
        },
        "active": {
          Swatch: {
            boxShadow: "inset 0 0 0 3px " + color
          }
        }
      }, { hover: hover2, active: active2 });
      return React$1.createElement(
        "div",
        { style: styles.swatch },
        React$1.createElement(Swatch$1, {
          style: styles.Swatch,
          color,
          onClick,
          onHover: onSwatchHover,
          focusStyle: { boxShadow: styles.Swatch.boxShadow + ", 0 0 5px " + color }
        })
      );
    };
    CircleSwatch.defaultProps = {
      circleSize: 28,
      circleSpacing: 14
    };
    const CircleSwatch$1 = handleHover(CircleSwatch);
    var Circle = function Circle2(_ref) {
      var width = _ref.width, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, circleSize = _ref.circleSize, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, circleSpacing = _ref.circleSpacing, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          card: {
            width,
            display: "flex",
            flexWrap: "wrap",
            marginRight: -circleSpacing,
            marginBottom: -circleSpacing
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(hexCode, e2) {
        return onChange({ hex: hexCode, source: "hex" }, e2);
      };
      return React$1.createElement(
        "div",
        { style: styles.card, className: "circle-picker " + className },
        map(colors, function(c2) {
          return React$1.createElement(CircleSwatch$1, {
            key: c2,
            color: c2,
            onClick: handleChange,
            onSwatchHover,
            active: hex === c2.toLowerCase(),
            circleSize,
            circleSpacing
          });
        })
      );
    };
    Circle.propTypes = {
      width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      circleSize: propTypesExports.number,
      circleSpacing: propTypesExports.number,
      styles: propTypesExports.object
    };
    Circle.defaultProps = {
      width: 252,
      circleSize: 28,
      circleSpacing: 14,
      colors: [red["500"], pink["500"], purple["500"], deepPurple["500"], indigo["500"], blue["500"], lightBlue["500"], cyan["500"], teal["500"], green["500"], lightGreen["500"], lime["500"], yellow["500"], amber["500"], orange["500"], deepOrange["500"], brown["500"], blueGrey["500"]],
      styles: {}
    };
    ColorWrap(Circle);
    function isUndefined(value) {
      return value === void 0;
    }
    var UnfoldMoreHorizontalIcon = {};
    Object.defineProperty(UnfoldMoreHorizontalIcon, "__esModule", {
      value: true
    });
    var _extends$4 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react$1 = reactExports;
    var _react2$1 = _interopRequireDefault$1(_react$1);
    function _interopRequireDefault$1(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties$1(obj, keys2) {
      var target = {};
      for (var i2 in obj) {
        if (keys2.indexOf(i2) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i2))
          continue;
        target[i2] = obj[i2];
      }
      return target;
    }
    var DEFAULT_SIZE$1 = 24;
    var _default$1 = UnfoldMoreHorizontalIcon.default = function(_ref) {
      var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE$1 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE$1 : _ref$height, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties$1(_ref, ["fill", "width", "height", "style"]);
      return _react2$1.default.createElement(
        "svg",
        _extends$4({
          viewBox: "0 0 " + DEFAULT_SIZE$1 + " " + DEFAULT_SIZE$1,
          style: _extends$4({ fill, width, height }, style2)
        }, props),
        _react2$1.default.createElement("path", { d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" })
      );
    };
    var _createClass$1 = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$1(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits$1(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var ChromeFields = function(_React$Component) {
      _inherits$1(ChromeFields2, _React$Component);
      function ChromeFields2(props) {
        _classCallCheck$1(this, ChromeFields2);
        var _this = _possibleConstructorReturn$1(this, (ChromeFields2.__proto__ || Object.getPrototypeOf(ChromeFields2)).call(this));
        _this.toggleViews = function() {
          if (_this.state.view === "hex") {
            _this.setState({ view: "rgb" });
          } else if (_this.state.view === "rgb") {
            _this.setState({ view: "hsl" });
          } else if (_this.state.view === "hsl") {
            if (_this.props.hsl.a === 1) {
              _this.setState({ view: "hex" });
            } else {
              _this.setState({ view: "rgb" });
            }
          }
        };
        _this.handleChange = function(data, e2) {
          if (data.hex) {
            isValidHex(data.hex) && _this.props.onChange({
              hex: data.hex,
              source: "hex"
            }, e2);
          } else if (data.r || data.g || data.b) {
            _this.props.onChange({
              r: data.r || _this.props.rgb.r,
              g: data.g || _this.props.rgb.g,
              b: data.b || _this.props.rgb.b,
              source: "rgb"
            }, e2);
          } else if (data.a) {
            if (data.a < 0) {
              data.a = 0;
            } else if (data.a > 1) {
              data.a = 1;
            }
            _this.props.onChange({
              h: _this.props.hsl.h,
              s: _this.props.hsl.s,
              l: _this.props.hsl.l,
              a: Math.round(data.a * 100) / 100,
              source: "rgb"
            }, e2);
          } else if (data.h || data.s || data.l) {
            if (typeof data.s === "string" && data.s.includes("%")) {
              data.s = data.s.replace("%", "");
            }
            if (typeof data.l === "string" && data.l.includes("%")) {
              data.l = data.l.replace("%", "");
            }
            if (data.s == 1) {
              data.s = 0.01;
            } else if (data.l == 1) {
              data.l = 0.01;
            }
            _this.props.onChange({
              h: data.h || _this.props.hsl.h,
              s: Number(!isUndefined(data.s) ? data.s : _this.props.hsl.s),
              l: Number(!isUndefined(data.l) ? data.l : _this.props.hsl.l),
              source: "hsl"
            }, e2);
          }
        };
        _this.showHighlight = function(e2) {
          e2.currentTarget.style.background = "#eee";
        };
        _this.hideHighlight = function(e2) {
          e2.currentTarget.style.background = "transparent";
        };
        if (props.hsl.a !== 1 && props.view === "hex") {
          _this.state = {
            view: "rgb"
          };
        } else {
          _this.state = {
            view: props.view
          };
        }
        return _this;
      }
      _createClass$1(ChromeFields2, [{
        key: "render",
        value: function render2() {
          var _this2 = this;
          var styles = _default$2({
            "default": {
              wrap: {
                paddingTop: "16px",
                display: "flex"
              },
              fields: {
                flex: "1",
                display: "flex",
                marginLeft: "-6px"
              },
              field: {
                paddingLeft: "6px",
                width: "100%"
              },
              alpha: {
                paddingLeft: "6px",
                width: "100%"
              },
              toggle: {
                width: "32px",
                textAlign: "right",
                position: "relative"
              },
              icon: {
                marginRight: "-4px",
                marginTop: "12px",
                cursor: "pointer",
                position: "relative"
              },
              iconHighlight: {
                position: "absolute",
                width: "24px",
                height: "28px",
                background: "#eee",
                borderRadius: "4px",
                top: "10px",
                left: "12px",
                display: "none"
              },
              input: {
                fontSize: "11px",
                color: "#333",
                width: "100%",
                borderRadius: "2px",
                border: "none",
                boxShadow: "inset 0 0 0 1px #dadada",
                height: "21px",
                textAlign: "center"
              },
              label: {
                textTransform: "uppercase",
                fontSize: "11px",
                lineHeight: "11px",
                color: "#969696",
                textAlign: "center",
                display: "block",
                marginTop: "12px"
              },
              svg: {
                fill: "#333",
                width: "24px",
                height: "24px",
                border: "1px transparent solid",
                borderRadius: "5px"
              }
            },
            "disableAlpha": {
              alpha: {
                display: "none"
              }
            }
          }, this.props, this.state);
          var fields = void 0;
          if (this.state.view === "hex") {
            fields = React$1.createElement(
              "div",
              { style: styles.fields, className: "flexbox-fix" },
              React$1.createElement(
                "div",
                { style: styles.field },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "hex",
                  value: this.props.hex,
                  onChange: this.handleChange
                })
              )
            );
          } else if (this.state.view === "rgb") {
            fields = React$1.createElement(
              "div",
              { style: styles.fields, className: "flexbox-fix" },
              React$1.createElement(
                "div",
                { style: styles.field },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "r",
                  value: this.props.rgb.r,
                  onChange: this.handleChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.field },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "g",
                  value: this.props.rgb.g,
                  onChange: this.handleChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.field },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "b",
                  value: this.props.rgb.b,
                  onChange: this.handleChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.alpha },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "a",
                  value: this.props.rgb.a,
                  arrowOffset: 0.01,
                  onChange: this.handleChange
                })
              )
            );
          } else if (this.state.view === "hsl") {
            fields = React$1.createElement(
              "div",
              { style: styles.fields, className: "flexbox-fix" },
              React$1.createElement(
                "div",
                { style: styles.field },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "h",
                  value: Math.round(this.props.hsl.h),
                  onChange: this.handleChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.field },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "s",
                  value: Math.round(this.props.hsl.s * 100) + "%",
                  onChange: this.handleChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.field },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "l",
                  value: Math.round(this.props.hsl.l * 100) + "%",
                  onChange: this.handleChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.alpha },
                React$1.createElement(EditableInput, {
                  style: { input: styles.input, label: styles.label },
                  label: "a",
                  value: this.props.hsl.a,
                  arrowOffset: 0.01,
                  onChange: this.handleChange
                })
              )
            );
          }
          return React$1.createElement(
            "div",
            { style: styles.wrap, className: "flexbox-fix" },
            fields,
            React$1.createElement(
              "div",
              { style: styles.toggle },
              React$1.createElement(
                "div",
                { style: styles.icon, onClick: this.toggleViews, ref: function ref(icon) {
                  return _this2.icon = icon;
                } },
                React$1.createElement(_default$1, {
                  style: styles.svg,
                  onMouseOver: this.showHighlight,
                  onMouseEnter: this.showHighlight,
                  onMouseOut: this.hideHighlight
                })
              )
            )
          );
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(nextProps, state) {
          if (nextProps.hsl.a !== 1 && state.view === "hex") {
            return { view: "rgb" };
          }
          return null;
        }
      }]);
      return ChromeFields2;
    }(React$1.Component);
    ChromeFields.defaultProps = {
      view: "hex"
    };
    var ChromePointer = function ChromePointer2() {
      var styles = _default$2({
        "default": {
          picker: {
            width: "12px",
            height: "12px",
            borderRadius: "6px",
            transform: "translate(-6px, -1px)",
            backgroundColor: "rgb(248, 248, 248)",
            boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
          }
        }
      });
      return React$1.createElement("div", { style: styles.picker });
    };
    var ChromePointerCircle = function ChromePointerCircle2() {
      var styles = _default$2({
        "default": {
          picker: {
            width: "12px",
            height: "12px",
            borderRadius: "6px",
            boxShadow: "inset 0 0 0 1px #fff",
            transform: "translate(-6px, -6px)"
          }
        }
      });
      return React$1.createElement("div", { style: styles.picker });
    };
    var Chrome = function Chrome2(_ref) {
      var width = _ref.width, onChange = _ref.onChange, disableAlpha = _ref.disableAlpha, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, defaultView = _ref.defaultView;
      var styles = _default$2(merge$1({
        "default": {
          picker: {
            width,
            background: "#fff",
            borderRadius: "2px",
            boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
            boxSizing: "initial",
            fontFamily: "Menlo"
          },
          saturation: {
            width: "100%",
            paddingBottom: "55%",
            position: "relative",
            borderRadius: "2px 2px 0 0",
            overflow: "hidden"
          },
          Saturation: {
            radius: "2px 2px 0 0"
          },
          body: {
            padding: "16px 16px 12px"
          },
          controls: {
            display: "flex"
          },
          color: {
            width: "32px"
          },
          swatch: {
            marginTop: "6px",
            width: "16px",
            height: "16px",
            borderRadius: "8px",
            position: "relative",
            overflow: "hidden"
          },
          active: {
            absolute: "0px 0px 0px 0px",
            borderRadius: "8px",
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
            background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + rgb.a + ")",
            zIndex: "2"
          },
          toggles: {
            flex: "1"
          },
          hue: {
            height: "10px",
            position: "relative",
            marginBottom: "8px"
          },
          Hue: {
            radius: "2px"
          },
          alpha: {
            height: "10px",
            position: "relative"
          },
          Alpha: {
            radius: "2px"
          }
        },
        "disableAlpha": {
          color: {
            width: "22px"
          },
          alpha: {
            display: "none"
          },
          hue: {
            marginBottom: "0px"
          },
          swatch: {
            width: "10px",
            height: "10px",
            marginTop: "0px"
          }
        }
      }, passedStyles), { disableAlpha });
      return React$1.createElement(
        "div",
        { style: styles.picker, className: "chrome-picker " + className },
        React$1.createElement(
          "div",
          { style: styles.saturation },
          React$1.createElement(Saturation, {
            style: styles.Saturation,
            hsl,
            hsv,
            pointer: ChromePointerCircle,
            onChange
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.body },
          React$1.createElement(
            "div",
            { style: styles.controls, className: "flexbox-fix" },
            React$1.createElement(
              "div",
              { style: styles.color },
              React$1.createElement(
                "div",
                { style: styles.swatch },
                React$1.createElement("div", { style: styles.active }),
                React$1.createElement(Checkboard, { renderers })
              )
            ),
            React$1.createElement(
              "div",
              { style: styles.toggles },
              React$1.createElement(
                "div",
                { style: styles.hue },
                React$1.createElement(Hue, {
                  style: styles.Hue,
                  hsl,
                  pointer: ChromePointer,
                  onChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.alpha },
                React$1.createElement(Alpha, {
                  style: styles.Alpha,
                  rgb,
                  hsl,
                  pointer: ChromePointer,
                  renderers,
                  onChange
                })
              )
            )
          ),
          React$1.createElement(ChromeFields, {
            rgb,
            hsl,
            hex,
            view: defaultView,
            onChange,
            disableAlpha
          })
        )
      );
    };
    Chrome.propTypes = {
      width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      disableAlpha: propTypesExports.bool,
      styles: propTypesExports.object,
      defaultView: propTypesExports.oneOf(["hex", "rgb", "hsl"])
    };
    Chrome.defaultProps = {
      width: 225,
      disableAlpha: false,
      styles: {}
    };
    ColorWrap(Chrome);
    var CompactColor = function CompactColor2(_ref) {
      var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, active2 = _ref.active;
      var styles = _default$2({
        "default": {
          color: {
            background: color,
            width: "15px",
            height: "15px",
            float: "left",
            marginRight: "5px",
            marginBottom: "5px",
            position: "relative",
            cursor: "pointer"
          },
          dot: {
            absolute: "5px 5px 5px 5px",
            background: getContrastingColor(color),
            borderRadius: "50%",
            opacity: "0"
          }
        },
        "active": {
          dot: {
            opacity: "1"
          }
        },
        "color-#FFFFFF": {
          color: {
            boxShadow: "inset 0 0 0 1px #ddd"
          },
          dot: {
            background: "#000"
          }
        },
        "transparent": {
          dot: {
            background: "#000"
          }
        }
      }, { active: active2, "color-#FFFFFF": color === "#FFFFFF", "transparent": color === "transparent" });
      return React$1.createElement(
        Swatch$1,
        {
          style: styles.color,
          color,
          onClick,
          onHover: onSwatchHover,
          focusStyle: { boxShadow: "0 0 4px " + color }
        },
        React$1.createElement("div", { style: styles.dot })
      );
    };
    var CompactFields = function CompactFields2(_ref) {
      var hex = _ref.hex, rgb = _ref.rgb, onChange = _ref.onChange;
      var styles = _default$2({
        "default": {
          fields: {
            display: "flex",
            paddingBottom: "6px",
            paddingRight: "5px",
            position: "relative"
          },
          active: {
            position: "absolute",
            top: "6px",
            left: "5px",
            height: "9px",
            width: "9px",
            background: hex
          },
          HEXwrap: {
            flex: "6",
            position: "relative"
          },
          HEXinput: {
            width: "80%",
            padding: "0px",
            paddingLeft: "20%",
            border: "none",
            outline: "none",
            background: "none",
            fontSize: "12px",
            color: "#333",
            height: "16px"
          },
          HEXlabel: {
            display: "none"
          },
          RGBwrap: {
            flex: "3",
            position: "relative"
          },
          RGBinput: {
            width: "70%",
            padding: "0px",
            paddingLeft: "30%",
            border: "none",
            outline: "none",
            background: "none",
            fontSize: "12px",
            color: "#333",
            height: "16px"
          },
          RGBlabel: {
            position: "absolute",
            top: "3px",
            left: "0px",
            lineHeight: "16px",
            textTransform: "uppercase",
            fontSize: "12px",
            color: "#999"
          }
        }
      });
      var handleChange = function handleChange2(data, e2) {
        if (data.r || data.g || data.b) {
          onChange({
            r: data.r || rgb.r,
            g: data.g || rgb.g,
            b: data.b || rgb.b,
            source: "rgb"
          }, e2);
        } else {
          onChange({
            hex: data.hex,
            source: "hex"
          }, e2);
        }
      };
      return React$1.createElement(
        "div",
        { style: styles.fields, className: "flexbox-fix" },
        React$1.createElement("div", { style: styles.active }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
          label: "hex",
          value: hex,
          onChange: handleChange
        }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "r",
          value: rgb.r,
          onChange: handleChange
        }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "g",
          value: rgb.g,
          onChange: handleChange
        }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "b",
          value: rgb.b,
          onChange: handleChange
        })
      );
    };
    var Compact = function Compact2(_ref) {
      var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          Compact: {
            background: "#f6f6f6",
            radius: "4px"
          },
          compact: {
            paddingTop: "5px",
            paddingLeft: "5px",
            boxSizing: "initial",
            width: "240px"
          },
          clear: {
            clear: "both"
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(data, e2) {
        if (data.hex) {
          isValidHex(data.hex) && onChange({
            hex: data.hex,
            source: "hex"
          }, e2);
        } else {
          onChange(data, e2);
        }
      };
      return React$1.createElement(
        Raised,
        { style: styles.Compact, styles: passedStyles },
        React$1.createElement(
          "div",
          { style: styles.compact, className: "compact-picker " + className },
          React$1.createElement(
            "div",
            null,
            map(colors, function(c2) {
              return React$1.createElement(CompactColor, {
                key: c2,
                color: c2,
                active: c2.toLowerCase() === hex,
                onClick: handleChange,
                onSwatchHover
              });
            }),
            React$1.createElement("div", { style: styles.clear })
          ),
          React$1.createElement(CompactFields, { hex, rgb, onChange: handleChange })
        )
      );
    };
    Compact.propTypes = {
      colors: propTypesExports.arrayOf(propTypesExports.string),
      styles: propTypesExports.object
    };
    Compact.defaultProps = {
      colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
      styles: {}
    };
    const CompactPicker = ColorWrap(Compact);
    var GithubSwatch = function GithubSwatch2(_ref) {
      var hover2 = _ref.hover, color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
      var hoverSwatch = {
        position: "relative",
        zIndex: "2",
        outline: "2px solid #fff",
        boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
      };
      var styles = _default$2({
        "default": {
          swatch: {
            width: "25px",
            height: "25px",
            fontSize: "0"
          }
        },
        "hover": {
          swatch: hoverSwatch
        }
      }, { hover: hover2 });
      return React$1.createElement(
        "div",
        { style: styles.swatch },
        React$1.createElement(Swatch$1, {
          color,
          onClick,
          onHover: onSwatchHover,
          focusStyle: hoverSwatch
        })
      );
    };
    const GithubSwatch$1 = handleHover(GithubSwatch);
    var Github = function Github2(_ref) {
      var width = _ref.width, colors = _ref.colors, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          card: {
            width,
            background: "#fff",
            border: "1px solid rgba(0,0,0,0.2)",
            boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
            borderRadius: "4px",
            position: "relative",
            padding: "5px",
            display: "flex",
            flexWrap: "wrap"
          },
          triangle: {
            position: "absolute",
            border: "7px solid transparent",
            borderBottomColor: "#fff"
          },
          triangleShadow: {
            position: "absolute",
            border: "8px solid transparent",
            borderBottomColor: "rgba(0,0,0,0.15)"
          }
        },
        "hide-triangle": {
          triangle: {
            display: "none"
          },
          triangleShadow: {
            display: "none"
          }
        },
        "top-left-triangle": {
          triangle: {
            top: "-14px",
            left: "10px"
          },
          triangleShadow: {
            top: "-16px",
            left: "9px"
          }
        },
        "top-right-triangle": {
          triangle: {
            top: "-14px",
            right: "10px"
          },
          triangleShadow: {
            top: "-16px",
            right: "9px"
          }
        },
        "bottom-left-triangle": {
          triangle: {
            top: "35px",
            left: "10px",
            transform: "rotate(180deg)"
          },
          triangleShadow: {
            top: "37px",
            left: "9px",
            transform: "rotate(180deg)"
          }
        },
        "bottom-right-triangle": {
          triangle: {
            top: "35px",
            right: "10px",
            transform: "rotate(180deg)"
          },
          triangleShadow: {
            top: "37px",
            right: "9px",
            transform: "rotate(180deg)"
          }
        }
      }, passedStyles), {
        "hide-triangle": triangle === "hide",
        "top-left-triangle": triangle === "top-left",
        "top-right-triangle": triangle === "top-right",
        "bottom-left-triangle": triangle === "bottom-left",
        "bottom-right-triangle": triangle === "bottom-right"
      });
      var handleChange = function handleChange2(hex, e2) {
        return onChange({ hex, source: "hex" }, e2);
      };
      return React$1.createElement(
        "div",
        { style: styles.card, className: "github-picker " + className },
        React$1.createElement("div", { style: styles.triangleShadow }),
        React$1.createElement("div", { style: styles.triangle }),
        map(colors, function(c2) {
          return React$1.createElement(GithubSwatch$1, {
            color: c2,
            key: c2,
            onClick: handleChange,
            onSwatchHover
          });
        })
      );
    };
    Github.propTypes = {
      width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      colors: propTypesExports.arrayOf(propTypesExports.string),
      triangle: propTypesExports.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
      styles: propTypesExports.object
    };
    Github.defaultProps = {
      width: 200,
      colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
      triangle: "top-left",
      styles: {}
    };
    ColorWrap(Github);
    var SliderPointer$1 = function SliderPointer2(_ref) {
      var direction = _ref.direction;
      var styles = _default$2({
        "default": {
          picker: {
            width: "18px",
            height: "18px",
            borderRadius: "50%",
            transform: "translate(-9px, -1px)",
            backgroundColor: "rgb(248, 248, 248)",
            boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
          }
        },
        "vertical": {
          picker: {
            transform: "translate(-3px, -9px)"
          }
        }
      }, { vertical: direction === "vertical" });
      return React$1.createElement("div", { style: styles.picker });
    };
    var _extends$3 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var HuePicker = function HuePicker2(_ref) {
      var width = _ref.width, height = _ref.height, onChange = _ref.onChange, hsl = _ref.hsl, direction = _ref.direction, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          picker: {
            position: "relative",
            width,
            height
          },
          hue: {
            radius: "2px"
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(data) {
        return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
      };
      return React$1.createElement(
        "div",
        { style: styles.picker, className: "hue-picker " + className },
        React$1.createElement(Hue, _extends$3({}, styles.hue, {
          hsl,
          pointer,
          onChange: handleChange,
          direction
        }))
      );
    };
    HuePicker.propTypes = {
      styles: propTypesExports.object
    };
    HuePicker.defaultProps = {
      width: "316px",
      height: "16px",
      direction: "horizontal",
      pointer: SliderPointer$1,
      styles: {}
    };
    ColorWrap(HuePicker);
    var Material = function Material2(_ref) {
      var onChange = _ref.onChange, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          material: {
            width: "98px",
            height: "98px",
            padding: "16px",
            fontFamily: "Roboto"
          },
          HEXwrap: {
            position: "relative"
          },
          HEXinput: {
            width: "100%",
            marginTop: "12px",
            fontSize: "15px",
            color: "#333",
            padding: "0px",
            border: "0px",
            borderBottom: "2px solid " + hex,
            outline: "none",
            height: "30px"
          },
          HEXlabel: {
            position: "absolute",
            top: "0px",
            left: "0px",
            fontSize: "11px",
            color: "#999999",
            textTransform: "capitalize"
          },
          Hex: {
            style: {}
          },
          RGBwrap: {
            position: "relative"
          },
          RGBinput: {
            width: "100%",
            marginTop: "12px",
            fontSize: "15px",
            color: "#333",
            padding: "0px",
            border: "0px",
            borderBottom: "1px solid #eee",
            outline: "none",
            height: "30px"
          },
          RGBlabel: {
            position: "absolute",
            top: "0px",
            left: "0px",
            fontSize: "11px",
            color: "#999999",
            textTransform: "capitalize"
          },
          split: {
            display: "flex",
            marginRight: "-10px",
            paddingTop: "11px"
          },
          third: {
            flex: "1",
            paddingRight: "10px"
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(data, e2) {
        if (data.hex) {
          isValidHex(data.hex) && onChange({
            hex: data.hex,
            source: "hex"
          }, e2);
        } else if (data.r || data.g || data.b) {
          onChange({
            r: data.r || rgb.r,
            g: data.g || rgb.g,
            b: data.b || rgb.b,
            source: "rgb"
          }, e2);
        }
      };
      return React$1.createElement(
        Raised,
        { styles: passedStyles },
        React$1.createElement(
          "div",
          { style: styles.material, className: "material-picker " + className },
          React$1.createElement(EditableInput, {
            style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
            label: "hex",
            value: hex,
            onChange: handleChange
          }),
          React$1.createElement(
            "div",
            { style: styles.split, className: "flexbox-fix" },
            React$1.createElement(
              "div",
              { style: styles.third },
              React$1.createElement(EditableInput, {
                style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
                label: "r",
                value: rgb.r,
                onChange: handleChange
              })
            ),
            React$1.createElement(
              "div",
              { style: styles.third },
              React$1.createElement(EditableInput, {
                style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
                label: "g",
                value: rgb.g,
                onChange: handleChange
              })
            ),
            React$1.createElement(
              "div",
              { style: styles.third },
              React$1.createElement(EditableInput, {
                style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
                label: "b",
                value: rgb.b,
                onChange: handleChange
              })
            )
          )
        )
      );
    };
    ColorWrap(Material);
    var PhotoshopPicker = function PhotoshopPicker2(_ref) {
      var onChange = _ref.onChange, rgb = _ref.rgb, hsv = _ref.hsv, hex = _ref.hex;
      var styles = _default$2({
        "default": {
          fields: {
            paddingTop: "5px",
            paddingBottom: "9px",
            width: "80px",
            position: "relative"
          },
          divider: {
            height: "5px"
          },
          RGBwrap: {
            position: "relative"
          },
          RGBinput: {
            marginLeft: "40%",
            width: "40%",
            height: "18px",
            border: "1px solid #888888",
            boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
            marginBottom: "5px",
            fontSize: "13px",
            paddingLeft: "3px",
            marginRight: "10px"
          },
          RGBlabel: {
            left: "0px",
            top: "0px",
            width: "34px",
            textTransform: "uppercase",
            fontSize: "13px",
            height: "18px",
            lineHeight: "22px",
            position: "absolute"
          },
          HEXwrap: {
            position: "relative"
          },
          HEXinput: {
            marginLeft: "20%",
            width: "80%",
            height: "18px",
            border: "1px solid #888888",
            boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
            marginBottom: "6px",
            fontSize: "13px",
            paddingLeft: "3px"
          },
          HEXlabel: {
            position: "absolute",
            top: "0px",
            left: "0px",
            width: "14px",
            textTransform: "uppercase",
            fontSize: "13px",
            height: "18px",
            lineHeight: "22px"
          },
          fieldSymbols: {
            position: "absolute",
            top: "5px",
            right: "-7px",
            fontSize: "13px"
          },
          symbol: {
            height: "20px",
            lineHeight: "22px",
            paddingBottom: "7px"
          }
        }
      });
      var handleChange = function handleChange2(data, e2) {
        if (data["#"]) {
          isValidHex(data["#"]) && onChange({
            hex: data["#"],
            source: "hex"
          }, e2);
        } else if (data.r || data.g || data.b) {
          onChange({
            r: data.r || rgb.r,
            g: data.g || rgb.g,
            b: data.b || rgb.b,
            source: "rgb"
          }, e2);
        } else if (data.h || data.s || data.v) {
          onChange({
            h: data.h || hsv.h,
            s: data.s || hsv.s,
            v: data.v || hsv.v,
            source: "hsv"
          }, e2);
        }
      };
      return React$1.createElement(
        "div",
        { style: styles.fields },
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "h",
          value: Math.round(hsv.h),
          onChange: handleChange
        }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "s",
          value: Math.round(hsv.s * 100),
          onChange: handleChange
        }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "v",
          value: Math.round(hsv.v * 100),
          onChange: handleChange
        }),
        React$1.createElement("div", { style: styles.divider }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "r",
          value: rgb.r,
          onChange: handleChange
        }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "g",
          value: rgb.g,
          onChange: handleChange
        }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
          label: "b",
          value: rgb.b,
          onChange: handleChange
        }),
        React$1.createElement("div", { style: styles.divider }),
        React$1.createElement(EditableInput, {
          style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
          label: "#",
          value: hex.replace("#", ""),
          onChange: handleChange
        }),
        React$1.createElement(
          "div",
          { style: styles.fieldSymbols },
          React$1.createElement(
            "div",
            { style: styles.symbol },
            ""
          ),
          React$1.createElement(
            "div",
            { style: styles.symbol },
            "%"
          ),
          React$1.createElement(
            "div",
            { style: styles.symbol },
            "%"
          )
        )
      );
    };
    var PhotoshopPointerCircle$1 = function PhotoshopPointerCircle2(_ref) {
      var hsl = _ref.hsl;
      var styles = _default$2({
        "default": {
          picker: {
            width: "12px",
            height: "12px",
            borderRadius: "6px",
            boxShadow: "inset 0 0 0 1px #fff",
            transform: "translate(-6px, -6px)"
          }
        },
        "black-outline": {
          picker: {
            boxShadow: "inset 0 0 0 1px #000"
          }
        }
      }, { "black-outline": hsl.l > 0.5 });
      return React$1.createElement("div", { style: styles.picker });
    };
    var PhotoshopPointerCircle = function PhotoshopPointerCircle2() {
      var styles = _default$2({
        "default": {
          triangle: {
            width: 0,
            height: 0,
            borderStyle: "solid",
            borderWidth: "4px 0 4px 6px",
            borderColor: "transparent transparent transparent #fff",
            position: "absolute",
            top: "1px",
            left: "1px"
          },
          triangleBorder: {
            width: 0,
            height: 0,
            borderStyle: "solid",
            borderWidth: "5px 0 5px 8px",
            borderColor: "transparent transparent transparent #555"
          },
          left: {
            Extend: "triangleBorder",
            transform: "translate(-13px, -4px)"
          },
          leftInside: {
            Extend: "triangle",
            transform: "translate(-8px, -5px)"
          },
          right: {
            Extend: "triangleBorder",
            transform: "translate(20px, -14px) rotate(180deg)"
          },
          rightInside: {
            Extend: "triangle",
            transform: "translate(-8px, -5px)"
          }
        }
      });
      return React$1.createElement(
        "div",
        { style: styles.pointer },
        React$1.createElement(
          "div",
          { style: styles.left },
          React$1.createElement("div", { style: styles.leftInside })
        ),
        React$1.createElement(
          "div",
          { style: styles.right },
          React$1.createElement("div", { style: styles.rightInside })
        )
      );
    };
    var PhotoshopButton = function PhotoshopButton2(_ref) {
      var onClick = _ref.onClick, label = _ref.label, children = _ref.children, active2 = _ref.active;
      var styles = _default$2({
        "default": {
          button: {
            backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
            border: "1px solid #878787",
            borderRadius: "2px",
            height: "20px",
            boxShadow: "0 1px 0 0 #EAEAEA",
            fontSize: "14px",
            color: "#000",
            lineHeight: "20px",
            textAlign: "center",
            marginBottom: "10px",
            cursor: "pointer"
          }
        },
        "active": {
          button: {
            boxShadow: "0 0 0 1px #878787"
          }
        }
      }, { active: active2 });
      return React$1.createElement(
        "div",
        { style: styles.button, onClick },
        label || children
      );
    };
    var PhotoshopPreviews = function PhotoshopPreviews2(_ref) {
      var rgb = _ref.rgb, currentColor = _ref.currentColor;
      var styles = _default$2({
        "default": {
          swatches: {
            border: "1px solid #B3B3B3",
            borderBottom: "1px solid #F0F0F0",
            marginBottom: "2px",
            marginTop: "1px"
          },
          new: {
            height: "34px",
            background: "rgb(" + rgb.r + "," + rgb.g + ", " + rgb.b + ")",
            boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
          },
          current: {
            height: "34px",
            background: currentColor,
            boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
          },
          label: {
            fontSize: "14px",
            color: "#000",
            textAlign: "center"
          }
        }
      });
      return React$1.createElement(
        "div",
        null,
        React$1.createElement(
          "div",
          { style: styles.label },
          "new"
        ),
        React$1.createElement(
          "div",
          { style: styles.swatches },
          React$1.createElement("div", { style: styles.new }),
          React$1.createElement("div", { style: styles.current })
        ),
        React$1.createElement(
          "div",
          { style: styles.label },
          "current"
        )
      );
    };
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call2) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Photoshop = function(_React$Component) {
      _inherits(Photoshop2, _React$Component);
      function Photoshop2(props) {
        _classCallCheck(this, Photoshop2);
        var _this = _possibleConstructorReturn(this, (Photoshop2.__proto__ || Object.getPrototypeOf(Photoshop2)).call(this));
        _this.state = {
          currentColor: props.hex
        };
        return _this;
      }
      _createClass(Photoshop2, [{
        key: "render",
        value: function render2() {
          var _props = this.props, _props$styles = _props.styles, passedStyles = _props$styles === void 0 ? {} : _props$styles, _props$className = _props.className, className = _props$className === void 0 ? "" : _props$className;
          var styles = _default$2(merge$1({
            "default": {
              picker: {
                background: "#DCDCDC",
                borderRadius: "4px",
                boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
                boxSizing: "initial",
                width: "513px"
              },
              head: {
                backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
                borderBottom: "1px solid #B1B1B1",
                boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
                height: "23px",
                lineHeight: "24px",
                borderRadius: "4px 4px 0 0",
                fontSize: "13px",
                color: "#4D4D4D",
                textAlign: "center"
              },
              body: {
                padding: "15px 15px 0",
                display: "flex"
              },
              saturation: {
                width: "256px",
                height: "256px",
                position: "relative",
                border: "2px solid #B3B3B3",
                borderBottom: "2px solid #F0F0F0",
                overflow: "hidden"
              },
              hue: {
                position: "relative",
                height: "256px",
                width: "19px",
                marginLeft: "10px",
                border: "2px solid #B3B3B3",
                borderBottom: "2px solid #F0F0F0"
              },
              controls: {
                width: "180px",
                marginLeft: "10px"
              },
              top: {
                display: "flex"
              },
              previews: {
                width: "60px"
              },
              actions: {
                flex: "1",
                marginLeft: "20px"
              }
            }
          }, passedStyles));
          return React$1.createElement(
            "div",
            { style: styles.picker, className: "photoshop-picker " + className },
            React$1.createElement(
              "div",
              { style: styles.head },
              this.props.header
            ),
            React$1.createElement(
              "div",
              { style: styles.body, className: "flexbox-fix" },
              React$1.createElement(
                "div",
                { style: styles.saturation },
                React$1.createElement(Saturation, {
                  hsl: this.props.hsl,
                  hsv: this.props.hsv,
                  pointer: PhotoshopPointerCircle$1,
                  onChange: this.props.onChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.hue },
                React$1.createElement(Hue, {
                  direction: "vertical",
                  hsl: this.props.hsl,
                  pointer: PhotoshopPointerCircle,
                  onChange: this.props.onChange
                })
              ),
              React$1.createElement(
                "div",
                { style: styles.controls },
                React$1.createElement(
                  "div",
                  { style: styles.top, className: "flexbox-fix" },
                  React$1.createElement(
                    "div",
                    { style: styles.previews },
                    React$1.createElement(PhotoshopPreviews, {
                      rgb: this.props.rgb,
                      currentColor: this.state.currentColor
                    })
                  ),
                  React$1.createElement(
                    "div",
                    { style: styles.actions },
                    React$1.createElement(PhotoshopButton, { label: "OK", onClick: this.props.onAccept, active: true }),
                    React$1.createElement(PhotoshopButton, { label: "Cancel", onClick: this.props.onCancel }),
                    React$1.createElement(PhotoshopPicker, {
                      onChange: this.props.onChange,
                      rgb: this.props.rgb,
                      hsv: this.props.hsv,
                      hex: this.props.hex
                    })
                  )
                )
              )
            )
          );
        }
      }]);
      return Photoshop2;
    }(React$1.Component);
    Photoshop.propTypes = {
      header: propTypesExports.string,
      styles: propTypesExports.object
    };
    Photoshop.defaultProps = {
      header: "Color Picker",
      styles: {}
    };
    ColorWrap(Photoshop);
    var SketchFields = function SketchFields2(_ref) {
      var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, disableAlpha = _ref.disableAlpha;
      var styles = _default$2({
        "default": {
          fields: {
            display: "flex",
            paddingTop: "4px"
          },
          single: {
            flex: "1",
            paddingLeft: "6px"
          },
          alpha: {
            flex: "1",
            paddingLeft: "6px"
          },
          double: {
            flex: "2"
          },
          input: {
            width: "80%",
            padding: "4px 10% 3px",
            border: "none",
            boxShadow: "inset 0 0 0 1px #ccc",
            fontSize: "11px"
          },
          label: {
            display: "block",
            textAlign: "center",
            fontSize: "11px",
            color: "#222",
            paddingTop: "3px",
            paddingBottom: "4px",
            textTransform: "capitalize"
          }
        },
        "disableAlpha": {
          alpha: {
            display: "none"
          }
        }
      }, { disableAlpha });
      var handleChange = function handleChange2(data, e2) {
        if (data.hex) {
          isValidHex(data.hex) && onChange({
            hex: data.hex,
            source: "hex"
          }, e2);
        } else if (data.r || data.g || data.b) {
          onChange({
            r: data.r || rgb.r,
            g: data.g || rgb.g,
            b: data.b || rgb.b,
            a: rgb.a,
            source: "rgb"
          }, e2);
        } else if (data.a) {
          if (data.a < 0) {
            data.a = 0;
          } else if (data.a > 100) {
            data.a = 100;
          }
          data.a /= 100;
          onChange({
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a: data.a,
            source: "rgb"
          }, e2);
        }
      };
      return React$1.createElement(
        "div",
        { style: styles.fields, className: "flexbox-fix" },
        React$1.createElement(
          "div",
          { style: styles.double },
          React$1.createElement(EditableInput, {
            style: { input: styles.input, label: styles.label },
            label: "hex",
            value: hex.replace("#", ""),
            onChange: handleChange
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.single },
          React$1.createElement(EditableInput, {
            style: { input: styles.input, label: styles.label },
            label: "r",
            value: rgb.r,
            onChange: handleChange,
            dragLabel: "true",
            dragMax: "255"
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.single },
          React$1.createElement(EditableInput, {
            style: { input: styles.input, label: styles.label },
            label: "g",
            value: rgb.g,
            onChange: handleChange,
            dragLabel: "true",
            dragMax: "255"
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.single },
          React$1.createElement(EditableInput, {
            style: { input: styles.input, label: styles.label },
            label: "b",
            value: rgb.b,
            onChange: handleChange,
            dragLabel: "true",
            dragMax: "255"
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.alpha },
          React$1.createElement(EditableInput, {
            style: { input: styles.input, label: styles.label },
            label: "a",
            value: Math.round(rgb.a * 100),
            onChange: handleChange,
            dragLabel: "true",
            dragMax: "100"
          })
        )
      );
    };
    var _extends$2 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var SketchPresetColors = function SketchPresetColors2(_ref) {
      var colors = _ref.colors, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, onSwatchHover = _ref.onSwatchHover;
      var styles = _default$2({
        "default": {
          colors: {
            margin: "0 -10px",
            padding: "10px 0 0 10px",
            borderTop: "1px solid #eee",
            display: "flex",
            flexWrap: "wrap",
            position: "relative"
          },
          swatchWrap: {
            width: "16px",
            height: "16px",
            margin: "0 10px 10px 0"
          },
          swatch: {
            borderRadius: "3px",
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
          }
        },
        "no-presets": {
          colors: {
            display: "none"
          }
        }
      }, {
        "no-presets": !colors || !colors.length
      });
      var handleClick = function handleClick2(hex, e2) {
        onClick({
          hex,
          source: "hex"
        }, e2);
      };
      return React$1.createElement(
        "div",
        { style: styles.colors, className: "flexbox-fix" },
        colors.map(function(colorObjOrString) {
          var c2 = typeof colorObjOrString === "string" ? { color: colorObjOrString } : colorObjOrString;
          var key = "" + c2.color + (c2.title || "");
          return React$1.createElement(
            "div",
            { key, style: styles.swatchWrap },
            React$1.createElement(Swatch$1, _extends$2({}, c2, {
              style: styles.swatch,
              onClick: handleClick,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c2.color
              }
            }))
          );
        })
      );
    };
    SketchPresetColors.propTypes = {
      colors: propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.string, propTypesExports.shape({
        color: propTypesExports.string,
        title: propTypesExports.string
      })])).isRequired
    };
    var _extends$1 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var Sketch = function Sketch2(_ref) {
      var width = _ref.width, rgb = _ref.rgb, hex = _ref.hex, hsv = _ref.hsv, hsl = _ref.hsl, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, disableAlpha = _ref.disableAlpha, presetColors = _ref.presetColors, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": _extends$1({
          picker: {
            width,
            padding: "10px 10px 0",
            boxSizing: "initial",
            background: "#fff",
            borderRadius: "4px",
            boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
          },
          saturation: {
            width: "100%",
            paddingBottom: "75%",
            position: "relative",
            overflow: "hidden"
          },
          Saturation: {
            radius: "3px",
            shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
          },
          controls: {
            display: "flex"
          },
          sliders: {
            padding: "4px 0",
            flex: "1"
          },
          color: {
            width: "24px",
            height: "24px",
            position: "relative",
            marginTop: "4px",
            marginLeft: "4px",
            borderRadius: "3px"
          },
          activeColor: {
            absolute: "0px 0px 0px 0px",
            borderRadius: "2px",
            background: "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + rgb.a + ")",
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
          },
          hue: {
            position: "relative",
            height: "10px",
            overflow: "hidden"
          },
          Hue: {
            radius: "2px",
            shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
          },
          alpha: {
            position: "relative",
            height: "10px",
            marginTop: "4px",
            overflow: "hidden"
          },
          Alpha: {
            radius: "2px",
            shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
          }
        }, passedStyles),
        "disableAlpha": {
          color: {
            height: "10px"
          },
          hue: {
            height: "10px"
          },
          alpha: {
            display: "none"
          }
        }
      }, passedStyles), { disableAlpha });
      return React$1.createElement(
        "div",
        { style: styles.picker, className: "sketch-picker " + className },
        React$1.createElement(
          "div",
          { style: styles.saturation },
          React$1.createElement(Saturation, {
            style: styles.Saturation,
            hsl,
            hsv,
            onChange
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.controls, className: "flexbox-fix" },
          React$1.createElement(
            "div",
            { style: styles.sliders },
            React$1.createElement(
              "div",
              { style: styles.hue },
              React$1.createElement(Hue, {
                style: styles.Hue,
                hsl,
                onChange
              })
            ),
            React$1.createElement(
              "div",
              { style: styles.alpha },
              React$1.createElement(Alpha, {
                style: styles.Alpha,
                rgb,
                hsl,
                renderers,
                onChange
              })
            )
          ),
          React$1.createElement(
            "div",
            { style: styles.color },
            React$1.createElement(Checkboard, null),
            React$1.createElement("div", { style: styles.activeColor })
          )
        ),
        React$1.createElement(SketchFields, {
          rgb,
          hsl,
          hex,
          onChange,
          disableAlpha
        }),
        React$1.createElement(SketchPresetColors, {
          colors: presetColors,
          onClick: onChange,
          onSwatchHover
        })
      );
    };
    Sketch.propTypes = {
      disableAlpha: propTypesExports.bool,
      width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      styles: propTypesExports.object
    };
    Sketch.defaultProps = {
      disableAlpha: false,
      width: 200,
      styles: {},
      presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
    };
    ColorWrap(Sketch);
    var SliderSwatch = function SliderSwatch2(_ref) {
      var hsl = _ref.hsl, offset = _ref.offset, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, active2 = _ref.active, first = _ref.first, last = _ref.last;
      var styles = _default$2({
        "default": {
          swatch: {
            height: "12px",
            background: "hsl(" + hsl.h + ", 50%, " + offset * 100 + "%)",
            cursor: "pointer"
          }
        },
        "first": {
          swatch: {
            borderRadius: "2px 0 0 2px"
          }
        },
        "last": {
          swatch: {
            borderRadius: "0 2px 2px 0"
          }
        },
        "active": {
          swatch: {
            transform: "scaleY(1.8)",
            borderRadius: "3.6px/2px"
          }
        }
      }, { active: active2, first, last });
      var handleClick = function handleClick2(e2) {
        return onClick({
          h: hsl.h,
          s: 0.5,
          l: offset,
          source: "hsl"
        }, e2);
      };
      return React$1.createElement("div", { style: styles.swatch, onClick: handleClick });
    };
    var SliderSwatches = function SliderSwatches2(_ref) {
      var onClick = _ref.onClick, hsl = _ref.hsl;
      var styles = _default$2({
        "default": {
          swatches: {
            marginTop: "20px"
          },
          swatch: {
            boxSizing: "border-box",
            width: "20%",
            paddingRight: "1px",
            float: "left"
          },
          clear: {
            clear: "both"
          }
        }
      });
      var epsilon = 0.1;
      return React$1.createElement(
        "div",
        { style: styles.swatches },
        React$1.createElement(
          "div",
          { style: styles.swatch },
          React$1.createElement(SliderSwatch, {
            hsl,
            offset: ".80",
            active: Math.abs(hsl.l - 0.8) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick,
            first: true
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.swatch },
          React$1.createElement(SliderSwatch, {
            hsl,
            offset: ".65",
            active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.swatch },
          React$1.createElement(SliderSwatch, {
            hsl,
            offset: ".50",
            active: Math.abs(hsl.l - 0.5) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.swatch },
          React$1.createElement(SliderSwatch, {
            hsl,
            offset: ".35",
            active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.swatch },
          React$1.createElement(SliderSwatch, {
            hsl,
            offset: ".20",
            active: Math.abs(hsl.l - 0.2) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick,
            last: true
          })
        ),
        React$1.createElement("div", { style: styles.clear })
      );
    };
    var SliderPointer = function SliderPointer2() {
      var styles = _default$2({
        "default": {
          picker: {
            width: "14px",
            height: "14px",
            borderRadius: "6px",
            transform: "translate(-7px, -1px)",
            backgroundColor: "rgb(248, 248, 248)",
            boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
          }
        }
      });
      return React$1.createElement("div", { style: styles.picker });
    };
    var Slider = function Slider2(_ref) {
      var hsl = _ref.hsl, onChange = _ref.onChange, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          hue: {
            height: "12px",
            position: "relative"
          },
          Hue: {
            radius: "2px"
          }
        }
      }, passedStyles));
      return React$1.createElement(
        "div",
        { style: styles.wrap || {}, className: "slider-picker " + className },
        React$1.createElement(
          "div",
          { style: styles.hue },
          React$1.createElement(Hue, {
            style: styles.Hue,
            hsl,
            pointer,
            onChange
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.swatches },
          React$1.createElement(SliderSwatches, { hsl, onClick: onChange })
        )
      );
    };
    Slider.propTypes = {
      styles: propTypesExports.object
    };
    Slider.defaultProps = {
      pointer: SliderPointer,
      styles: {}
    };
    ColorWrap(Slider);
    var CheckIcon = {};
    Object.defineProperty(CheckIcon, "__esModule", {
      value: true
    });
    var _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = reactExports;
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties(obj, keys2) {
      var target = {};
      for (var i2 in obj) {
        if (keys2.indexOf(i2) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i2))
          continue;
        target[i2] = obj[i2];
      }
      return target;
    }
    var DEFAULT_SIZE = 24;
    var _default = CheckIcon.default = function(_ref) {
      var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties(_ref, ["fill", "width", "height", "style"]);
      return _react2.default.createElement(
        "svg",
        _extends({
          viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
          style: _extends({ fill, width, height }, style2)
        }, props),
        _react2.default.createElement("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
      );
    };
    var SwatchesColor = function SwatchesColor2(_ref) {
      var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, first = _ref.first, last = _ref.last, active2 = _ref.active;
      var styles = _default$2({
        "default": {
          color: {
            width: "40px",
            height: "24px",
            cursor: "pointer",
            background: color,
            marginBottom: "1px"
          },
          check: {
            color: getContrastingColor(color),
            marginLeft: "8px",
            display: "none"
          }
        },
        "first": {
          color: {
            overflow: "hidden",
            borderRadius: "2px 2px 0 0"
          }
        },
        "last": {
          color: {
            overflow: "hidden",
            borderRadius: "0 0 2px 2px"
          }
        },
        "active": {
          check: {
            display: "block"
          }
        },
        "color-#FFFFFF": {
          color: {
            boxShadow: "inset 0 0 0 1px #ddd"
          },
          check: {
            color: "#333"
          }
        },
        "transparent": {
          check: {
            color: "#333"
          }
        }
      }, {
        first,
        last,
        active: active2,
        "color-#FFFFFF": color === "#FFFFFF",
        "transparent": color === "transparent"
      });
      return React$1.createElement(
        Swatch$1,
        {
          color,
          style: styles.color,
          onClick,
          onHover: onSwatchHover,
          focusStyle: { boxShadow: "0 0 4px " + color }
        },
        React$1.createElement(
          "div",
          { style: styles.check },
          React$1.createElement(_default, null)
        )
      );
    };
    var SwatchesGroup = function SwatchesGroup2(_ref) {
      var onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, group = _ref.group, active2 = _ref.active;
      var styles = _default$2({
        "default": {
          group: {
            paddingBottom: "10px",
            width: "40px",
            float: "left",
            marginRight: "10px"
          }
        }
      });
      return React$1.createElement(
        "div",
        { style: styles.group },
        map(group, function(color, i2) {
          return React$1.createElement(SwatchesColor, {
            key: color,
            color,
            active: color.toLowerCase() === active2,
            first: i2 === 0,
            last: i2 === group.length - 1,
            onClick,
            onSwatchHover
          });
        })
      );
    };
    var Swatches = function Swatches2(_ref) {
      var width = _ref.width, height = _ref.height, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          picker: {
            width,
            height
          },
          overflow: {
            height,
            overflowY: "scroll"
          },
          body: {
            padding: "16px 0 6px 16px"
          },
          clear: {
            clear: "both"
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(data, e2) {
        return onChange({ hex: data, source: "hex" }, e2);
      };
      return React$1.createElement(
        "div",
        { style: styles.picker, className: "swatches-picker " + className },
        React$1.createElement(
          Raised,
          null,
          React$1.createElement(
            "div",
            { style: styles.overflow },
            React$1.createElement(
              "div",
              { style: styles.body },
              map(colors, function(group) {
                return React$1.createElement(SwatchesGroup, {
                  key: group.toString(),
                  group,
                  active: hex,
                  onClick: handleChange,
                  onSwatchHover
                });
              }),
              React$1.createElement("div", { style: styles.clear })
            )
          )
        )
      );
    };
    Swatches.propTypes = {
      width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      height: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      colors: propTypesExports.arrayOf(propTypesExports.arrayOf(propTypesExports.string)),
      styles: propTypesExports.object
      /* eslint-disable max-len */
    };
    Swatches.defaultProps = {
      width: 320,
      height: 240,
      colors: [[red["900"], red["700"], red["500"], red["300"], red["100"]], [pink["900"], pink["700"], pink["500"], pink["300"], pink["100"]], [purple["900"], purple["700"], purple["500"], purple["300"], purple["100"]], [deepPurple["900"], deepPurple["700"], deepPurple["500"], deepPurple["300"], deepPurple["100"]], [indigo["900"], indigo["700"], indigo["500"], indigo["300"], indigo["100"]], [blue["900"], blue["700"], blue["500"], blue["300"], blue["100"]], [lightBlue["900"], lightBlue["700"], lightBlue["500"], lightBlue["300"], lightBlue["100"]], [cyan["900"], cyan["700"], cyan["500"], cyan["300"], cyan["100"]], [teal["900"], teal["700"], teal["500"], teal["300"], teal["100"]], ["#194D33", green["700"], green["500"], green["300"], green["100"]], [lightGreen["900"], lightGreen["700"], lightGreen["500"], lightGreen["300"], lightGreen["100"]], [lime["900"], lime["700"], lime["500"], lime["300"], lime["100"]], [yellow["900"], yellow["700"], yellow["500"], yellow["300"], yellow["100"]], [amber["900"], amber["700"], amber["500"], amber["300"], amber["100"]], [orange["900"], orange["700"], orange["500"], orange["300"], orange["100"]], [deepOrange["900"], deepOrange["700"], deepOrange["500"], deepOrange["300"], deepOrange["100"]], [brown["900"], brown["700"], brown["500"], brown["300"], brown["100"]], [blueGrey["900"], blueGrey["700"], blueGrey["500"], blueGrey["300"], blueGrey["100"]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
      styles: {}
    };
    ColorWrap(Swatches);
    var Twitter = function Twitter2(_ref) {
      var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          card: {
            width,
            background: "#fff",
            border: "0 solid rgba(0,0,0,0.25)",
            boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
            borderRadius: "4px",
            position: "relative"
          },
          body: {
            padding: "15px 9px 9px 15px"
          },
          label: {
            fontSize: "18px",
            color: "#fff"
          },
          triangle: {
            width: "0px",
            height: "0px",
            borderStyle: "solid",
            borderWidth: "0 9px 10px 9px",
            borderColor: "transparent transparent #fff transparent",
            position: "absolute"
          },
          triangleShadow: {
            width: "0px",
            height: "0px",
            borderStyle: "solid",
            borderWidth: "0 9px 10px 9px",
            borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
            position: "absolute"
          },
          hash: {
            background: "#F0F0F0",
            height: "30px",
            width: "30px",
            borderRadius: "4px 0 0 4px",
            float: "left",
            color: "#98A1A4",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          input: {
            width: "100px",
            fontSize: "14px",
            color: "#666",
            border: "0px",
            outline: "none",
            height: "28px",
            boxShadow: "inset 0 0 0 1px #F0F0F0",
            boxSizing: "content-box",
            borderRadius: "0 4px 4px 0",
            float: "left",
            paddingLeft: "8px"
          },
          swatch: {
            width: "30px",
            height: "30px",
            float: "left",
            borderRadius: "4px",
            margin: "0 6px 6px 0"
          },
          clear: {
            clear: "both"
          }
        },
        "hide-triangle": {
          triangle: {
            display: "none"
          },
          triangleShadow: {
            display: "none"
          }
        },
        "top-left-triangle": {
          triangle: {
            top: "-10px",
            left: "12px"
          },
          triangleShadow: {
            top: "-11px",
            left: "12px"
          }
        },
        "top-right-triangle": {
          triangle: {
            top: "-10px",
            right: "12px"
          },
          triangleShadow: {
            top: "-11px",
            right: "12px"
          }
        }
      }, passedStyles), {
        "hide-triangle": triangle === "hide",
        "top-left-triangle": triangle === "top-left",
        "top-right-triangle": triangle === "top-right"
      });
      var handleChange = function handleChange2(hexcode, e2) {
        isValidHex(hexcode) && onChange({
          hex: hexcode,
          source: "hex"
        }, e2);
      };
      return React$1.createElement(
        "div",
        { style: styles.card, className: "twitter-picker " + className },
        React$1.createElement("div", { style: styles.triangleShadow }),
        React$1.createElement("div", { style: styles.triangle }),
        React$1.createElement(
          "div",
          { style: styles.body },
          map(colors, function(c2, i2) {
            return React$1.createElement(Swatch$1, {
              key: i2,
              color: c2,
              hex: c2,
              style: styles.swatch,
              onClick: handleChange,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: "0 0 4px " + c2
              }
            });
          }),
          React$1.createElement(
            "div",
            { style: styles.hash },
            "#"
          ),
          React$1.createElement(EditableInput, {
            label: null,
            style: { input: styles.input },
            value: hex.replace("#", ""),
            onChange: handleChange
          }),
          React$1.createElement("div", { style: styles.clear })
        )
      );
    };
    Twitter.propTypes = {
      width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      triangle: propTypesExports.oneOf(["hide", "top-left", "top-right"]),
      colors: propTypesExports.arrayOf(propTypesExports.string),
      styles: propTypesExports.object
    };
    Twitter.defaultProps = {
      width: 276,
      colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
      triangle: "top-left",
      styles: {}
    };
    ColorWrap(Twitter);
    var GooglePointerCircle = function GooglePointerCircle2(props) {
      var styles = _default$2({
        "default": {
          picker: {
            width: "20px",
            height: "20px",
            borderRadius: "22px",
            border: "2px #fff solid",
            transform: "translate(-12px, -13px)",
            background: "hsl(" + Math.round(props.hsl.h) + ", " + Math.round(props.hsl.s * 100) + "%, " + Math.round(props.hsl.l * 100) + "%)"
          }
        }
      });
      return React$1.createElement("div", { style: styles.picker });
    };
    GooglePointerCircle.propTypes = {
      hsl: propTypesExports.shape({
        h: propTypesExports.number,
        s: propTypesExports.number,
        l: propTypesExports.number,
        a: propTypesExports.number
      })
    };
    GooglePointerCircle.defaultProps = {
      hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
    };
    var GooglePointer = function GooglePointer2(props) {
      var styles = _default$2({
        "default": {
          picker: {
            width: "20px",
            height: "20px",
            borderRadius: "22px",
            transform: "translate(-10px, -7px)",
            background: "hsl(" + Math.round(props.hsl.h) + ", 100%, 50%)",
            border: "2px white solid"
          }
        }
      });
      return React$1.createElement("div", { style: styles.picker });
    };
    GooglePointer.propTypes = {
      hsl: propTypesExports.shape({
        h: propTypesExports.number,
        s: propTypesExports.number,
        l: propTypesExports.number,
        a: propTypesExports.number
      })
    };
    GooglePointer.defaultProps = {
      hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
    };
    var GoogleFields = function GoogleFields2(_ref) {
      var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, hsv = _ref.hsv;
      var handleChange = function handleChange2(data, e2) {
        if (data.hex) {
          isValidHex(data.hex) && onChange({
            hex: data.hex,
            source: "hex"
          }, e2);
        } else if (data.rgb) {
          var values = data.rgb.split(",");
          isvalidColorString(data.rgb, "rgb") && onChange({
            r: values[0],
            g: values[1],
            b: values[2],
            a: 1,
            source: "rgb"
          }, e2);
        } else if (data.hsv) {
          var _values = data.hsv.split(",");
          if (isvalidColorString(data.hsv, "hsv")) {
            _values[2] = _values[2].replace("%", "");
            _values[1] = _values[1].replace("%", "");
            _values[0] = _values[0].replace("", "");
            if (_values[1] == 1) {
              _values[1] = 0.01;
            } else if (_values[2] == 1) {
              _values[2] = 0.01;
            }
            onChange({
              h: Number(_values[0]),
              s: Number(_values[1]),
              v: Number(_values[2]),
              source: "hsv"
            }, e2);
          }
        } else if (data.hsl) {
          var _values2 = data.hsl.split(",");
          if (isvalidColorString(data.hsl, "hsl")) {
            _values2[2] = _values2[2].replace("%", "");
            _values2[1] = _values2[1].replace("%", "");
            _values2[0] = _values2[0].replace("", "");
            if (hsvValue[1] == 1) {
              hsvValue[1] = 0.01;
            } else if (hsvValue[2] == 1) {
              hsvValue[2] = 0.01;
            }
            onChange({
              h: Number(_values2[0]),
              s: Number(_values2[1]),
              v: Number(_values2[2]),
              source: "hsl"
            }, e2);
          }
        }
      };
      var styles = _default$2({
        "default": {
          wrap: {
            display: "flex",
            height: "100px",
            marginTop: "4px"
          },
          fields: {
            width: "100%"
          },
          column: {
            paddingTop: "10px",
            display: "flex",
            justifyContent: "space-between"
          },
          double: {
            padding: "0px 4.4px",
            boxSizing: "border-box"
          },
          input: {
            width: "100%",
            height: "38px",
            boxSizing: "border-box",
            padding: "4px 10% 3px",
            textAlign: "center",
            border: "1px solid #dadce0",
            fontSize: "11px",
            textTransform: "lowercase",
            borderRadius: "5px",
            outline: "none",
            fontFamily: "Roboto,Arial,sans-serif"
          },
          input2: {
            height: "38px",
            width: "100%",
            border: "1px solid #dadce0",
            boxSizing: "border-box",
            fontSize: "11px",
            textTransform: "lowercase",
            borderRadius: "5px",
            outline: "none",
            paddingLeft: "10px",
            fontFamily: "Roboto,Arial,sans-serif"
          },
          label: {
            textAlign: "center",
            fontSize: "12px",
            background: "#fff",
            position: "absolute",
            textTransform: "uppercase",
            color: "#3c4043",
            width: "35px",
            top: "-6px",
            left: "0",
            right: "0",
            marginLeft: "auto",
            marginRight: "auto",
            fontFamily: "Roboto,Arial,sans-serif"
          },
          label2: {
            left: "10px",
            textAlign: "center",
            fontSize: "12px",
            background: "#fff",
            position: "absolute",
            textTransform: "uppercase",
            color: "#3c4043",
            width: "32px",
            top: "-6px",
            fontFamily: "Roboto,Arial,sans-serif"
          },
          single: {
            flexGrow: "1",
            margin: "0px 4.4px"
          }
        }
      });
      var rgbValue = rgb.r + ", " + rgb.g + ", " + rgb.b;
      var hslValue = Math.round(hsl.h) + ", " + Math.round(hsl.s * 100) + "%, " + Math.round(hsl.l * 100) + "%";
      var hsvValue = Math.round(hsv.h) + ", " + Math.round(hsv.s * 100) + "%, " + Math.round(hsv.v * 100) + "%";
      return React$1.createElement(
        "div",
        { style: styles.wrap, className: "flexbox-fix" },
        React$1.createElement(
          "div",
          { style: styles.fields },
          React$1.createElement(
            "div",
            { style: styles.double },
            React$1.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "hex",
              value: hex,
              onChange: handleChange
            })
          ),
          React$1.createElement(
            "div",
            { style: styles.column },
            React$1.createElement(
              "div",
              { style: styles.single },
              React$1.createElement(EditableInput, {
                style: { input: styles.input2, label: styles.label2 },
                label: "rgb",
                value: rgbValue,
                onChange: handleChange
              })
            ),
            React$1.createElement(
              "div",
              { style: styles.single },
              React$1.createElement(EditableInput, {
                style: { input: styles.input2, label: styles.label2 },
                label: "hsv",
                value: hsvValue,
                onChange: handleChange
              })
            ),
            React$1.createElement(
              "div",
              { style: styles.single },
              React$1.createElement(EditableInput, {
                style: { input: styles.input2, label: styles.label2 },
                label: "hsl",
                value: hslValue,
                onChange: handleChange
              })
            )
          )
        )
      );
    };
    var Google = function Google2(_ref) {
      var width = _ref.width, onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, header = _ref.header, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles = _default$2(merge$1({
        "default": {
          picker: {
            width,
            background: "#fff",
            border: "1px solid #dfe1e5",
            boxSizing: "initial",
            display: "flex",
            flexWrap: "wrap",
            borderRadius: "8px 8px 0px 0px"
          },
          head: {
            height: "57px",
            width: "100%",
            paddingTop: "16px",
            paddingBottom: "16px",
            paddingLeft: "16px",
            fontSize: "20px",
            boxSizing: "border-box",
            fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
          },
          saturation: {
            width: "70%",
            padding: "0px",
            position: "relative",
            overflow: "hidden"
          },
          swatch: {
            width: "30%",
            height: "228px",
            padding: "0px",
            background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", 1)",
            position: "relative",
            overflow: "hidden"
          },
          body: {
            margin: "auto",
            width: "95%"
          },
          controls: {
            display: "flex",
            boxSizing: "border-box",
            height: "52px",
            paddingTop: "22px"
          },
          color: {
            width: "32px"
          },
          hue: {
            height: "8px",
            position: "relative",
            margin: "0px 16px 0px 16px",
            width: "100%"
          },
          Hue: {
            radius: "2px"
          }
        }
      }, passedStyles));
      return React$1.createElement(
        "div",
        { style: styles.picker, className: "google-picker " + className },
        React$1.createElement(
          "div",
          { style: styles.head },
          header
        ),
        React$1.createElement("div", { style: styles.swatch }),
        React$1.createElement(
          "div",
          { style: styles.saturation },
          React$1.createElement(Saturation, {
            hsl,
            hsv,
            pointer: GooglePointerCircle,
            onChange
          })
        ),
        React$1.createElement(
          "div",
          { style: styles.body },
          React$1.createElement(
            "div",
            { style: styles.controls, className: "flexbox-fix" },
            React$1.createElement(
              "div",
              { style: styles.hue },
              React$1.createElement(Hue, {
                style: styles.Hue,
                hsl,
                radius: "4px",
                pointer: GooglePointer,
                onChange
              })
            )
          ),
          React$1.createElement(GoogleFields, {
            rgb,
            hsl,
            hex,
            hsv,
            onChange
          })
        )
      );
    };
    Google.propTypes = {
      width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
      styles: propTypesExports.object,
      header: propTypesExports.string
    };
    Google.defaultProps = {
      width: 652,
      styles: {},
      header: "Color picker"
    };
    ColorWrap(Google);
    const { Text } = Typography$1;
    function convertBalance(balance) {
      return (balance.slice(0, -24) + "," + balance.slice(-24)).slice(0, 5);
    }
    function App() {
      const { isInitializedContext, signUp, signIn, signOut, setNearColor } = useNear();
      const [account2, setAccount] = reactExports.useState("");
      const [accountBalance, setAccountBalance] = reactExports.useState({});
      const [color, setColor] = reactExports.useState([0, 0, 0]);
      const timerID = reactExports.useRef(0);
      function colorHandler(color2) {
        clearTimeout(timerID.current);
        timerID.current = setTimeout(async () => {
          const result = await setNearColor([color2.rgb.r, color2.rgb.g, color2.rgb.b]);
          setColor(result);
        }, 1e3);
      }
      reactExports.useEffect(() => {
        if (location.hash === "#hack") {
          location.href = location.origin + location.pathname;
        }
      }, []);
      reactExports.useEffect(() => {
        if (!isInitializedContext)
          return;
        (async () => {
          const { accountID, accountBalance: accountBalance2, color: color2 } = await signUp();
          setAccount(accountID);
          setAccountBalance(accountBalance2);
          setColor(color2);
        })();
      }, [isInitializedContext]);
      return /* @__PURE__ */ jsxs("div", { children: [
        /* @__PURE__ */ jsxs("div", { children: [
          account2 && /* @__PURE__ */ jsxs(Text, { children: [
            " ",
            /* @__PURE__ */ jsx("strong", { children: account2 })
          ] }),
          /* @__PURE__ */ jsx("br", {}),
          accountBalance.available && /* @__PURE__ */ jsxs(Text, { children: [
            " ",
            /* @__PURE__ */ jsx("strong", { children: convertBalance(accountBalance.available) }),
            " NEAR "
          ] })
        ] }),
        /* @__PURE__ */ jsx("br", {}),
        account2 && /* @__PURE__ */ jsx(
          CompactPicker,
          {
            onChange: colorHandler,
            color: { r: color[0], g: color[1], b: color[2] }
          }
        ),
        /* @__PURE__ */ jsx("br", {}),
        /* @__PURE__ */ jsx("br", {}),
        /* @__PURE__ */ jsxs("div", { children: [
          !account2 && /* @__PURE__ */ jsx(Button$1, { type: "primary", onClick: signIn, children: "Sign In" }),
          account2 && /* @__PURE__ */ jsx(Button$1, { type: "primary", onClick: () => {
            signOut();
            setAccount("");
            setAccountBalance({});
          }, children: "Sign Out" })
        ] })
      ] });
    }
    client.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsx(React$1.StrictMode, { children: /* @__PURE__ */ jsx(NearContextProvider, { children: /* @__PURE__ */ jsx(App, {}) }) })
    );
  }
});
export default require_index_001();
